/*
 * RCEngine - v4.3.0-alpha.8
 * CommitId - 6c6ffee27a93e4fce8289ae56803f3c019f915c0
 * Wed Mar 03 2021 20:39:29 GMT+0800 (中国标准时间)
 * ©2020 RongCloud, Inc. All rights reserved.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RCEngine = {}));
}(this, (function (exports) { 'use strict';

  var ReceivedStatus;

  (function (ReceivedStatus) {
    /**
     * 已读
    */
    ReceivedStatus[ReceivedStatus["READ"] = 1] = "READ";
    /**
     * 已听
    */

    ReceivedStatus[ReceivedStatus["LISTENED"] = 2] = "LISTENED";
    /**
     * 已下载
    */

    ReceivedStatus[ReceivedStatus["DOWNLOADED"] = 4] = "DOWNLOADED";
    /**
     * 该消息已经被其他登录的多端收取过。( 即该消息已经被其他端收取过后。当前端才登录，并重新拉取了这条消息。客户可以通过这个状态更新 UI，比如不再提示 )
    */

    ReceivedStatus[ReceivedStatus["RETRIEVED"] = 8] = "RETRIEVED";
    /**
     * 未读
    */

    ReceivedStatus[ReceivedStatus["UNREAD"] = 0] = "UNREAD";
  })(ReceivedStatus || (ReceivedStatus = {}));

  var ReceivedStatus$1 = ReceivedStatus;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn) {
    var module = { exports: {} };
    return fn(module, module.exports), module.exports;
  }

  var check = function (it) {
    return it && it.Math == Math && it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global$1 =
    /* global globalThis -- safe */
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func -- fallback
    (function () { return this; })() || Function('return this')();

  var fails = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  // Detect IE8's incomplete defineProperty implementation
  var descriptors = !fails(function () {
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable;

  var objectPropertyIsEnumerable = {
    f: f
  };

  var createPropertyDescriptor = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var toString = {}.toString;

  var classofRaw = function (it) {
    return toString.call(it).slice(8, -1);
  };

  var split = ''.split;

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
  } : Object;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function (it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings



  var toIndexedObject = function (it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var toPrimitive = function (input, PREFERRED_STRING) {
    if (!isObject(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var document$1 = global$1.document;
  // typeof document.createElement is 'object' in old IE
  var EXISTS = isObject(document$1) && isObject(document$1.createElement);

  var documentCreateElement = function (it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  // Thank's IE8 for his funny defineProperty
  var ie8DomDefine = !descriptors && !fails(function () {
    return Object.defineProperty(documentCreateElement('div'), 'a', {
      get: function () { return 7; }
    }).a != 7;
  });

  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPrimitive(P, true);
    if (ie8DomDefine) try {
      return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) { /* empty */ }
    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
  };

  var objectGetOwnPropertyDescriptor = {
    f: f$1
  };

  var anObject = function (it) {
    if (!isObject(it)) {
      throw TypeError(String(it) + ' is not an object');
    } return it;
  };

  var nativeDefineProperty = Object.defineProperty;

  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return nativeDefineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var objectDefineProperty = {
    f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var setGlobal = function (key, value) {
    try {
      createNonEnumerableProperty(global$1, key, value);
    } catch (error) {
      global$1[key] = value;
    } return value;
  };

  var SHARED = '__core-js_shared__';
  var store = global$1[SHARED] || setGlobal(SHARED, {});

  var sharedStore = store;

  var functionToString = Function.toString;

  // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
  if (typeof sharedStore.inspectSource != 'function') {
    sharedStore.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap = global$1.WeakMap;

  var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

  var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.9.0',
    mode: 'global',
    copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id = 0;
  var postfix = Math.random();

  var uid = function (key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
  };

  var keys = shared('keys');

  var sharedKey = function (key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var WeakMap$1 = global$1.WeakMap;
  var set, get, has$1;

  var enforce = function (it) {
    return has$1(it) ? get(it) : set(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError('Incompatible receiver, ' + TYPE + ' required');
      } return state;
    };
  };

  if (nativeWeakMap) {
    var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());
    var wmget = store$1.get;
    var wmhas = store$1.has;
    var wmset = store$1.set;
    set = function (it, metadata) {
      metadata.facade = it;
      wmset.call(store$1, it, metadata);
      return metadata;
    };
    get = function (it) {
      return wmget.call(store$1, it) || {};
    };
    has$1 = function (it) {
      return wmhas.call(store$1, it);
    };
  } else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;
    set = function (it, metadata) {
      metadata.facade = it;
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };
    get = function (it) {
      return has(it, STATE) ? it[STATE] : {};
    };
    has$1 = function (it) {
      return has(it, STATE);
    };
  }

  var internalState = {
    set: set,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
  };

  var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(String).split('String');

  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    var state;
    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) {
        createNonEnumerableProperty(value, 'name', key);
      }
      state = enforceInternalState(value);
      if (!state.source) {
        state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
      }
    }
    if (O === global$1) {
      if (simple) O[key] = value;
      else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
  });
  });

  var path = global$1;

  var aFunction = function (variable) {
    return typeof variable == 'function' ? variable : undefined;
  };

  var getBuiltIn = function (namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global$1[namespace])
      : path[namespace] && path[namespace][method] || global$1[namespace] && global$1[namespace][method];
  };

  var ceil = Math.ceil;
  var floor = Math.floor;

  // `ToInteger` abstract operation
  // https://tc39.es/ecma262/#sec-tointeger
  var toInteger = function (argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
  };

  var min = Math.min;

  // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength
  var toLength = function (argument) {
    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex = function (index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare -- NaN check
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;


  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
  ];

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
    f: f$3
  };

  var f$4 = Object.getOwnPropertySymbols;

  var objectGetOwnPropertySymbols = {
    f: f$4
  };

  // all object keys, includes non-enumerable and symbols
  var ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function (target, source) {
    var keys = ownKeys$1(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : typeof detection == 'function' ? fails(detection)
      : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = 'N';
  var POLYFILL = isForced.POLYFILL = 'P';

  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$1;
    } else if (STATIC) {
      target = global$1[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global$1[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
      // contained in target
      if (!FORCED && targetProperty !== undefined) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      // add a flag to not completely full polyfills
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty(sourceProperty, 'sham', true);
      }
      // extend global
      redefine(target, key, sourceProperty, options);
    }
  };

  // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  var isArray = Array.isArray || function isArray(arg) {
    return classofRaw(arg) == 'Array';
  };

  // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject
  var toObject = function (argument) {
    return Object(requireObjectCoercible(argument));
  };

  var createProperty = function (object, key, value) {
    var propertyKey = toPrimitive(key);
    if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
    // Chrome 38 Symbol has incorrect toString conversion
    /* global Symbol -- required for testing */
    return !String(Symbol());
  });

  var useSymbolAsUid = nativeSymbol
    /* global Symbol -- safe */
    && !Symbol.sham
    && typeof Symbol.iterator == 'symbol';

  var WellKnownSymbolsStore = shared('wks');
  var Symbol$1 = global$1.Symbol;
  var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

  var wellKnownSymbol = function (name) {
    if (!has(WellKnownSymbolsStore, name)) {
      if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
      else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    } return WellKnownSymbolsStore[name];
  };

  var SPECIES = wellKnownSymbol('species');

  // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate
  var arraySpeciesCreate = function (originalArray, length) {
    var C;
    if (isArray(originalArray)) {
      C = originalArray.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      else if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
  };

  var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

  var process$1 = global$1.process;
  var versions = process$1 && process$1.versions;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    version = match[0] + match[1];
  } else if (engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version && +version;

  var SPECIES$1 = wellKnownSymbol('species');

  var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return engineV8Version >= 51 || !fails(function () {
      var array = [];
      var constructor = array.constructor = {};
      constructor[SPECIES$1] = function () {
        return { foo: 1 };
      };
      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679
  var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });

  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

  var isConcatSpreadable = function (O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
  };

  var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

  // `Array.prototype.concat` method
  // https://tc39.es/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species
  _export({ target: 'Array', proto: true, forced: FORCED }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat(arg) {
      var O = toObject(this);
      var A = arraySpeciesCreate(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = toLength(E.length);
          if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
        } else {
          if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });

  /**
   * Navi 缓存数据有效时长，单位毫秒
   */
  var NAVI_CACHE_DURATION = 2 * 60 * 60 * 1000;
  /**
   * 单个 Navi 请求的超时时间，单位毫秒
   */

  var NAVI_REQ_TIMEOUT = 10 * 1000;
  /**
   * /ping?r= 请求的超时时间，单位毫秒
   */

  var PING_REQ_TIMEOUT = 5 * 1000;
  /**
   * WebSocket 建立连接超时时间，单位毫秒
   */

  var WEB_SOCKET_TIMEOUT = 5 * 1000;
  /**
   * 公有云 Navi 请求地址
   */

  var PUBLIC_CLOUD_NAVI_URIS = ['http://navqa.cn.ronghub.com','https://nav.cn.ronghub.com', 'https://nav2-cn.ronghub.com'];
  /**
   * 小程序 websocket 连接地址
   */

  var MINI_SOCKET_CONNECT_URIS = ['wsproxy.cn.ronghub.com', 'wsap-cn.ronghub.com'];
  /**
   * 小程序 长轮询 连接地址
   */

  var MINI_COMET_CONNECT_URIS = ['cometproxy-cn.ronghub.com', 'mini-cn.ronghub.com'];
  /**
   * IM 接口超时时间，单位毫秒
   */

  var IM_SIGNAL_TIMEOUT = 30 * 1000;
  /**
   * IM Ping 间隔时间，单位毫秒
   */

  var IM_PING_INTERVAL_TIME = 30 * 1000;
  /**
   * IM Ping 最大超时时间，单位毫秒
   */

  var IM_PING_MAX_TIMEOUT = 6 * 1000;
  /**
   * IM Ping 最小超时时间，单位毫秒
   */

  var IM_PING_MIN_TIMEOUT = 2 * 1000;
  /**
   * 消息 content 内容尺寸限制：128 KB
   */

  var MAX_MESSAGE_CONTENT_BYTES = 128 * 1024;
  /**
   * IM Comet 发送 pullmsg(嗅探 + 等待信令) 超时时间 45s
   */

  var IM_COMET_PULLMSG_TIMEOUT = 45000;
  /**
   * storage key 使用的前缀
  */

  var STORAGE_ROOT_KEY = 'RCV4-';
  /*
   * 内置消息的配置项. 发消息时, objectName 匹配到以下项时, 将覆盖用户传入值
   * 内置消息文档: https://docs.rongcloud.cn/im/introduction/message_structure/#inherent
   * 'RC:DizNtf' 为讨论组消息通知类型，讨论组已废弃
  */

  var SEND_MESSAGE_TYPE_OPTION = {
    // 存储且计数
    'RC:TxtMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:ImgMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:VcMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:ImgTextMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:FileMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:HQVCMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:LBSMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:PSImgTxtMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:PSMultiImgTxtMsg': {
      isCounted: true,
      isPersited: true
    },
    'RCJrmf:RpMsg': {
      isCounted: true,
      isPersited: true
    },
    'RCJrmf:RpOpendMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:CombineMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:ReferenceMsg': {
      isCounted: true,
      isPersited: true
    },
    'RC:SightMsg': {
      isCounted: true,
      isPersited: true
    },
    // 只存储 不计数
    'RC:InfoNtf': {
      isCounted: false,
      isPersited: true
    },
    'RC:ContactNtf': {
      isCounted: false,
      isPersited: true
    },
    'RC:ProfileNtf': {
      isCounted: false,
      isPersited: true
    },
    'RC:CmdNtf': {
      isCounted: false,
      isPersited: true
    },
    'RC:GrpNtf': {
      isCounted: false,
      isPersited: true
    },
    'RC:RcCmd': {
      isCounted: false,
      isPersited: true
    },
    // 不存储 只计数 - 目前无
    // 不存储 不计数
    'RC:CmdMsg': {
      isCounted: false,
      isPersited: false
    },
    'RC:TypSts': {
      isCounted: false,
      isPersited: false
    },
    'RC:PSCmd': {
      isCounted: false,
      isPersited: false
    },
    'RC:SRSMsg': {
      isCounted: false,
      isPersited: false
    },
    'RC:RRReqMsg': {
      isCounted: false,
      isPersited: false
    },
    'RC:RRRspMsg': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsChaR': {
      isCounted: false,
      isPersited: false
    },
    'RC:CSCha': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsEva': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsContact': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsHs': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsHsR': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsSp': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsEnd': {
      isCounted: false,
      isPersited: false
    },
    'RC:CsUpdate': {
      isCounted: false,
      isPersited: false
    },
    'RC:ReadNtf': {
      isCounted: false,
      isPersited: false
    },
    'RC:chrmKVNotiMsg': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCAccept': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCRinging': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCSummary': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCHangup': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCInvite': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCModifyMedia': {
      isCounted: false,
      isPersited: false
    },
    'RC:VCModifyMem': {
      isCounted: false,
      isPersited: false
    },
    'RC:MsgExMsg': {
      isCounted: false,
      isPersited: false
    }
  };
  /**
   * 协议栈内置消息类型
   * TODO: 需确认是否添加到 Web 中
  */

  var CPP_PROTOCAL_MSGTYPE_OPTION = {
    // 讨论组通知
    'RC:DizNtf': {
      isCounted: false,
      isPersited: false
    }
  };

  var rootStorage;
  var createRootStorage = function createRootStorage(runtime) {
    if (!rootStorage) {
      rootStorage = {
        set: function set(key, val) {
          runtime.localStorage.setItem(key, JSON.stringify(val));
        },
        get: function get(key) {
          var val;

          try {
            val = JSON.parse(runtime.localStorage.getItem(key));
          } catch (e) {
            val = null;
          }

          return val;
        },
        remove: function remove(key) {
          return runtime.localStorage.removeItem(key);
        },
        getKeys: function getKeys() {
          var keys = [];

          for (var key in runtime.localStorage) {
            keys.push(key);
          }

          return keys;
        }
      };
    }

    return rootStorage;
  };
  var AppCache = /*#__PURE__*/function () {
    function AppCache(value) {
      _classCallCheck(this, AppCache);

      this._caches = {};

      if (value) {
        this._caches = value;
      }
    }

    _createClass(AppCache, [{
      key: "set",
      value: function set(key, value) {
        this._caches[key] = value;
      }
    }, {
      key: "remove",
      value: function remove(key) {
        var val = this.get(key);
        delete this._caches[key];
        return val;
      }
    }, {
      key: "get",
      value: function get(key) {
        return this._caches[key];
      }
    }, {
      key: "getKeys",
      value: function getKeys() {
        var keys = [];

        for (var key in this._caches) {
          keys.push(key);
        }

        return keys;
      }
    }]);

    return AppCache;
  }();
  var AppStorage = /*#__PURE__*/function () {
    function AppStorage(runtime, suffix) {
      _classCallCheck(this, AppStorage);

      var key = suffix ? "".concat(STORAGE_ROOT_KEY).concat(suffix) : STORAGE_ROOT_KEY;
      this._rootStorage = createRootStorage(runtime);
      var localCache = this._rootStorage.get(key) || {};
      this._cache = new AppCache(_defineProperty({}, key, localCache));
      this._storageKey = key;
    }

    _createClass(AppStorage, [{
      key: "_get",
      value: function _get() {
        var key = this._storageKey;
        return this._cache.get(key) || {};
      }
    }, {
      key: "_set",
      value: function _set(cache) {
        var key = this._storageKey;
        cache = cache || {};

        this._cache.set(key, cache);

        this._rootStorage.set(key, cache);
      }
    }, {
      key: "set",
      value: function set(key, value) {
        var localValue = this._get();

        localValue[key] = value;

        this._set(localValue);
      }
    }, {
      key: "remove",
      value: function remove(key) {
        var localValue = this._get();

        delete localValue[key];

        this._set(localValue);
      }
    }, {
      key: "clear",
      value: function clear() {
        var key = this._storageKey;

        this._rootStorage.remove(key);

        this._cache.remove(key);
      }
    }, {
      key: "get",
      value: function get(key) {
        var localValue = this._get();

        return localValue[key];
      }
    }, {
      key: "getKeys",
      value: function getKeys() {
        var localValue = this._get();

        var keyList = [];

        for (var key in localValue) {
          keyList.push(key);
        }

        return keyList;
      }
    }, {
      key: "getValues",
      value: function getValues() {
        return this._get() || {};
      }
    }]);

    return AppStorage;
  }();

  var Todo = /*#__PURE__*/function (_Error) {
    _inherits(Todo, _Error);

    var _super = _createSuper(Todo);

    function Todo(message) {
      _classCallCheck(this, Todo);

      return _super.call(this, "TODO => ".concat(message));
    }

    return Todo;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var todo = function todo(message) {
    return new Todo(message);
  };

  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

  var SPECIES$2 = wellKnownSymbol('species');
  var nativeSlice = [].slice;
  var max$1 = Math.max;

  // `Array.prototype.slice` method
  // https://tc39.es/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    slice: function slice(start, end) {
      var O = toIndexedObject(this);
      var length = toLength(O.length);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
      var Constructor, result, n;
      if (isArray(O)) {
        Constructor = O.constructor;
        // cross-realm fallback
        if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject(Constructor)) {
          Constructor = Constructor[SPECIES$2];
          if (Constructor === null) Constructor = undefined;
        }
        if (Constructor === Array || Constructor === undefined) {
          return nativeSlice.call(O, k, fin);
        }
      }
      result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
      for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
      result.length = n;
      return result;
    }
  });

  // `RegExp.prototype.flags` getter implementation
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
  var regexpFlags = function () {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };

  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
  // so we use an intermediate function.
  function RE(s, f) {
    return RegExp(s, f);
  }

  var UNSUPPORTED_Y = fails(function () {
    // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
    var re = RE('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
  });

  var BROKEN_CARET = fails(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = RE('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
  });

  var regexpStickyHelpers = {
    UNSUPPORTED_Y: UNSUPPORTED_Y,
    BROKEN_CARET: BROKEN_CARET
  };

  var nativeExec = RegExp.prototype.exec;
  // This always refers to the native implementation, because the
  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
  // which loads this file before patching the method.
  var nativeReplace = String.prototype.replace;

  var patchedExec = nativeExec;

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();

  var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

  // nonparticipating capturing group, copied from es5-shim's String#split patch.
  // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

  if (PATCH) {
    patchedExec = function exec(str) {
      var re = this;
      var lastIndex, reCopy, match, i;
      var sticky = UNSUPPORTED_Y$1 && re.sticky;
      var flags = regexpFlags.call(re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = flags.replace('y', '');
        if (flags.indexOf('g') === -1) {
          flags += 'g';
        }

        strCopy = String(str).slice(re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
          source = '(?: ' + source + ')';
          strCopy = ' ' + strCopy;
          charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

      match = nativeExec.call(sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = match.input.slice(charsAdded);
          match[0] = match[0].slice(charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        nativeReplace.call(match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      return match;
    };
  }

  var regexpExec = patchedExec;

  // `RegExp.prototype.exec` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.exec
  _export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
    exec: regexpExec
  });

  // TODO: Remove from `core-js@4` since it's moved to entry points







  var SPECIES$3 = wellKnownSymbol('species');

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a "grops" property.
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: '7' };
      return result;
    };
    return ''.replace(re, '$<a>') !== '7';
  });

  // IE <= 11 replaces $0 with the whole match, as if it was $&
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
  var REPLACE_KEEPS_$0 = (function () {
    return 'a'.replace(/./, '$0') === '$0';
  })();

  var REPLACE = wellKnownSymbol('replace');
  // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
    if (/./[REPLACE]) {
      return /./[REPLACE]('a', '$0') === '';
    }
    return false;
  })();

  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
  });

  var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
    var SYMBOL = wellKnownSymbol(KEY);

    var DELEGATES_TO_SYMBOL = !fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === 'split') {
        // We can't use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {};
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES$3] = function () { return re; };
        re.flags = '';
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () { execCalled = true; return null; };

      re[SYMBOL]('');
      return !execCalled;
    });

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      (KEY === 'replace' && !(
        REPLACE_SUPPORTS_NAMED_GROUPS &&
        REPLACE_KEEPS_$0 &&
        !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      )) ||
      (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
    ) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }, {
        REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      });
      var stringMethod = methods[0];
      var regexMethod = methods[1];

      redefine(String.prototype, KEY, stringMethod);
      redefine(RegExp.prototype, SYMBOL, length == 2
        // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) { return regexMethod.call(string, this, arg); }
        // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) { return regexMethod.call(string, this); }
      );
    }

    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
  };

  // `String.prototype.{ codePointAt, at }` methods implementation
  var createMethod$1 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = String(requireObjectCoercible($this));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING ? S.charAt(position) : first
          : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$1(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$1(true)
  };

  var charAt = stringMultibyte.charAt;

  // `AdvanceStringIndex` abstract operation
  // https://tc39.es/ecma262/#sec-advancestringindex
  var advanceStringIndex = function (S, index, unicode) {
    return index + (unicode ? charAt(S, index).length : 1);
  };

  var floor$1 = Math.floor;
  var replace = ''.replace;
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

  // https://tc39.es/ecma262/#sec-getsubstitution
  var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor$1(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  };

  // `RegExpExec` abstract operation
  // https://tc39.es/ecma262/#sec-regexpexec
  var regexpExecAbstract = function (R, S) {
    var exec = R.exec;
    if (typeof exec === 'function') {
      var result = exec.call(R, S);
      if (typeof result !== 'object') {
        throw TypeError('RegExp exec method returned something other than an Object or null');
      }
      return result;
    }

    if (classofRaw(R) !== 'RegExp') {
      throw TypeError('RegExp#exec called on incompatible receiver');
    }

    return regexpExec.call(R, S);
  };

  var max$2 = Math.max;
  var min$2 = Math.min;

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // @@replace logic
  fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
    var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
        return replacer !== undefined
          ? replacer.call(searchValue, O, replaceValue)
          : nativeReplace.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        if (
          (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
          (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
        ) {
          var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
          if (res.done) return res.value;
        }

        var rx = anObject(regexp);
        var S = String(this);

        var functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = String(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regexpExecAbstract(rx, S);
          if (result === null) break;

          results.push(result);
          if (!global) break;

          var matchStr = String(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = String(result[0]);
          var position = max$2(min$2(toInteger(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];
  });

  var aFunction$1 = function (it) {
    if (typeof it != 'function') {
      throw TypeError(String(it) + ' is not a function');
    } return it;
  };

  // optional / simple context binding
  var functionBindContext = function (fn, that, length) {
    aFunction$1(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 0: return function () {
        return fn.call(that);
      };
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var push = [].push;

  // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
  var createMethod$2 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_OUT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = indexedObject(O);
      var boundFunction = functionBindContext(callbackfn, that, 3);
      var length = toLength(self.length);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
      var value, result;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3: return true;              // some
            case 5: return value;             // find
            case 6: return index;             // findIndex
            case 2: push.call(target, value); // filter
          } else switch (TYPE) {
            case 4: return false;             // every
            case 7: push.call(target, value); // filterOut
          }
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$2(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$2(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$2(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$2(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$2(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$2(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$2(6),
    // `Array.prototype.filterOut` method
    // https://github.com/tc39/proposal-array-filtering
    filterOut: createMethod$2(7)
  };

  var $filter = arrayIteration.filter;


  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('filter');

  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
    filter: function filter(callbackfn /* , thisArg */) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $map = arrayIteration.map;


  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('map');

  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
    map: function map(callbackfn /* , thisArg */) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  _export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
    keys: function keys(it) {
      return objectKeys(toObject(it));
    }
  });

  var arrayMethodIsStrict = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function () {
      // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
      method.call(null, argument || function () { throw 1; }, 1);
    });
  };

  var nativeJoin = [].join;

  var ES3_STRINGS = indexedObject != Object;
  var STRICT_METHOD = arrayMethodIsStrict('join', ',');

  // `Array.prototype.join` method
  // https://tc39.es/ecma262/#sec-array.prototype.join
  _export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
    join: function join(separator) {
      return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
  });

  // @@match logic
  fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        if (!rx.global) return regexpExecAbstract(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regexpExecAbstract(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });

  /**
   * 字符串转为大写形式并返回
   * @todo 违反单一性原则，后续需分拆，以及需要评估是否过渡封装
   * @param str
   * @param startIndex 开始位置
   * @param endIndex 结束位置
  */
  var toUpperCase = function toUpperCase(str, startIndex, endIndex) {
    if (startIndex === undefined || endIndex === undefined) {
      return str.toUpperCase();
    }

    var sliceStr = str.slice(startIndex, endIndex);
    str = str.replace(sliceStr, function (text) {
      return text.toUpperCase();
    });
    return str;
  };
  var getByteLength = function getByteLength(str) {
    var charset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf-8';
    var total = 0;
    var chatCode;

    if (charset === 'utf-16') {
      for (var i = 0, max = str.length; i < max; i++) {
        chatCode = str.charCodeAt(i);

        if (chatCode <= 0xffff) {
          total += 2;
        } else {
          total += 4;
        }
      }
    } else {
      for (var _i = 0, _max = str.length; _i < _max; _i++) {
        chatCode = str.charCodeAt(_i);

        if (chatCode < 0x007f) {
          total += 1;
        } else if (chatCode <= 0x07ff) {
          total += 2;
        } else if (chatCode <= 0xffff) {
          total += 3;
        } else {
          total += 4;
        }
      }
    }

    return total;
  };
  var appendUrl = function appendUrl(url, query) {
    url = url.replace(/\?$/, '');

    if (!query) {
      return url;
    }

    var searchArr = Object.keys(query).map(function (key) {
      return "".concat(key, "=").concat(query[key]);
    }).filter(function (item) {
      return !!item;
    });

    if (searchArr.length) {
      return [url, searchArr.join('&')].join('?');
    }

    return url;
  };
  /**
   * 建立连接时，apiVersion 需符合 `/\d+(\.\d+){2}/` 规则，对于预发布版本号如 `3.1.0-alpha.1`，需解析定为 `3.1.0`
   * @param apiVersion
   */

  var matchVersion = function matchVersion(apiVersion) {
    var matches = apiVersion.match(/\d+(\.\d+){2}/);
    return matches[0];
  };

  exports.LogLevel = void 0;

  (function (LogLevel) {
    /**
     * 等同于 `LogLevel.DEBUG`
     */
    LogLevel[LogLevel["LOG"] = 0] = "LOG";
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    LogLevel[LogLevel["NONE"] = 1000] = "NONE";
  })(exports.LogLevel || (exports.LogLevel = {}));

  var _methods;
  var methods = (_methods = {}, _defineProperty(_methods, exports.LogLevel.DEBUG, console.debug.bind(console)), _defineProperty(_methods, exports.LogLevel.INFO, console.info.bind(console)), _defineProperty(_methods, exports.LogLevel.WARN, console.warn.bind(console)), _defineProperty(_methods, exports.LogLevel.ERROR, console.error.bind(console)), _methods);
  var Logger = /*#__PURE__*/function () {
    function Logger(tag) {
      _classCallCheck(this, Logger);

      this.tag = tag;
      /**
       * 输出等级
       */

      this._outLevel = exports.LogLevel.WARN;
      /**
       * 输出函数
       */

      this._stdout = this._defaultStdout;
      this.log = this._out;
      this.debug = this._out.bind(this, exports.LogLevel.DEBUG);
      this.info = this._out.bind(this, exports.LogLevel.INFO);
      this.warn = this._out.bind(this, exports.LogLevel.WARN);
      this.error = this._out.bind(this, exports.LogLevel.ERROR);
    }
    /**
     * 默认输出函数
     * @param level
     * @param args
     */


    _createClass(Logger, [{
      key: "_defaultStdout",
      value: function _defaultStdout(level) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        methods[level].apply(methods, ["[".concat(this.tag, "](").concat(new Date().toUTCString(), "):")].concat(args));
      }
    }, {
      key: "_out",
      value: function _out(level) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        level >= this._outLevel && this._stdout.apply(this, [level].concat(args));
      }
      /**
       * 设置默认输出等级及输出函数
       * @param outLevel
       * @param stdout
       */

    }, {
      key: "set",
      value: function set(outLevel, stdout) {
        this._outLevel = outLevel !== undefined ? outLevel : exports.LogLevel.WARN;
        this._stdout = stdout || this._defaultStdout;
      }
    }]);

    return Logger;
  }();
  var logger = new Logger('RCLog');
  logger.set(exports.LogLevel.DEBUG );

  var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  var test = {};

  test[TO_STRING_TAG] = 'z';

  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
  };

  // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return '[object ' + classof(this) + ']';
  };

  // `Object.prototype.toString` method
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (!toStringTagSupport) {
    redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
  }

  /**
   * 会话类型
   */
  var ConversationType;

  (function (ConversationType) {
    /**
     * 无类型
     */
    ConversationType[ConversationType["NONE"] = 0] = "NONE";
    /**
     * 单聊
     */

    ConversationType[ConversationType["PRIVATE"] = 1] = "PRIVATE";
    /**
     * 讨论组
     */

    ConversationType[ConversationType["DISCUSSION"] = 2] = "DISCUSSION";
    /**
     * 群组聊天
     */

    ConversationType[ConversationType["GROUP"] = 3] = "GROUP";
    /**
     * 聊天室会话
     */

    ConversationType[ConversationType["CHATROOM"] = 4] = "CHATROOM";
    /**
     * 客服会话
     */

    ConversationType[ConversationType["CUSTOMER_SERVICE"] = 5] = "CUSTOMER_SERVICE";
    /**
     * 系统消息
     */

    ConversationType[ConversationType["SYSTEM"] = 6] = "SYSTEM";
    /**
     * 默认关注的公众号会话类型（MC)
     */

    ConversationType[ConversationType["APP_PUBLIC_SERVICE"] = 7] = "APP_PUBLIC_SERVICE";
    /**
     * 需手动关注的公众号会话类型（MP)
     */

    ConversationType[ConversationType["PUBLIC_SERVICE"] = 8] = "PUBLIC_SERVICE";
    /**
     * RTCLib 特有的会话类型
     */

    ConversationType[ConversationType["RTC_ROOM"] = 12] = "RTC_ROOM";
  })(ConversationType || (ConversationType = {}));

  var ConversationType$1 = ConversationType;

  /**
   * 文件类型
   */
  var FileType;

  (function (FileType) {
    /**
     * 图片文件
     */
    FileType[FileType["IMAGE"] = 1] = "IMAGE";
    /**
     * 声音文件
     */

    FileType[FileType["AUDIO"] = 2] = "AUDIO";
    /**
     * 视频文件
     */

    FileType[FileType["VIDEO"] = 3] = "VIDEO";
    /**
     * 非媒体文件
     */

    FileType[FileType["FILE"] = 4] = "FILE";
    /**
     * 小视频类型
    */

    FileType[FileType["SIGHT"] = 5] = "SIGHT";
    /**
     * 合并转发
    */

    FileType[FileType["COMBINE_HTML"] = 6] = "COMBINE_HTML";
  })(FileType || (FileType = {}));

  var FileType$1 = FileType;

  /**
   * 检查参数是否为字符串
   * 只做类型检查，不做长度检查，故当字符串长度为 0，结果依然为 true
   * @param str
   */

  var isString = function isString(value) {
    return typeof value === 'string';
  };
  /**
   * 检查参数是否为 number 数据
   * @param value
   */

  var isNumber = function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  };
  /**
   * 检查参数是否为数组
   * 只做类型检查，不做长度检查
   * 如 UnitArray、BufferArray 等也属于数组
   * @param arr
   */

  var isArray$1 = function isArray(arr) {
    return Object.prototype.toString.call(arr).indexOf('Array') !== -1;
  };
  /**
   * 检查参数是否为 ArrayBuffer
   * @param arr
   */

  var isArrayBuffer = function isArrayBuffer(arr) {
    return Object.prototype.toString.call(arr) === '[object ArrayBuffer]';
  };
  /**
   * 检查参数是否为长度非 0 的字符串
   * @param str
   */

  var notEmptyString = function notEmptyString(str) {
    return isString(str) && str.length > 0;
  };
  /**
   * 检查参数是否为长度非 0 的数组
   * @param str
   */

  var notEmptyArray = function notEmptyArray(arr) {
    return isArray$1(arr) && arr.length > 0;
  };
  /**
   * 检查参数是否为对象
   * @param val
   */

  var isObject$1 = function isObject(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  };
  /**
   * 检查参数是否为函数
   * @param val
   */

  var isFunction = function isFunction(val) {
    return Object.prototype.toString.call(val) === '[object Function]';
  };
  /**
   * 检查参数是否为undefined
   * @param val
   */

  var isUndefined = function isUndefined(val) {
    // IE 下 undefined 为 Object
    return val === undefined || Object.prototype.toString.call(val) === '[object Undefined]';
  };
  /**
   * 检查参数是否为 null
  */

  var isNull = function isNull(val) {
    return Object.prototype.toString.call(val) === '[object Null]';
  };
  /**
   * 检查参数是否为有效 http(s) 协议 url
   * @param value
   */

  var isHttpUrl = function isHttpUrl(value) {
    return isString(value) && /https?:\/\//.test(value);
  };
  /**
   * 检查对象不为空
   * @param val
  */

  var notEmptyObject = function notEmptyObject(val) {
    // eslint-disable-next-line no-unreachable-loop
    for (var key in val) {
      return true;
    }

    return false;
  };
  var isValidConversationType = function isValidConversationType(conversation) {
    return isNumber(conversation) && Object.prototype.hasOwnProperty.call(ConversationType$1, conversation);
  };
  /**
   * 判断是否是一个有效的文件类型
   */

  var isValidFileType = function isValidFileType(fileType) {
    return isNumber(fileType) && Object.prototype.hasOwnProperty.call(FileType$1, fileType);
  };

  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
    return O;
  };

  var html = getBuiltIn('document', 'documentElement');

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO = sharedKey('IE_PROTO');

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      /* global ActiveXObject -- old IE */
      activeXDocument = document.domain && new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true;

  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : objectDefineProperties(result, Properties);
  };

  var UNSCOPABLES = wellKnownSymbol('unscopables');
  var ArrayPrototype = Array.prototype;

  // Array.prototype[@@unscopables]
  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  }

  // add a key to Array.prototype[@@unscopables]
  var addToUnscopables = function (key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var $includes = arrayIncludes.includes;


  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  _export({ target: 'Array', proto: true }, {
    includes: function includes(el /* , fromIndex = 0 */) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('includes');

  var MATCH = wellKnownSymbol('match');

  // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp
  var isRegexp = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
  };

  var notARegexp = function (it) {
    if (isRegexp(it)) {
      throw TypeError("The method doesn't accept regular expressions");
    } return it;
  };

  var MATCH$1 = wellKnownSymbol('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;
    try {
      '/./'[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH$1] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (error2) { /* empty */ }
    } return false;
  };

  // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes
  _export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~String(requireObjectCoercible(this))
        .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');

  var max$3 = Math.max;
  var min$3 = Math.min;
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

  // `Array.prototype.splice` method
  // https://tc39.es/ecma262/#sec-array.prototype.splice
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
    splice: function splice(start, deleteCount /* , ...items */) {
      var O = toObject(this);
      var len = toLength(O.length);
      var actualStart = toAbsoluteIndex(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;
      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min$3(max$3(toInteger(deleteCount), 0), len - actualStart);
      }
      if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
        throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }
      A = arraySpeciesCreate(O, actualDeleteCount);
      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }
      A.length = actualDeleteCount;
      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
        for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
      }
      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }
      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  var $forEach = arrayIteration.forEach;


  var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');

  // `Array.prototype.forEach` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  var arrayForEach = !STRICT_METHOD$1 ? function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  } : [].forEach;

  for (var COLLECTION_NAME in domIterables) {
    var Collection = global$1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
      createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
    } catch (error) {
      CollectionPrototype.forEach = arrayForEach;
    }
  }

  var EventEmitter = /*#__PURE__*/function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      this._map = {};
    }
    /**
     * 添加事件监听器
     * @param eventType
     * @param listener
     */


    _createClass(EventEmitter, [{
      key: "on",
      value: function on(eventType, listener) {
        var arr = this._map[eventType] || (this._map[eventType] = []);

        if (arr.includes(listener)) {
          return;
        }

        arr.push(listener);
      }
      /**
       * 移除事件监听器
       * @param eventType
       * @param listener
       */

    }, {
      key: "off",
      value: function off(eventType, listener) {
        var arr = this._map[eventType];

        if (!arr) {
          return;
        }

        var len = arr.length;

        for (var i = len - 1; i >= 0; i -= 1) {
          if (arr[i] === listener) {
            arr.splice(i, 1);

            if (len === 1) {
              delete this._map[eventType];
            }

            break;
          }
        }
      }
      /**
       * 事件派发
       * @param eventType
       * @param data
       */

    }, {
      key: "emit",
      value: function emit(eventType, data) {
        var arr = this._map[eventType];

        if (!arr) {
          return;
        }

        arr.forEach(function (item) {
          return item(data);
        });
      }
      /**
       * 清空所有指定类型的事件监听器
       * @param eventType
       */

    }, {
      key: "removeAll",
      value: function removeAll(eventType) {
        delete this._map[eventType];
      }
      /**
       * 无差别清空所有事件监听器
       */

    }, {
      key: "clear",
      value: function clear() {
        Object.keys(this._map).forEach(this.removeAll, this);
      }
    }]);

    return EventEmitter;
  }();

  var defineProperty = objectDefineProperty.f;

  var FunctionPrototype = Function.prototype;
  var FunctionPrototypeToString = FunctionPrototype.toString;
  var nameRE = /^\s*function ([^ (]*)/;
  var NAME = 'name';

  // Function instances `.name` property
  // https://tc39.es/ecma262/#sec-function-instances-name
  if (descriptors && !(NAME in FunctionPrototype)) {
    defineProperty(FunctionPrototype, NAME, {
      configurable: true,
      get: function () {
        try {
          return FunctionPrototypeToString.call(this).match(nameRE)[1];
        } catch (error) {
          return '';
        }
      }
    });
  }

  var _validators;
  /**
   * 预定义的验证规则，只包含`值类型`数据验证
   * 引用类型数据需使用自定义 validator 校验函数进行校验
   */

  exports.AssertRules = void 0;

  (function (AssertRules) {
    /**
     * 类型为字符串，且长度大于 0
     */
    AssertRules[AssertRules["STRING"] = 0] = "STRING";
    /**
     * 类型仅为 String
    */

    AssertRules[AssertRules["ONLY_STRING"] = 1] = "ONLY_STRING";
    /**
     * 类型为数字
     */

    AssertRules[AssertRules["NUMBER"] = 2] = "NUMBER";
    /**
     * 类型为布尔值
     */

    AssertRules[AssertRules["BOOLEAN"] = 3] = "BOOLEAN";
    /**
     * 类型为对象
    */

    AssertRules[AssertRules["OBJECT"] = 4] = "OBJECT";
    /**
     * 类型为数组
    */

    AssertRules[AssertRules["ARRAY"] = 5] = "ARRAY";
    /**
     * 类型为 callback 回调对象，包含 callback.onSuccess、callback.onError
    */

    AssertRules[AssertRules["CALLBACK"] = 6] = "CALLBACK";
  })(exports.AssertRules || (exports.AssertRules = {}));

  var validators = (_validators = {}, _defineProperty(_validators, exports.AssertRules.STRING, notEmptyString), _defineProperty(_validators, exports.AssertRules.ONLY_STRING, isString), _defineProperty(_validators, exports.AssertRules.NUMBER, isNumber), _defineProperty(_validators, exports.AssertRules.BOOLEAN, function (value) {
    return typeof value === 'boolean';
  }), _defineProperty(_validators, exports.AssertRules.OBJECT, isObject$1), _defineProperty(_validators, exports.AssertRules.ARRAY, isArray$1), _defineProperty(_validators, exports.AssertRules.CALLBACK, function (callback) {
    var flag = true;

    if (!isObject$1(callback)) {
      flag = false;
    }

    callback = callback || {};

    if (callback.onSuccess && !isFunction(callback.onSuccess)) {
      flag = false;
    }

    if (callback.onError && !isFunction(callback.onError)) {
      flag = false;
    }

    return flag;
  }), _validators);
  var RCAssertError = /*#__PURE__*/function (_Error) {
    _inherits(RCAssertError, _Error);

    var _super = _createSuper(RCAssertError);

    function RCAssertError(message) {
      var _this;

      _classCallCheck(this, RCAssertError);

      _this = _super.call(this, message);
      _this.name = 'RCAssertError';
      return _this;
    }

    return RCAssertError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * 参数校验，该方法用于对业务层入参数据检查，及时抛出异常通知业务层进行修改
   * @description
   * 1. 必填参数，value 需符合 validator 验证规，否则抛出异常
   * 2. 非必填参数，value 可为 undefined | null 或符合 validator 规则
   * @param key 字段名，仅用于验证失败时给出提示信息
   * @param value 待验证的值
   * @param validator 期望类型或校验规则函数，若使用规则函数
   * @param required 是否为必填参数，默认为 `false`
   */

  var assert = function assert(key, value, validator) {
    var required = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (!validate(key, value, validator, required)) {
      throw new RCAssertError("'".concat(key, "' is invalid: ").concat(JSON.stringify(value)));
    }
  };
  /**
   * 参数校验，该方法用于对业务层入参数据检查，与 `assert` 函数不同的是其返回 boolean 值而非直接抛出异常
   * @description
   * 1. 必填参数，value 需符合 validator 验证规，否则抛出异常
   * 2. 非必填参数，value 可为 undefined | null 或符合 validator 规则
   * @param key 字段名，仅用于验证失败时给出提示信息
   * @param value 待验证的值
   * @param validator 期望类型或校验规则函数，若使用规则函数
   * @param required 是否为必填参数，默认为 `false`
   */

  var validate = function validate(key, value, validator) {
    var required = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    validator = validators[validator] || validator;
    var invalid = // 必填参数校验
    required && !validator(value) || // 非必填参数校验
    !required && !(isUndefined(value) || value === null || validator(value));

    if (invalid) {
      // 打印无效参数到控制台便于定位问题
      logger.error("'".concat(key, "' is invalid: ").concat(JSON.stringify(value)));
    }

    return !invalid;
  };

  var SPECIES$4 = wellKnownSymbol('species');

  // `SpeciesConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-speciesconstructor
  var speciesConstructor = function (O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES$4]) == undefined ? defaultConstructor : aFunction$1(S);
  };

  var arrayPush = [].push;
  var min$4 = Math.min;
  var MAX_UINT32 = 0xFFFFFFFF;

  // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
  var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

  // @@split logic
  fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      'abbc'.split(/(b)*/)[1] == 'c' ||
      // eslint-disable-next-line regexp/no-empty-group -- required for testing
      'test'.split(/(?:)/, -1).length != 4 ||
      'ab'.split(/(?:ab)*/).length != 2 ||
      '.'.split(/(.?)(.?)/).length != 4 ||
      // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
      '.'.split(/()()/).length > 1 ||
      ''.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = String(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegexp(separator)) {
          return nativeSplit.call(string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while (match = regexpExec.call(separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));
        return output.length > lim ? output.slice(0, lim) : output;
      };
    // Chakra, V8
    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = separator == undefined ? undefined : separator[SPLIT];
        return splitter !== undefined
          ? splitter.call(separator, O, limit)
          : internalSplit.call(String(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (regexp, limit) {
        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);
        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (SUPPORTS_Y ? 'y' : 'g');

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.
        var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = SUPPORTS_Y ? q : 0;
          var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
          var e;
          if (
            z === null ||
            (e = min$4(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            A.push(S.slice(p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              A.push(z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        A.push(S.slice(p));
        return A;
      }
    ];
  }, !SUPPORTS_Y);

  var TO_STRING = 'toString';
  var RegExpPrototype = RegExp.prototype;
  var nativeToString = RegExpPrototype[TO_STRING];

  var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
  // FF44- RegExp#toString has a wrong name
  var INCORRECT_NAME = nativeToString.name != TO_STRING;

  // `RegExp.prototype.toString` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
  if (NOT_GENERIC || INCORRECT_NAME) {
    redefine(RegExp.prototype, TO_STRING, function toString() {
      var R = anObject(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
      return '/' + p + '/' + f;
    }, { unsafe: true });
  }

  var randomNum = function randomNum(min, max) {
    return min + Math.floor(Math.random() * (max - min));
  };
  var getUUID = function getUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  var nativePromiseConstructor = global$1.Promise;

  var redefineAll = function (target, src, options) {
    for (var key in src) redefine(target, key, src[key], options);
    return target;
  };

  var defineProperty$1 = objectDefineProperty.f;



  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

  var setToStringTag = function (it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
      defineProperty$1(it, TO_STRING_TAG$2, { configurable: true, value: TAG });
    }
  };

  var SPECIES$5 = wellKnownSymbol('species');

  var setSpecies = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = objectDefineProperty.f;

    if (descriptors && Constructor && !Constructor[SPECIES$5]) {
      defineProperty(Constructor, SPECIES$5, {
        configurable: true,
        get: function () { return this; }
      });
    }
  };

  var anInstance = function (it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    } return it;
  };

  var iterators = {};

  var ITERATOR = wellKnownSymbol('iterator');
  var ArrayPrototype$1 = Array.prototype;

  // check on default Array iterator
  var isArrayIteratorMethod = function (it) {
    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR] === it);
  };

  var ITERATOR$1 = wellKnownSymbol('iterator');

  var getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$1]
      || it['@@iterator']
      || iterators[classof(it)];
  };

  var iteratorClose = function (iterator) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) {
      return anObject(returnMethod.call(iterator)).value;
    }
  };

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      } return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && result instanceof Result) return result;
        } return new Result(false);
      }
      iterator = iterFn.call(iterable);
    }

    next = iterator.next;
    while (!(step = next.call(iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator);
        throw error;
      }
      if (typeof result == 'object' && result && result instanceof Result) return result;
    } return new Result(false);
  };

  var ITERATOR$2 = wellKnownSymbol('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return { done: !!called++ };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR$2] = function () {
      return this;
    };
    // eslint-disable-next-line no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function () { throw 2; });
  } catch (error) { /* empty */ }

  var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$2] = function () {
        return {
          next: function () {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
  };

  var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

  var engineIsNode = classofRaw(global$1.process) == 'process';

  var location = global$1.location;
  var set$1 = global$1.setImmediate;
  var clear = global$1.clearImmediate;
  var process$2 = global$1.process;
  var MessageChannel = global$1.MessageChannel;
  var Dispatch = global$1.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function (id) {
    // eslint-disable-next-line no-prototype-builtins -- safe
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var runner = function (id) {
    return function () {
      run(id);
    };
  };

  var listener = function (event) {
    run(event.data);
  };

  var post = function (id) {
    // old engines have not location.origin
    global$1.postMessage(id + '', location.protocol + '//' + location.host);
  };

  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!set$1 || !clear) {
    set$1 = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func -- spec requirement
        (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue[id];
    };
    // Node.js 0.8-
    if (engineIsNode) {
      defer = function (id) {
        process$2.nextTick(runner(id));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(runner(id));
      };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
    } else if (MessageChannel && !engineIsIos) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = functionBindContext(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (
      global$1.addEventListener &&
      typeof postMessage == 'function' &&
      !global$1.importScripts &&
      location && location.protocol !== 'file:' &&
      !fails(post)
    ) {
      defer = post;
      global$1.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
      defer = function (id) {
        html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task = {
    set: set$1,
    clear: clear
  };

  var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task.set;




  var MutationObserver = global$1.MutationObserver || global$1.WebKitMutationObserver;
  var document$2 = global$1.document;
  var process$3 = global$1.process;
  var Promise$1 = global$1.Promise;
  // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global$1, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

  var flush, head, last, notify, toggle, node, promise, then;

  // modern engines have queueMicrotask method
  if (!queueMicrotask) {
    flush = function () {
      var parent, fn;
      if (engineIsNode && (parent = process$3.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (error) {
          if (head) notify();
          else last = undefined;
          throw error;
        }
      } last = undefined;
      if (parent) parent.enter();
    };

    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
      toggle = true;
      node = document$2.createTextNode('');
      new MutationObserver(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      then = promise.then;
      notify = function () {
        then.call(promise, flush);
      };
    // Node.js without promises
    } else if (engineIsNode) {
      notify = function () {
        process$3.nextTick(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      notify = function () {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global$1, flush);
      };
    }
  }

  var microtask = queueMicrotask || function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };

  var PromiseCapability = function (C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction$1(resolve);
    this.reject = aFunction$1(reject);
  };

  // 25.4.1.5 NewPromiseCapability(C)
  var f$5 = function (C) {
    return new PromiseCapability(C);
  };

  var newPromiseCapability = {
    f: f$5
  };

  var promiseResolve = function (C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var hostReportErrors = function (a, b) {
    var console = global$1.console;
    if (console && console.error) {
      arguments.length === 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform = function (exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };

  var task$1 = task.set;











  var SPECIES$6 = wellKnownSymbol('species');
  var PROMISE = 'Promise';
  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var getInternalPromiseState = internalState.getterFor(PROMISE);
  var PromiseConstructor = nativePromiseConstructor;
  var TypeError$1 = global$1.TypeError;
  var document$3 = global$1.document;
  var process$4 = global$1.process;
  var $fetch = getBuiltIn('fetch');
  var newPromiseCapability$1 = newPromiseCapability.f;
  var newGenericPromiseCapability = newPromiseCapability$1;
  var DISPATCH_EVENT = !!(document$3 && document$3.createEvent && global$1.dispatchEvent);
  var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

  var FORCED$1 = isForced_1(PROMISE, function () {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE) {
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (engineV8Version === 66) return true;
      // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      if (!engineIsNode && !NATIVE_REJECTION_EVENT) return true;
    }
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = PromiseConstructor.resolve(1);
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES$6] = FakePromise;
    return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
  });

  var INCORRECT_ITERATION = FORCED$1 || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
  });

  // helpers
  var isThenable = function (it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify$1 = function (state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function () {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0;
      // variable length - can't use forEach
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(state);
              state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value); // can throw
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(state);
    });
  };

  var dispatchEvent = function (name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document$3.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$1.dispatchEvent(event);
    } else event = { promise: promise, reason: reason };
    if (!NATIVE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function (state) {
    task$1.call(global$1, function () {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function () {
          if (engineIsNode) {
            process$4.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function (state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function (state) {
    task$1.call(global$1, function () {
      var promise = state.facade;
      if (engineIsNode) {
        process$4.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function (fn, state, unwrap) {
    return function (value) {
      fn(state, value, unwrap);
    };
  };

  var internalReject = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify$1(state, true);
  };

  var internalResolve = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function () {
          var wrapper = { done: false };
          try {
            then.call(value,
              bind(internalResolve, wrapper, state),
              bind(internalReject, wrapper, state)
            );
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify$1(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };

  // constructor polyfill
  if (FORCED$1) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromiseConstructor, PROMISE);
      aFunction$1(executor);
      Internal.call(this);
      var state = getInternalState(this);
      try {
        executor(bind(internalResolve, state), bind(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise(executor) {
      setInternalState(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };
    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.es/ecma262/#sec-promise.prototype.then
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = engineIsNode ? process$4.domain : undefined;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify$1(state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.es/ecma262/#sec-promise.prototype.catch
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      var state = getInternalState(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, state);
      this.reject = bind(internalReject, state);
    };
    newPromiseCapability.f = newPromiseCapability$1 = function (C) {
      return C === PromiseConstructor || C === PromiseWrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };

    if (typeof nativePromiseConstructor == 'function') {
      nativeThen = nativePromiseConstructor.prototype.then;

      // wrap native Promise#then for native async functions
      redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          nativeThen.call(that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });

      // wrap fetch result
      if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        fetch: function fetch(input /* , init */) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global$1, arguments));
        }
      });
    }
  }

  _export({ global: true, wrap: true, forced: FORCED$1 }, {
    Promise: PromiseConstructor
  });

  setToStringTag(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);

  PromiseWrapper = getBuiltIn(PROMISE);

  // statics
  _export({ target: PROMISE, stat: true, forced: FORCED$1 }, {
    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability$1(this);
      capability.reject.call(undefined, r);
      return capability.promise;
    }
  });

  _export({ target: PROMISE, stat: true, forced: FORCED$1 }, {
    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve(this, x);
    }
  });

  _export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          $promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        iterate(iterable, function (promise) {
          $promiseResolve.call(C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var slice = [].slice;
  var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

  var wrap = function (scheduler) {
    return function (handler, timeout /* , ...arguments */) {
      var boundArgs = arguments.length > 2;
      var args = boundArgs ? slice.call(arguments, 2) : undefined;
      return scheduler(boundArgs ? function () {
        // eslint-disable-next-line no-new-func -- spec requirement
        (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
      } : handler, timeout);
    };
  };

  // ie9- setTimeout & setInterval additional parameters fix
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
  _export({ global: true, bind: true, forced: MSIE }, {
    // `setTimeout` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
    setTimeout: wrap(global$1.setTimeout),
    // `setInterval` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
    setInterval: wrap(global$1.setInterval)
  });

  var aPossiblePrototype = function (it) {
    if (!isObject(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + ' as a prototype');
    } return it;
  };

  /* eslint-disable no-proto -- safe */

  // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
      setter.call(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
      anObject(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  // makes subclassing work correct for wrapped built-ins
  var inheritIfRequired = function ($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (
      // it can work only with native `setPrototypeOf`
      objectSetPrototypeOf &&
      // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      typeof (NewTarget = dummy.constructor) == 'function' &&
      NewTarget !== Wrapper &&
      isObject(NewTargetPrototype = NewTarget.prototype) &&
      NewTargetPrototype !== Wrapper.prototype
    ) objectSetPrototypeOf($this, NewTargetPrototype);
    return $this;
  };

  var defineProperty$2 = objectDefineProperty.f;
  var getOwnPropertyNames = objectGetOwnPropertyNames.f;





  var setInternalState$1 = internalState.set;



  var MATCH$2 = wellKnownSymbol('match');
  var NativeRegExp = global$1.RegExp;
  var RegExpPrototype$1 = NativeRegExp.prototype;
  var re1 = /a/g;
  var re2 = /a/g;

  // "new" should create a new object, old webkit bug
  var CORRECT_NEW = new NativeRegExp(re1) !== re1;

  var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;

  var FORCED$2 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
    re2[MATCH$2] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
  })));

  // `RegExp` constructor
  // https://tc39.es/ecma262/#sec-regexp-constructor
  if (FORCED$2) {
    var RegExpWrapper = function RegExp(pattern, flags) {
      var thisIsRegExp = this instanceof RegExpWrapper;
      var patternIsRegExp = isRegexp(pattern);
      var flagsAreUndefined = flags === undefined;
      var sticky;

      if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
        return pattern;
      }

      if (CORRECT_NEW) {
        if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
      } else if (pattern instanceof RegExpWrapper) {
        if (flagsAreUndefined) flags = regexpFlags.call(pattern);
        pattern = pattern.source;
      }

      if (UNSUPPORTED_Y$2) {
        sticky = !!flags && flags.indexOf('y') > -1;
        if (sticky) flags = flags.replace(/y/g, '');
      }

      var result = inheritIfRequired(
        CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
        thisIsRegExp ? this : RegExpPrototype$1,
        RegExpWrapper
      );

      if (UNSUPPORTED_Y$2 && sticky) setInternalState$1(result, { sticky: sticky });

      return result;
    };
    var proxy = function (key) {
      key in RegExpWrapper || defineProperty$2(RegExpWrapper, key, {
        configurable: true,
        get: function () { return NativeRegExp[key]; },
        set: function (it) { NativeRegExp[key] = it; }
      });
    };
    var keys$1 = getOwnPropertyNames(NativeRegExp);
    var index = 0;
    while (keys$1.length > index) proxy(keys$1[index++]);
    RegExpPrototype$1.constructor = RegExpWrapper;
    RegExpWrapper.prototype = RegExpPrototype$1;
    redefine(global$1, 'RegExp', RegExpWrapper);
  }

  // https://tc39.es/ecma262/#sec-get-regexp-@@species
  setSpecies('RegExp');

  var ErrorCode;

  (function (ErrorCode) {
    /** 超时 */
    ErrorCode[ErrorCode["TIMEOUT"] = -1] = "TIMEOUT";
    /**
     * 未知原因失败。
     */

    ErrorCode[ErrorCode["UNKNOWN"] = -2] = "UNKNOWN";
    /** 参数错误 */

    ErrorCode[ErrorCode["PARAMETER_ERROR"] = -3] = "PARAMETER_ERROR";
    /** 未实现的方法定义，在应用层调用 callExtra 传入无法识别的方法名时抛出 */

    ErrorCode[ErrorCode["EXTRA_METHOD_UNDEFINED"] = -4] = "EXTRA_METHOD_UNDEFINED";
    /** 主进程内方法错误 */

    ErrorCode[ErrorCode["MAIN_PROCESS_ERROR"] = -5] = "MAIN_PROCESS_ERROR";
    /**
     * 成功
     */

    ErrorCode[ErrorCode["SUCCESS"] = 0] = "SUCCESS";
    ErrorCode[ErrorCode["RC_MSG_UNAUTHORIZED"] = 20406] = "RC_MSG_UNAUTHORIZED";
    /**
     * 群组 Id 无效
     */

    ErrorCode[ErrorCode["RC_DISCUSSION_GROUP_ID_INVALID"] = 20407] = "RC_DISCUSSION_GROUP_ID_INVALID";
    /**
     * 发送频率过快
     */

    ErrorCode[ErrorCode["SEND_FREQUENCY_TOO_FAST"] = 20604] = "SEND_FREQUENCY_TOO_FAST";
    /**
     * 不在讨论组。
     */

    ErrorCode[ErrorCode["NOT_IN_DISCUSSION"] = 21406] = "NOT_IN_DISCUSSION";
    /**
     * 群组被禁言
     */

    ErrorCode[ErrorCode["FORBIDDEN_IN_GROUP"] = 22408] = "FORBIDDEN_IN_GROUP";
    ErrorCode[ErrorCode["RECALL_MESSAGE"] = 25101] = "RECALL_MESSAGE";
    /**
     * 不在群组。
     */

    ErrorCode[ErrorCode["NOT_IN_GROUP"] = 22406] = "NOT_IN_GROUP";
    /**
     * 不在聊天室。
     */

    ErrorCode[ErrorCode["NOT_IN_CHATROOM"] = 23406] = "NOT_IN_CHATROOM";
    /**
     *聊天室被禁言
     */

    ErrorCode[ErrorCode["FORBIDDEN_IN_CHATROOM"] = 23408] = "FORBIDDEN_IN_CHATROOM";
    /**
     * 聊天室中成员被踢出
     */

    ErrorCode[ErrorCode["RC_CHATROOM_USER_KICKED"] = 23409] = "RC_CHATROOM_USER_KICKED";
    /**
     * 聊天室不存在
     */

    ErrorCode[ErrorCode["RC_CHATROOM_NOT_EXIST"] = 23410] = "RC_CHATROOM_NOT_EXIST";
    /**
     * 聊天室成员已满
     */

    ErrorCode[ErrorCode["RC_CHATROOM_IS_FULL"] = 23411] = "RC_CHATROOM_IS_FULL";
    /**
     * 获取聊天室信息参数无效
     */

    ErrorCode[ErrorCode["RC_CHATROOM_PATAMETER_INVALID"] = 23412] = "RC_CHATROOM_PATAMETER_INVALID";
    /**
     * 聊天室异常
     */

    ErrorCode[ErrorCode["CHATROOM_GET_HISTORYMSG_ERROR"] = 23413] = "CHATROOM_GET_HISTORYMSG_ERROR";
    /**
     * 没有打开聊天室消息存储
     */

    ErrorCode[ErrorCode["CHATROOM_NOT_OPEN_HISTORYMSG_STORE"] = 23414] = "CHATROOM_NOT_OPEN_HISTORYMSG_STORE";
    /**
     * 聊天室 KV 设置超出最大值(已满, 默认最多设置 100 个)
     */

    ErrorCode[ErrorCode["CHATROOM_KV_EXCEED"] = 23423] = "CHATROOM_KV_EXCEED";
    /**
     * 聊天室 KV 设置失败(kv 已存在, 需覆盖设置)
     */

    ErrorCode[ErrorCode["CHATROOM_KV_OVERWRITE_INVALID"] = 23424] = "CHATROOM_KV_OVERWRITE_INVALID";
    /**
     * 聊天室 KV 存储功能没有开通
     */

    ErrorCode[ErrorCode["CHATROOM_KV_STORE_NOT_OPEN"] = 23426] = "CHATROOM_KV_STORE_NOT_OPEN";
    /**
     * 聊天室Key不存在
     */

    ErrorCode[ErrorCode["CHATROOM_KEY_NOT_EXIST"] = 23427] = "CHATROOM_KEY_NOT_EXIST";
    /**
     * 敏感词屏蔽
     */

    ErrorCode[ErrorCode["SENSITIVE_SHIELD"] = 21501] = "SENSITIVE_SHIELD";
    ErrorCode[ErrorCode["SENSITIVE_REPLACE"] = 21502] = "SENSITIVE_REPLACE";
    /**
     * 加入讨论失败
     */

    ErrorCode[ErrorCode["JOIN_IN_DISCUSSION"] = 21407] = "JOIN_IN_DISCUSSION";
    /**
     * 创建讨论组失败
     */

    ErrorCode[ErrorCode["CREATE_DISCUSSION"] = 21408] = "CREATE_DISCUSSION";
    /**
     * 设置讨论组邀请状态失败
     */

    ErrorCode[ErrorCode["INVITE_DICUSSION"] = 21409] = "INVITE_DICUSSION";
    /**
     *获取用户失败
     */

    ErrorCode[ErrorCode["GET_USERINFO_ERROR"] = 23407] = "GET_USERINFO_ERROR";
    /**
     * 在黑名单中。
     */

    ErrorCode[ErrorCode["REJECTED_BY_BLACKLIST"] = 405] = "REJECTED_BY_BLACKLIST";
    /**
     * 通信过程中，当前 Socket 不存在。
     */

    ErrorCode[ErrorCode["RC_NET_CHANNEL_INVALID"] = 30001] = "RC_NET_CHANNEL_INVALID";
    /**
     * Socket 连接不可用。
     */

    ErrorCode[ErrorCode["RC_NET_UNAVAILABLE"] = 30002] = "RC_NET_UNAVAILABLE";
    /**
     * 通信超时。
     */

    ErrorCode[ErrorCode["RC_MSG_RESP_TIMEOUT"] = 30003] = "RC_MSG_RESP_TIMEOUT";
    /**
     * 导航操作时，Http 请求失败。
     */

    ErrorCode[ErrorCode["RC_HTTP_SEND_FAIL"] = 30004] = "RC_HTTP_SEND_FAIL";
    /**
     * HTTP 请求失败。
     */

    ErrorCode[ErrorCode["RC_HTTP_REQ_TIMEOUT"] = 30005] = "RC_HTTP_REQ_TIMEOUT";
    /**
     * HTTP 接收失败。
     */

    ErrorCode[ErrorCode["RC_HTTP_RECV_FAIL"] = 30006] = "RC_HTTP_RECV_FAIL";
    /**
     * 导航操作的 HTTP 请求，返回不是200。
     */

    ErrorCode[ErrorCode["RC_NAVI_RESOURCE_ERROR"] = 30007] = "RC_NAVI_RESOURCE_ERROR";
    /**
     * 导航数据解析后，其中不存在有效数据。
     */

    ErrorCode[ErrorCode["RC_NODE_NOT_FOUND"] = 30008] = "RC_NODE_NOT_FOUND";
    /**
     * 导航数据解析后，其中不存在有效 IP 地址。
     */

    ErrorCode[ErrorCode["RC_DOMAIN_NOT_RESOLVE"] = 30009] = "RC_DOMAIN_NOT_RESOLVE";
    /**
     * 创建 Socket 失败。
     */

    ErrorCode[ErrorCode["RC_SOCKET_NOT_CREATED"] = 30010] = "RC_SOCKET_NOT_CREATED";
    /**
     * Socket 被断开。
     */

    ErrorCode[ErrorCode["RC_SOCKET_DISCONNECTED"] = 30011] = "RC_SOCKET_DISCONNECTED";
    /**
     * PING 操作失败。
     */

    ErrorCode[ErrorCode["RC_PING_SEND_FAIL"] = 30012] = "RC_PING_SEND_FAIL";
    /**
     * PING 超时。
     */

    ErrorCode[ErrorCode["RC_PONG_RECV_FAIL"] = 30013] = "RC_PONG_RECV_FAIL";
    /**
     * 消息发送失败。
     */

    ErrorCode[ErrorCode["RC_MSG_SEND_FAIL"] = 30014] = "RC_MSG_SEND_FAIL";
    /**
     * JSON 后的消息体超限, 目前最大 128kb
     */

    ErrorCode[ErrorCode["RC_MSG_CONTENT_EXCEED_LIMIT"] = 30016] = "RC_MSG_CONTENT_EXCEED_LIMIT";
    /**
     * 做 connect 连接时，收到的 ACK 超时。
     */

    ErrorCode[ErrorCode["RC_CONN_ACK_TIMEOUT"] = 31000] = "RC_CONN_ACK_TIMEOUT";
    /**
     * 参数错误。
     */

    ErrorCode[ErrorCode["RC_CONN_PROTO_VERSION_ERROR"] = 31001] = "RC_CONN_PROTO_VERSION_ERROR";
    /**
     * 参数错误，App Id 错误。
     */

    ErrorCode[ErrorCode["RC_CONN_ID_REJECT"] = 31002] = "RC_CONN_ID_REJECT";
    /**
     * 服务器不可用。
     */

    ErrorCode[ErrorCode["RC_CONN_SERVER_UNAVAILABLE"] = 31003] = "RC_CONN_SERVER_UNAVAILABLE";
    /**
     * Token 错误。
     */

    ErrorCode[ErrorCode["RC_CONN_USER_OR_PASSWD_ERROR"] = 31004] = "RC_CONN_USER_OR_PASSWD_ERROR";
    /**
     * websocket 鉴权失败，通常为连接后未及时发送 Ping 或接收到 Pong
     */

    ErrorCode[ErrorCode["RC_CONN_NOT_AUTHRORIZED"] = 31005] = "RC_CONN_NOT_AUTHRORIZED";
    /**
     * 重定向，地址错误。
     */

    ErrorCode[ErrorCode["RC_CONN_REDIRECTED"] = 31006] = "RC_CONN_REDIRECTED";
    /**
     * NAME 与后台注册信息不一致。
     */

    ErrorCode[ErrorCode["RC_CONN_PACKAGE_NAME_INVALID"] = 31007] = "RC_CONN_PACKAGE_NAME_INVALID";
    /**
     * APP 被屏蔽、删除或不存在。
     */

    ErrorCode[ErrorCode["RC_CONN_APP_BLOCKED_OR_DELETED"] = 31008] = "RC_CONN_APP_BLOCKED_OR_DELETED";
    /**
     * 用户被屏蔽。
     */

    ErrorCode[ErrorCode["RC_CONN_USER_BLOCKED"] = 31009] = "RC_CONN_USER_BLOCKED";
    /**
     * Disconnect，由服务器返回，比如用户互踢。
     */

    ErrorCode[ErrorCode["RC_DISCONN_KICK"] = 31010] = "RC_DISCONN_KICK";
    /**
     * Disconnect，由服务器返回，比如用户互踢。
     */

    ErrorCode[ErrorCode["RC_DISCONN_EXCEPTION"] = 31011] = "RC_DISCONN_EXCEPTION";
    /**
     * 协议层内部错误。query，上传下载过程中数据错误。
     */

    ErrorCode[ErrorCode["RC_QUERY_ACK_NO_DATA"] = 32001] = "RC_QUERY_ACK_NO_DATA";
    /**
     * 协议层内部错误。
     */

    ErrorCode[ErrorCode["RC_MSG_DATA_INCOMPLETE"] = 32002] = "RC_MSG_DATA_INCOMPLETE";
    /**
     * 未调用 init 初始化函数。
     */

    ErrorCode[ErrorCode["BIZ_ERROR_CLIENT_NOT_INIT"] = 33001] = "BIZ_ERROR_CLIENT_NOT_INIT";
    /**
     * 数据库初始化失败。
     */

    ErrorCode[ErrorCode["BIZ_ERROR_DATABASE_ERROR"] = 33002] = "BIZ_ERROR_DATABASE_ERROR";
    /**
     * 传入参数无效。
     */

    ErrorCode[ErrorCode["BIZ_ERROR_INVALID_PARAMETER"] = 33003] = "BIZ_ERROR_INVALID_PARAMETER";
    /**
     * 通道无效。
     */

    ErrorCode[ErrorCode["BIZ_ERROR_NO_CHANNEL"] = 33004] = "BIZ_ERROR_NO_CHANNEL";
    /**
     * 重新连接成功。
     */

    ErrorCode[ErrorCode["BIZ_ERROR_RECONNECT_SUCCESS"] = 33005] = "BIZ_ERROR_RECONNECT_SUCCESS";
    /**
     * 连接中，再调用 connect 被拒绝。
     */

    ErrorCode[ErrorCode["BIZ_ERROR_CONNECTING"] = 33006] = "BIZ_ERROR_CONNECTING";
    /**
     * 消息漫游服务未开通
     */

    ErrorCode[ErrorCode["MSG_ROAMING_SERVICE_UNAVAILABLE"] = 33007] = "MSG_ROAMING_SERVICE_UNAVAILABLE";
    ErrorCode[ErrorCode["MSG_INSERT_ERROR"] = 33008] = "MSG_INSERT_ERROR";
    ErrorCode[ErrorCode["MSG_DEL_ERROR"] = 33009] = "MSG_DEL_ERROR";
    /**
     * 标签不存在
     */

    ErrorCode[ErrorCode["TAG_NOT_EXIST"] = 33101] = "TAG_NOT_EXIST";
    /**
     * 会话中不存在此标签
     */

    ErrorCode[ErrorCode["NO_TAG_IN_CONVER"] = 33102] = "NO_TAG_IN_CONVER";
    /**
     * 删除会话失败
     */

    ErrorCode[ErrorCode["CONVER_REMOVE_ERROR"] = 34001] = "CONVER_REMOVE_ERROR";
    /**
     *拉取历史消息
     */

    ErrorCode[ErrorCode["CONVER_GETLIST_ERROR"] = 34002] = "CONVER_GETLIST_ERROR";
    /**
     * 会话指定异常
     */

    ErrorCode[ErrorCode["CONVER_SETOP_ERROR"] = 34003] = "CONVER_SETOP_ERROR";
    /**
     * 获取会话未读消息总数失败
     */

    ErrorCode[ErrorCode["CONVER_TOTAL_UNREAD_ERROR"] = 34004] = "CONVER_TOTAL_UNREAD_ERROR";
    /**
     * 获取指定会话类型未读消息数异常
     */

    ErrorCode[ErrorCode["CONVER_TYPE_UNREAD_ERROR"] = 34005] = "CONVER_TYPE_UNREAD_ERROR";
    /**
     * 获取指定用户ID&会话类型未读消息数异常
     */

    ErrorCode[ErrorCode["CONVER_ID_TYPE_UNREAD_ERROR"] = 34006] = "CONVER_ID_TYPE_UNREAD_ERROR";
    ErrorCode[ErrorCode["CONVER_CLEAR_ERROR"] = 34007] = "CONVER_CLEAR_ERROR";
    /**
     * 扩展存储 key value 超出限制 (错误码与移动端对齐)
    */

    ErrorCode[ErrorCode["EXPANSION_LIMIT_EXCEET"] = 34010] = "EXPANSION_LIMIT_EXCEET";
    /**
     * 消息不支持扩展 (错误码与移动端对齐)
    */

    ErrorCode[ErrorCode["MESSAGE_KV_NOT_SUPPORT"] = 34008] = "MESSAGE_KV_NOT_SUPPORT";
    ErrorCode[ErrorCode["CLEAR_HIS_TIME_ERROR"] = 34011] = "CLEAR_HIS_TIME_ERROR";
    /**
     * 会话数量超出上限
     */

    ErrorCode[ErrorCode["CONVER_OUT_LIMIT_ERROR"] = 34013] = "CONVER_OUT_LIMIT_ERROR";
    ErrorCode[ErrorCode["CONVER_GET_ERROR"] = 34009] = "CONVER_GET_ERROR";
    /**
     * 群组信息异常
     */

    ErrorCode[ErrorCode["GROUP_SYNC_ERROR"] = 35001] = "GROUP_SYNC_ERROR";
    /**
     * 匹配群信息异常
     */

    ErrorCode[ErrorCode["GROUP_MATCH_ERROR"] = 35002] = "GROUP_MATCH_ERROR"; // 聊天室异常

    /**
     * 加入聊天室Id为空
     */

    ErrorCode[ErrorCode["CHATROOM_ID_ISNULL"] = 36001] = "CHATROOM_ID_ISNULL";
    /**
     * 加入聊天室失败
     */

    ErrorCode[ErrorCode["CHARTOOM_JOIN_ERROR"] = 36002] = "CHARTOOM_JOIN_ERROR";
    /**
     * 拉取聊天室历史消息失败
     */

    ErrorCode[ErrorCode["CHATROOM_HISMESSAGE_ERROR"] = 36003] = "CHATROOM_HISMESSAGE_ERROR";
    /**
     * 聊天室 kv 未找到
     */

    ErrorCode[ErrorCode["CHATROOM_KV_NOT_FOUND"] = 36004] = "CHATROOM_KV_NOT_FOUND"; // 黑名单异常

    /**
     * 加入黑名单异常
     */

    ErrorCode[ErrorCode["BLACK_ADD_ERROR"] = 37001] = "BLACK_ADD_ERROR";
    /**
     * 获得指定人员再黑名单中的状态异常
     */

    ErrorCode[ErrorCode["BLACK_GETSTATUS_ERROR"] = 37002] = "BLACK_GETSTATUS_ERROR";
    /**
     * 移除黑名单异常
     */

    ErrorCode[ErrorCode["BLACK_REMOVE_ERROR"] = 37003] = "BLACK_REMOVE_ERROR";
    /**
     * 获取草稿失败
     */

    ErrorCode[ErrorCode["DRAF_GET_ERROR"] = 38001] = "DRAF_GET_ERROR";
    /**
     * 保存草稿失败
     */

    ErrorCode[ErrorCode["DRAF_SAVE_ERROR"] = 38002] = "DRAF_SAVE_ERROR";
    /**
     * 删除草稿失败
     */

    ErrorCode[ErrorCode["DRAF_REMOVE_ERROR"] = 38003] = "DRAF_REMOVE_ERROR";
    /**
     * 关注公众号失败
     */

    ErrorCode[ErrorCode["SUBSCRIBE_ERROR"] = 39001] = "SUBSCRIBE_ERROR";
    /**
     * 方法未支持
     */

    ErrorCode[ErrorCode["NOT_SUPPORT"] = 39002] = "NOT_SUPPORT";
    /**
     * 关注公众号失败
     */

    ErrorCode[ErrorCode["QNTKN_FILETYPE_ERROR"] = 41001] = "QNTKN_FILETYPE_ERROR";
    /**
     * 获取七牛token失败
     */

    ErrorCode[ErrorCode["QNTKN_GET_ERROR"] = 41002] = "QNTKN_GET_ERROR";
    /**
     * cookie被禁用
     */

    ErrorCode[ErrorCode["COOKIE_ENABLE"] = 51001] = "COOKIE_ENABLE";
    ErrorCode[ErrorCode["GET_MESSAGE_BY_ID_ERROR"] = 61001] = "GET_MESSAGE_BY_ID_ERROR"; // 没有注册DeviveId 也就是用户没有登陆

    ErrorCode[ErrorCode["HAVNODEVICEID"] = 24001] = "HAVNODEVICEID"; // 已经存在

    ErrorCode[ErrorCode["DEVICEIDISHAVE"] = 24002] = "DEVICEIDISHAVE"; // 没有对应的用户或token

    ErrorCode[ErrorCode["FEILD"] = 24009] = "FEILD"; // voip为空

    ErrorCode[ErrorCode["VOIPISNULL"] = 24013] = "VOIPISNULL"; // 不支持的Voip引擎

    ErrorCode[ErrorCode["NOENGINETYPE"] = 24010] = "NOENGINETYPE"; // channleName 是空

    ErrorCode[ErrorCode["NULLCHANNELNAME"] = 24011] = "NULLCHANNELNAME"; // 生成Voipkey失败

    ErrorCode[ErrorCode["VOIPDYANMICERROR"] = 24012] = "VOIPDYANMICERROR"; // 没有配置voip

    ErrorCode[ErrorCode["NOVOIP"] = 24014] = "NOVOIP"; // 服务器内部错误

    ErrorCode[ErrorCode["INTERNALERRROR"] = 24015] = "INTERNALERRROR"; // VOIP close

    ErrorCode[ErrorCode["VOIPCLOSE"] = 24016] = "VOIPCLOSE";
    ErrorCode[ErrorCode["CLOSE_BEFORE_OPEN"] = 51001] = "CLOSE_BEFORE_OPEN";
    ErrorCode[ErrorCode["ALREADY_IN_USE"] = 51002] = "ALREADY_IN_USE";
    ErrorCode[ErrorCode["INVALID_CHANNEL_NAME"] = 51003] = "INVALID_CHANNEL_NAME";
    ErrorCode[ErrorCode["VIDEO_CONTAINER_IS_NULL"] = 51004] = "VIDEO_CONTAINER_IS_NULL";
    /**
     * 删除消息数组长度为 0 .
     */

    ErrorCode[ErrorCode["DELETE_MESSAGE_ID_IS_NULL"] = 61001] = "DELETE_MESSAGE_ID_IS_NULL";
    /**
     * 己方取消已发出的通话请求
     */

    ErrorCode[ErrorCode["CANCEL"] = 1] = "CANCEL";
    /**
     * 己方拒绝收到的通话请求
     */

    ErrorCode[ErrorCode["REJECT"] = 2] = "REJECT";
    /**
     * 己方挂断
     */

    ErrorCode[ErrorCode["HANGUP"] = 3] = "HANGUP";
    /**
     * 己方忙碌
     */

    ErrorCode[ErrorCode["BUSYLINE"] = 4] = "BUSYLINE";
    /**
     * 己方未接听
     */

    ErrorCode[ErrorCode["NO_RESPONSE"] = 5] = "NO_RESPONSE";
    /**
     * 己方不支持当前引擎
     */

    ErrorCode[ErrorCode["ENGINE_UN_SUPPORTED"] = 6] = "ENGINE_UN_SUPPORTED";
    /**
     * 己方网络出错
     */

    ErrorCode[ErrorCode["NETWORK_ERROR"] = 7] = "NETWORK_ERROR";
    /**
     * 对方取消已发出的通话请求
     */

    ErrorCode[ErrorCode["REMOTE_CANCEL"] = 11] = "REMOTE_CANCEL";
    /**
     * 对方拒绝收到的通话请求
     */

    ErrorCode[ErrorCode["REMOTE_REJECT"] = 12] = "REMOTE_REJECT";
    /**
     * 通话过程对方挂断
     */

    ErrorCode[ErrorCode["REMOTE_HANGUP"] = 13] = "REMOTE_HANGUP";
    /**
     * 对方忙碌
     */

    ErrorCode[ErrorCode["REMOTE_BUSYLINE"] = 14] = "REMOTE_BUSYLINE";
    /**
     * 对方未接听
     */

    ErrorCode[ErrorCode["REMOTE_NO_RESPONSE"] = 15] = "REMOTE_NO_RESPONSE";
    /**
     * 对方网络错误
     */

    ErrorCode[ErrorCode["REMOTE_ENGINE_UN_SUPPORTED"] = 16] = "REMOTE_ENGINE_UN_SUPPORTED";
    /**
     * 对方网络错误
     */

    ErrorCode[ErrorCode["REMOTE_NETWORK_ERROR"] = 17] = "REMOTE_NETWORK_ERROR";
    /**
     * VoIP 不可用
     */

    ErrorCode[ErrorCode["VOIP_NOT_AVALIABLE"] = 18] = "VOIP_NOT_AVALIABLE";
  })(ErrorCode || (ErrorCode = {}));

  var ErrorCode$1 = ErrorCode;

  var timerSetTimeout = function timerSetTimeout(fun, itv) {
    return setTimeout(fun, itv);
  };
  var int64ToTimestamp = function int64ToTimestamp(obj) {
    if (!isObject$1(obj) || obj.low === undefined || obj.high === undefined) {
      return obj;
    }

    var low = obj.low;

    if (low < 0) {
      low += 0xffffffff + 1;
    }

    low = low.toString(16);
    var timestamp = parseInt(obj.high.toString(16) + '00000000'.replace(new RegExp('0{' + low.length + '}$'), low), 16);
    return timestamp;
  };
  var batchInt64ToTimestamp = function batchInt64ToTimestamp(data) {
    for (var key in data) {
      if (isObject$1(data[key])) {
        data[key] = int64ToTimestamp(data[key]);
      }
    }

    return data;
  };
  var formatDate = function formatDate(seperator) {
    seperator = seperator || '-';
    var date = new Date();
    var year = date.getFullYear();
    var month = date.getMonth() + 1;
    var day = date.getDate();
    return "".concat(year).concat(seperator).concat(month).concat(seperator).concat(day);
  };

  /**
   * 通过文件类型生成上传唯一文件名
  */

  var getUploadFileName = function getUploadFileName(type, fileName) {
    var random = Math.floor(Math.random() * 1000 % 10000);
    var uuid = getUUID();
    var date = formatDate();
    var timestamp = new Date().getTime();
    var extension = '';

    if (fileName) {
      var fileNameArr = fileName.split('.');
      extension = '.' + fileNameArr[fileNameArr.length - 1];
    }

    return "".concat(type, "__RC-").concat(date, "_").concat(random, "_").concat(timestamp).concat(uuid).concat(extension);
  };
  /**
   * 通过 fileType 获取 MIME
  */

  var getMimeKey = function getMimeKey(fileType) {
    var mimeKey = 'application/octet-stream';

    switch (fileType) {
      case FileType$1.IMAGE:
        mimeKey = 'image/jpeg';
        break;

      case FileType$1.AUDIO:
        mimeKey = 'audio/amr';
        break;

      case FileType$1.VIDEO:
        mimeKey = 'video/3gpp';
        break;

      case FileType$1.SIGHT:
        mimeKey = 'video/mpeg4';
        break;

      case FileType$1.COMBINE_HTML:
        mimeKey = 'text/html';
        break;
    }

    return mimeKey;
  };
  /**
   * 生成 pushConfigs JSON
   * @description
   * 与 Server 约定一致， threadId、apnsCollapseId、channelIdMi、channelIdHW、channelIdOPPO、typeVivo 无值时可传空字符串
  */

  var pushConfigsToJSON = function pushConfigsToJSON() {
    var iOSConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var androidConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var threadId = iOSConfig.threadId,
        apnsCollapseId = iOSConfig.apnsCollapseId;
    var channelIdMi = androidConfig.channelIdMi,
        channelIdHW = androidConfig.channelIdHW,
        channelIdOPPO = androidConfig.channelIdOPPO,
        typeVivo = androidConfig.typeVivo;
    var APNS = {};
    APNS['thread-id'] = threadId || '';
    APNS['apns-collapse-id'] = apnsCollapseId || '';
    var pushCongfigs = [{
      HW: {
        channelId: channelIdHW || ''
      }
    }, {
      MI: {
        channelId: channelIdMi || ''
      }
    }, {
      OPPO: {
        channelId: channelIdOPPO || ''
      }
    }, {
      VIVO: {
        classification: typeVivo || ''
      }
    }, {
      APNS: APNS
    }];
    return JSON.stringify(pushCongfigs);
  };
  var isValidChrmEntryKey = function isValidChrmEntryKey(key) {
    var isValid = /^[A-Za-z0-9_=+-]+$/.test(key); // 大小写英文字母、数字、+、=、-、_

    var keyLen = key.length;
    var isLimit = keyLen <= 128 && keyLen >= 1;
    return isValid && isLimit;
  };
  var isValidChrmEntryValue = function isValidChrmEntryValue(value) {
    var length = value.length;
    return length <= 4096 && length >= 1;
  };

  /**
   * @todo 后期禁用此方法，容易滥用，且会丢失上下文的数据类型跟踪
   * @deprecated
   * @param source
   * @param event
   * @param options
   */

  var forEach = function forEach(source, event, options) {
    options = options || {};

    event = event || function () {};

    var _options = options,
        isReverse = _options.isReverse;

    var loopObj = function loopObj() {
      for (var key in source) {
        event(source[key], key, source);
      }
    };

    var loopArr = function loopArr() {
      if (isReverse) {
        for (var i = source.length - 1; i >= 0; i--) {
          event(source[i], i);
        }
      } else {
        for (var j = 0, len = source.length; j < len; j++) {
          event(source[j], j);
        }
      }
    };

    if (isObject$1(source)) {
      loopObj();
    }

    if (isArray$1(source) || isString(source)) {
      loopArr();
    }
  };
  /**
   * @deprecated
   * @param source
   * @param event
   */

  var map = function map(source, event) {
    forEach(source, function (item, index) {
      source[index] = event(item, index);
    });
    return source;
  };
  var indexOf$1 = function indexOf(source, searchVal) {
    // 注: 字符串的 indexof 兼容至 IE3
    if (source.indexOf) {
      return source.indexOf(searchVal);
    }

    var index = -1;
    forEach(source, function (sub, i) {
      if (searchVal === sub) {
        index = i;
      }
    });
    return index;
  };
  var isInclude = function isInclude(source, searchVal) {
    var index = indexOf$1(source, searchVal);
    return index !== -1;
  };
  /**
   * 判断对象里是否有某个值
  */

  var isInObject = function isInObject(source, searchVal) {
    var arr = [];
    forEach(source, function (val) {
      arr.push(val);
    });
    var index = indexOf$1(arr, searchVal);
    return index !== -1;
  };
  /**
   * 通过 JSON 拷贝
  */

  var cloneByJSON = function cloneByJSON(sourceObj) {
    return JSON.parse(JSON.stringify(sourceObj));
  };
  /**
   * 判断当前是否运行在 electron 环境且搭配 c++ 协议栈使用
   */

  var usingCppEngine = function usingCppEngine() {
    return typeof RCCppEngine !== 'undefined';
  };

  /**
   *  聊天室 kv 存储操作类型. 对方操作, 己方收到消息(RC:chrmKVNotiMsg)中会带入此值. 根据此值判断是删除还是更新
  */
  var ChatroomEntryType;

  (function (ChatroomEntryType) {
    ChatroomEntryType[ChatroomEntryType["UPDATE"] = 1] = "UPDATE";
    ChatroomEntryType[ChatroomEntryType["DELETE"] = 2] = "DELETE";
  })(ChatroomEntryType || (ChatroomEntryType = {}));

  var ChatroomEntryType$1 = ChatroomEntryType;

  /**
   * 通过 status 计算接收到的消息的部分属性值
   * @description
   * status 转为二进制, 二进制的比特位存储消息的部分属性值
   * 属性所占比特位:
   * 0000-0010 该消息是否曾被该用户拉取过(其他端)
   * 0001-0000 isPersited
   * 0010-0000 isCounted
   * 0100-0000 isMentioned
   * 0010-0000-0000 disableNotification
   * 0100-0000-0000 canIncludeExpansion
  */

  var getMessageOptionByStatus = function getMessageOptionByStatus(status) {
    var isPersited = true;
    var isCounted = true;
    var isMentioned = false;
    var disableNotification = false;
    var receivedStatus = ReceivedStatus$1.READ;
    var isReceivedByOtherClient = false;
    var canIncludeExpansion = false;
    isPersited = !!(status & 0x10);
    isCounted = !!(status & 0x20);
    isMentioned = !!(status & 0x40);
    disableNotification = !!(status & 0x200);
    isReceivedByOtherClient = !!(status & 0x02);
    receivedStatus = isReceivedByOtherClient ? ReceivedStatus$1.RETRIEVED : receivedStatus;
    canIncludeExpansion = !!(status & 0x400);
    return {
      isPersited: isPersited,
      isCounted: isCounted,
      isMentioned: isMentioned,
      disableNotification: disableNotification,
      receivedStatus: receivedStatus,
      canIncludeExpansion: canIncludeExpansion
    };
  };
  /**
   * 通过 sessionId 计算发送消息成功后，发送消息的部分属性
   * @description
   * sessionId 转为二进制, 二进制的比特位存储消息的部分属性值
   * 属性所占比特位:
   * 0000-0001 isPersited
   * 0000-0010 isCounted
   * 0000-0100 isMentioned
   * 0010-0000 disableNotification
   * 0100-0000 canIncludeExpansion
  */

  var getUpMessageOptionBySessionId = function getUpMessageOptionBySessionId(sessionId) {
    var isPersited = false;
    var isCounted = false;
    var disableNotification = false;
    var canIncludeExpansion = false;
    isPersited = !!(sessionId & 0x01);
    isCounted = !!(sessionId & 0x02);
    disableNotification = !!(sessionId & 0x10);
    canIncludeExpansion = !!(sessionId & 0x40);
    return {
      isPersited: isPersited,
      isCounted: isCounted,
      disableNotification: disableNotification,
      canIncludeExpansion: canIncludeExpansion
    };
  };
  var formatExtraContent = function formatExtraContent(extraContent) {
    var expansion = {}; // 扩展为用户任意设置的键值对

    var parseExtraContent = JSON.parse(extraContent);
    forEach(parseExtraContent, function (value, key) {
      expansion[key] = value.v;
    });
    return expansion;
  };
  /**
   * TODO: 确定对外暴露的必要性
   * @deprecated
   */

  var DelayTimer = {
    _delayTime: 0,

    /**
     * 方法并未引用，getTimer 实际返回值始终为 Date.now()
     * @deprecated
     */
    setTime: function setTime(time) {
      var currentTime = new Date().getTime();
      DelayTimer._delayTime = currentTime - time;
    },
    getTime: function getTime() {
      var delayTime = DelayTimer._delayTime;
      var currentTime = new Date().getTime();
      return currentTime - delayTime;
    }
  };
  var getChatRoomKVByStatus = function getChatRoomKVByStatus(status) {
    var isDeleteOpt = !!(status & 0x0004);
    return {
      isAutoDelete: !!(status & 0x0001),
      isOverwrite: !!(status & 0x0002),
      type: isDeleteOpt ? ChatroomEntryType$1.DELETE : ChatroomEntryType$1.UPDATE
    };
  };
  var getChatRoomKVOptStatus = function getChatRoomKVOptStatus(entity, action) {
    var status = 0; // 是否自动清理

    if (entity.isAutoDelete) {
      status = status | 0x0001;
    } // 是否覆盖


    if (entity.isOverwrite) {
      status = status | 0x0002;
    } // 操作类型


    if (action === 2) {
      status = status | 0x0004;
    }

    return status;
  };
  var getSessionId = function getSessionId(option) {
    var isStatusMessage = option.isStatusMessage;
    var isPersited = option.isPersited,
        isCounted = option.isCounted,
        isMentioned = option.isMentioned,
        disableNotification = option.disableNotification,
        canIncludeExpansion = option.canIncludeExpansion;

    if (isStatusMessage) {
      isPersited = isCounted = false;
    }

    var sessionId = 0;

    if (isPersited) {
      sessionId = sessionId | 0x01;
    }

    if (isCounted) {
      sessionId = sessionId | 0x02;
    }

    if (isMentioned) {
      sessionId = sessionId | 0x04;
    }

    if (disableNotification) {
      sessionId = sessionId | 0x20;
    }

    if (canIncludeExpansion) {
      sessionId = sessionId | 0x40;
    }

    return sessionId;
  };

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  createCommonjsModule(function (module) {
  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    define(Gp, toStringTagSymbol, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var correctPrototypeGetter = !fails(function () {
    function F() { /* empty */ }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var IE_PROTO$1 = sharedKey('IE_PROTO');
  var ObjectPrototype = Object.prototype;

  // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof
  var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectPrototype : null;
  };

  var ITERATOR$3 = wellKnownSymbol('iterator');
  var BUGGY_SAFARI_ITERATORS = false;

  var returnThis = function () { return this; };

  // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

  if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
      PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype[ITERATOR$3].call(test) !== test;
  });

  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  if (!has(IteratorPrototype, ITERATOR$3)) {
    createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
  };

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





  var returnThis$1 = function () { return this; };

  var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
    iterators[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$4 = wellKnownSymbol('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis$2 = function () { return this; };

  var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
        case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
        case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
      } return function () { return new IteratorConstructor(this); };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$4]
      || IterablePrototype['@@iterator']
      || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;

    // fix native
    if (anyNativeIterator) {
      CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
        if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
          if (objectSetPrototypeOf) {
            objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
            createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
          }
        }
        // Set @@toStringTag to native iterators
        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    }

    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return nativeIterator.call(this); };
    }

    // define iterator
    if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
      createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
    }
    iterators[NAME] = defaultIterator;

    // export additional methods
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine(IterablePrototype, KEY, methods[KEY]);
        }
      } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
    }

    return methods;
  };

  var charAt$1 = stringMultibyte.charAt;



  var STRING_ITERATOR = 'String Iterator';
  var setInternalState$2 = internalState.set;
  var getInternalState$1 = internalState.getterFor(STRING_ITERATOR);

  // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
  defineIterator(String, 'String', function (iterated) {
    setInternalState$2(this, {
      type: STRING_ITERATOR,
      string: String(iterated),
      index: 0
    });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState$1(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return { value: undefined, done: true };
    point = charAt$1(string, index);
    state.index += point.length;
    return { value: point, done: false };
  });

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$3 = internalState.set;
  var getInternalState$2 = internalState.getterFor(ARRAY_ITERATOR);

  // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator
  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState$3(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated), // target
      index: 0,                          // next index
      kind: kind                         // kind
    });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$2(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = undefined;
      return { value: undefined, done: true };
    }
    if (kind == 'keys') return { value: index, done: false };
    if (kind == 'values') return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject
  iterators.Arguments = iterators.Array;

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  var ITERATOR$5 = wellKnownSymbol('iterator');
  var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
  var ArrayValues = es_array_iterator.values;

  for (var COLLECTION_NAME$1 in domIterables) {
    var Collection$1 = global$1[COLLECTION_NAME$1];
    var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
    if (CollectionPrototype$1) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype$1[ITERATOR$5] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$5, ArrayValues);
      } catch (error) {
        CollectionPrototype$1[ITERATOR$5] = ArrayValues;
      }
      if (!CollectionPrototype$1[TO_STRING_TAG$3]) {
        createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$3, COLLECTION_NAME$1);
      }
      if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
        }
      }
    }
  }

  var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

  var defineProperty$3 = objectDefineProperty.f;





  var Int8Array$1 = global$1.Int8Array;
  var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
  var Uint8ClampedArray = global$1.Uint8ClampedArray;
  var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
  var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
  var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
  var ObjectPrototype$1 = Object.prototype;
  var isPrototypeOf = ObjectPrototype$1.isPrototypeOf;

  var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
  var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
  // Fixing native typed arrays in Opera Presto crashes the browser, see #595
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global$1.opera) !== 'Opera';
  var TYPED_ARRAY_TAG_REQIRED = false;
  var NAME$1;

  var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };

  var BigIntArrayConstructorsList = {
    BigInt64Array: 8,
    BigUint64Array: 8
  };

  var isView = function isView(it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return klass === 'DataView'
      || has(TypedArrayConstructorsList, klass)
      || has(BigIntArrayConstructorsList, klass);
  };

  var isTypedArray = function (it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return has(TypedArrayConstructorsList, klass)
      || has(BigIntArrayConstructorsList, klass);
  };

  var aTypedArray = function (it) {
    if (isTypedArray(it)) return it;
    throw TypeError('Target is not a typed array');
  };

  var aTypedArrayConstructor = function (C) {
    if (objectSetPrototypeOf) {
      if (isPrototypeOf.call(TypedArray, C)) return C;
    } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME$1)) {
      var TypedArrayConstructor = global$1[ARRAY];
      if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
        return C;
      }
    } throw TypeError('Target is not a typed array constructor');
  };

  var exportTypedArrayMethod = function (KEY, property, forced) {
    if (!descriptors) return;
    if (forced) for (var ARRAY in TypedArrayConstructorsList) {
      var TypedArrayConstructor = global$1[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
        delete TypedArrayConstructor.prototype[KEY];
      }
    }
    if (!TypedArrayPrototype[KEY] || forced) {
      redefine(TypedArrayPrototype, KEY, forced ? property
        : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
    }
  };

  var exportTypedArrayStaticMethod = function (KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!descriptors) return;
    if (objectSetPrototypeOf) {
      if (forced) for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global$1[ARRAY];
        if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
          delete TypedArrayConstructor[KEY];
        }
      }
      if (!TypedArray[KEY] || forced) {
        // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
        try {
          return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
        } catch (error) { /* empty */ }
      } else return;
    }
    for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global$1[ARRAY];
      if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
        redefine(TypedArrayConstructor, KEY, property);
      }
    }
  };

  for (NAME$1 in TypedArrayConstructorsList) {
    if (!global$1[NAME$1]) NATIVE_ARRAY_BUFFER_VIEWS = false;
  }

  // WebKit bug - typed arrays constructors prototype is Object.prototype
  if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
    // eslint-disable-next-line no-shadow -- safe
    TypedArray = function TypedArray() {
      throw TypeError('Incorrect invocation');
    };
    if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
      if (global$1[NAME$1]) objectSetPrototypeOf(global$1[NAME$1], TypedArray);
    }
  }

  if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$1) {
    TypedArrayPrototype = TypedArray.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
      if (global$1[NAME$1]) objectSetPrototypeOf(global$1[NAME$1].prototype, TypedArrayPrototype);
    }
  }

  // WebKit bug - one more object in Uint8ClampedArray prototype chain
  if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
    objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
  }

  if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$4)) {
    TYPED_ARRAY_TAG_REQIRED = true;
    defineProperty$3(TypedArrayPrototype, TO_STRING_TAG$4, { get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    } });
    for (NAME$1 in TypedArrayConstructorsList) if (global$1[NAME$1]) {
      createNonEnumerableProperty(global$1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
    }
  }

  var arrayBufferViewCore = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
    aTypedArray: aTypedArray,
    aTypedArrayConstructor: aTypedArrayConstructor,
    exportTypedArrayMethod: exportTypedArrayMethod,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
    isView: isView,
    isTypedArray: isTypedArray,
    TypedArray: TypedArray,
    TypedArrayPrototype: TypedArrayPrototype
  };

  /* eslint-disable no-new -- required for testing */

  var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

  var ArrayBuffer$1 = global$1.ArrayBuffer;
  var Int8Array$2 = global$1.Int8Array;

  var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
    Int8Array$2(1);
  }) || !fails(function () {
    new Int8Array$2(-1);
  }) || !checkCorrectnessOfIteration(function (iterable) {
    new Int8Array$2();
    new Int8Array$2(null);
    new Int8Array$2(1.5);
    new Int8Array$2(iterable);
  }, true) || fails(function () {
    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
    return new Int8Array$2(new ArrayBuffer$1(2), 1, undefined).length !== 1;
  });

  // `ToIndex` abstract operation
  // https://tc39.es/ecma262/#sec-toindex
  var toIndex = function (it) {
    if (it === undefined) return 0;
    var number = toInteger(it);
    var length = toLength(number);
    if (number !== length) throw RangeError('Wrong length or index');
    return length;
  };

  // IEEE754 conversions based on https://github.com/feross/ieee754
  var abs = Math.abs;
  var pow = Math.pow;
  var floor$2 = Math.floor;
  var log = Math.log;
  var LN2 = Math.LN2;

  var pack = function (number, mantissaLength, bytes) {
    var buffer = new Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number);
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number || number === Infinity) {
      // eslint-disable-next-line no-self-compare -- NaN check
      mantissa = number != number ? 1 : 0;
      exponent = eMax;
    } else {
      exponent = floor$2(log(number) / LN2);
      if (number * (c = pow(2, -exponent)) < 1) {
        exponent--;
        c *= 2;
      }
      if (exponent + eBias >= 1) {
        number += rt / c;
      } else {
        number += rt * pow(2, 1 - eBias);
      }
      if (number * c >= 2) {
        exponent++;
        c /= 2;
      }
      if (exponent + eBias >= eMax) {
        mantissa = 0;
        exponent = eMax;
      } else if (exponent + eBias >= 1) {
        mantissa = (number * c - 1) * pow(2, mantissaLength);
        exponent = exponent + eBias;
      } else {
        mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
        exponent = 0;
      }
    }
    for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;
    for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
    buffer[--index] |= sign * 128;
    return buffer;
  };

  var unpack = function (buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;
    for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;
    for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
    if (exponent === 0) {
      exponent = 1 - eBias;
    } else if (exponent === eMax) {
      return mantissa ? NaN : sign ? -Infinity : Infinity;
    } else {
      mantissa = mantissa + pow(2, mantissaLength);
      exponent = exponent - eBias;
    } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
  };

  var ieee754 = {
    pack: pack,
    unpack: unpack
  };

  // `Array.prototype.fill` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.fill
  var arrayFill = function fill(value /* , start = 0, end = @length */) {
    var O = toObject(this);
    var length = toLength(O.length);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
    while (endPos > index) O[index++] = value;
    return O;
  };

  var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
  var defineProperty$4 = objectDefineProperty.f;




  var getInternalState$3 = internalState.get;
  var setInternalState$4 = internalState.set;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var DATA_VIEW = 'DataView';
  var PROTOTYPE$1 = 'prototype';
  var WRONG_LENGTH = 'Wrong length';
  var WRONG_INDEX = 'Wrong index';
  var NativeArrayBuffer = global$1[ARRAY_BUFFER];
  var $ArrayBuffer = NativeArrayBuffer;
  var $DataView = global$1[DATA_VIEW];
  var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$1];
  var ObjectPrototype$2 = Object.prototype;
  var RangeError$1 = global$1.RangeError;

  var packIEEE754 = ieee754.pack;
  var unpackIEEE754 = ieee754.unpack;

  var packInt8 = function (number) {
    return [number & 0xFF];
  };

  var packInt16 = function (number) {
    return [number & 0xFF, number >> 8 & 0xFF];
  };

  var packInt32 = function (number) {
    return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
  };

  var unpackInt32 = function (buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
  };

  var packFloat32 = function (number) {
    return packIEEE754(number, 23, 4);
  };

  var packFloat64 = function (number) {
    return packIEEE754(number, 52, 8);
  };

  var addGetter = function (Constructor, key) {
    defineProperty$4(Constructor[PROTOTYPE$1], key, { get: function () { return getInternalState$3(this)[key]; } });
  };

  var get$1 = function (view, count, index, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState$3(view);
    if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
    var bytes = getInternalState$3(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = bytes.slice(start, start + count);
    return isLittleEndian ? pack : pack.reverse();
  };

  var set$2 = function (view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState$3(view);
    if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
    var bytes = getInternalState$3(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);
    for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
  };

  if (!arrayBufferNative) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
      var byteLength = toIndex(length);
      setInternalState$4(this, {
        bytes: arrayFill.call(new Array(byteLength), 0),
        byteLength: byteLength
      });
      if (!descriptors) this.byteLength = byteLength;
    };

    $DataView = function DataView(buffer, byteOffset, byteLength) {
      anInstance(this, $DataView, DATA_VIEW);
      anInstance(buffer, $ArrayBuffer, DATA_VIEW);
      var bufferLength = getInternalState$3(buffer).byteLength;
      var offset = toInteger(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
      byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
      if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
      setInternalState$4(this, {
        buffer: buffer,
        byteLength: byteLength,
        byteOffset: offset
      });
      if (!descriptors) {
        this.buffer = buffer;
        this.byteLength = byteLength;
        this.byteOffset = offset;
      }
    };

    if (descriptors) {
      addGetter($ArrayBuffer, 'byteLength');
      addGetter($DataView, 'buffer');
      addGetter($DataView, 'byteLength');
      addGetter($DataView, 'byteOffset');
    }

    redefineAll($DataView[PROTOTYPE$1], {
      getInt8: function getInt8(byteOffset) {
        return get$1(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get$1(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset /* , littleEndian */) {
        var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset /* , littleEndian */) {
        var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset /* , littleEndian */) {
        return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
      },
      getUint32: function getUint32(byteOffset /* , littleEndian */) {
        return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
        return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
      },
      getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
        return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
      },
      setInt8: function setInt8(byteOffset, value) {
        set$2(this, 1, byteOffset, packInt8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set$2(this, 1, byteOffset, packInt8, value);
      },
      setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
        set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
        set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
        set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
        set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
        set$2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
        set$2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
      }
    });
  } else {
    /* eslint-disable no-new -- required for testing */
    if (!fails(function () {
      NativeArrayBuffer(1);
    }) || !fails(function () {
      new NativeArrayBuffer(-1);
    }) || fails(function () {
      new NativeArrayBuffer();
      new NativeArrayBuffer(1.5);
      new NativeArrayBuffer(NaN);
      return NativeArrayBuffer.name != ARRAY_BUFFER;
    })) {
    /* eslint-enable no-new -- required for testing */
      $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, $ArrayBuffer);
        return new NativeArrayBuffer(toIndex(length));
      };
      var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$1] = NativeArrayBuffer[PROTOTYPE$1];
      for (var keys$2 = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys$2.length > j;) {
        if (!((key = keys$2[j++]) in $ArrayBuffer)) {
          createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
        }
      }
      ArrayBufferPrototype.constructor = $ArrayBuffer;
    }

    // WebKit bug - the same parent prototype for typed arrays and data view
    if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
      objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
    }

    // iOS Safari 7.x bug
    var testView = new $DataView(new $ArrayBuffer(2));
    var nativeSetInt8 = $DataViewPrototype.setInt8;
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
      setInt8: function setInt8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      }
    }, { unsafe: true });
  }

  setToStringTag($ArrayBuffer, ARRAY_BUFFER);
  setToStringTag($DataView, DATA_VIEW);

  var arrayBuffer = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
  };

  var toPositiveInteger = function (it) {
    var result = toInteger(it);
    if (result < 0) throw RangeError("The argument can't be less than 0");
    return result;
  };

  var toOffset = function (it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw RangeError('Wrong offset');
    return offset;
  };

  var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

  var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, step, iterator, next;
    if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
      iterator = iteratorMethod.call(O);
      next = iterator.next;
      O = [];
      while (!(step = next.call(iterator)).done) {
        O.push(step.value);
      }
    }
    if (mapping && argumentsLength > 2) {
      mapfn = functionBindContext(mapfn, arguments[2], 2);
    }
    length = toLength(O.length);
    result = new (aTypedArrayConstructor$1(this))(length);
    for (i = 0; length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var typedArrayConstructor = createCommonjsModule(function (module) {


















  var getOwnPropertyNames = objectGetOwnPropertyNames.f;

  var forEach = arrayIteration.forEach;






  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var nativeDefineProperty = objectDefineProperty.f;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var round = Math.round;
  var RangeError = global$1.RangeError;
  var ArrayBuffer = arrayBuffer.ArrayBuffer;
  var DataView = arrayBuffer.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = arrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = arrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, { get: function () {
      return getInternalState(this)[key];
    } });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target)
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true))
      ? createPropertyDescriptor(2, target[key])
      : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true))
      && isObject(descriptor)
      && has(descriptor, 'value')
      && !has(descriptor, 'get')
      && !has(descriptor, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !descriptor.configurable
      && (!has(descriptor, 'writable') || descriptor.writable)
      && (!has(descriptor, 'enumerable') || descriptor.enumerable)
    ) {
      target[key] = descriptor.value;
      return target;
    } return nativeDefineProperty(target, key, descriptor);
  };

  if (descriptors) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
      objectDefineProperty.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, 'buffer');
      addGetter(TypedArrayPrototype, 'byteOffset');
      addGetter(TypedArrayPrototype, 'byteLength');
      addGetter(TypedArrayPrototype, 'length');
    }

    _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty
    });

    module.exports = function (TYPE, wrapper, CLAMPED) {
      var BYTES = TYPE.match(/\d+$/)[0] / 8;
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + TYPE;
      var SETTER = 'set' + TYPE;
      var NativeTypedArrayConstructor = global$1[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};

      var getter = function (that, index) {
        var data = getInternalState(that);
        return data.view[GETTER](index * BYTES + data.byteOffset, true);
      };

      var setter = function (that, index, value) {
        var data = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
      };

      var addElement = function (that, index) {
        nativeDefineProperty(that, index, {
          get: function () {
            return getter(this, index);
          },
          set: function (value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };

      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength, length;
          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new ArrayBuffer(byteLength);
          } else if (isArrayBuffer(data)) {
            buffer = data;
            byteOffset = toOffset(offset, BYTES);
            var $len = data.byteLength;
            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - byteOffset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
            }
            length = byteLength / BYTES;
          } else if (isTypedArray(data)) {
            return fromList(TypedArrayConstructor, data);
          } else {
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }
          setInternalState(that, {
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength,
            length: length,
            view: new DataView(buffer)
          });
          while (index < length) addElement(that, index++);
        });

        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
      } else if (typedArrayConstructorsRequireWrappers) {
        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
          return inheritIfRequired(function () {
            if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
            if (isArrayBuffer(data)) return $length !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
              : typedArrayOffset !== undefined
                ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
                : new NativeTypedArrayConstructor(data);
            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }(), dummy, TypedArrayConstructor);
        });

        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
          }
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }

      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
      }

      if (TYPED_ARRAY_TAG) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      }

      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

      _export({
        global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
      }, exported);

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }

      setSpecies(CONSTRUCTOR_NAME);
    };
  } else module.exports = function () { /* empty */ };
  });

  // `Uint8Array` constructor
  // https://tc39.es/ecma262/#sec-typedarray-objects
  typedArrayConstructor('Uint8', function (init) {
    return function Uint8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  var min$5 = Math.min;

  // `Array.prototype.copyWithin` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.copywithin
  var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = min$5((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O) O[to] = O[from];
      else delete O[to];
      to += inc;
      from += inc;
    } return O;
  };

  var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.copyWithin` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
  exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start /* , end */) {
    return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
  });

  var $every = arrayIteration.every;

  var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.every` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
  exportTypedArrayMethod$2('every', function every(callbackfn /* , thisArg */) {
    return $every(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.fill` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  exportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {
    return arrayFill.apply(aTypedArray$3(this), arguments);
  });

  var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;


  var typedArrayFromSpeciesAndList = function (instance, list) {
    var C = speciesConstructor(instance, instance.constructor);
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor$2(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var $filter$1 = arrayIteration.filter;


  var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.filter` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
  exportTypedArrayMethod$4('filter', function filter(callbackfn /* , thisArg */) {
    var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return typedArrayFromSpeciesAndList(this, list);
  });

  var $find = arrayIteration.find;

  var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.find` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
  exportTypedArrayMethod$5('find', function find(predicate /* , thisArg */) {
    return $find(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $findIndex = arrayIteration.findIndex;

  var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
  exportTypedArrayMethod$6('findIndex', function findIndex(predicate /* , thisArg */) {
    return $findIndex(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $forEach$1 = arrayIteration.forEach;

  var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
  exportTypedArrayMethod$7('forEach', function forEach(callbackfn /* , thisArg */) {
    $forEach$1(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $includes$1 = arrayIncludes.includes;

  var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.includes` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
  exportTypedArrayMethod$8('includes', function includes(searchElement /* , fromIndex */) {
    return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $indexOf = arrayIncludes.indexOf;

  var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
  exportTypedArrayMethod$9('indexOf', function indexOf(searchElement /* , fromIndex */) {
    return $indexOf(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
  });

  var ITERATOR$6 = wellKnownSymbol('iterator');
  var Uint8Array$1 = global$1.Uint8Array;
  var arrayValues = es_array_iterator.values;
  var arrayKeys = es_array_iterator.keys;
  var arrayEntries = es_array_iterator.entries;
  var aTypedArray$a = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
  var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR$6];

  var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
    && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

  var typedArrayValues = function values() {
    return arrayValues.call(aTypedArray$a(this));
  };

  // `%TypedArray%.prototype.entries` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
  exportTypedArrayMethod$a('entries', function entries() {
    return arrayEntries.call(aTypedArray$a(this));
  });
  // `%TypedArray%.prototype.keys` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
  exportTypedArrayMethod$a('keys', function keys() {
    return arrayKeys.call(aTypedArray$a(this));
  });
  // `%TypedArray%.prototype.values` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
  exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME);
  // `%TypedArray%.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
  exportTypedArrayMethod$a(ITERATOR$6, typedArrayValues, !CORRECT_ITER_NAME);

  var aTypedArray$b = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
  var $join = [].join;

  // `%TypedArray%.prototype.join` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  exportTypedArrayMethod$b('join', function join(separator) {
    return $join.apply(aTypedArray$b(this), arguments);
  });

  var min$6 = Math.min;
  var nativeLastIndexOf = [].lastIndexOf;
  var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
  var STRICT_METHOD$2 = arrayMethodIsStrict('lastIndexOf');
  var FORCED$3 = NEGATIVE_ZERO || !STRICT_METHOD$2;

  // `Array.prototype.lastIndexOf` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.lastindexof
  var arrayLastIndexOf = FORCED$3 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = min$6(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
    return -1;
  } : nativeLastIndexOf;

  var aTypedArray$c = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.lastIndexOf` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
    return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
  });

  var $map$1 = arrayIteration.map;


  var aTypedArray$d = arrayBufferViewCore.aTypedArray;
  var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
  var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.map` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
  exportTypedArrayMethod$d('map', function map(mapfn /* , thisArg */) {
    return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
      return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
    });
  });

  // `Array.prototype.{ reduce, reduceRight }` methods implementation
  var createMethod$3 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aFunction$1(callbackfn);
      var O = toObject(that);
      var self = indexedObject(O);
      var length = toLength(O.length);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError('Reduce of empty array with no initial value');
        }
      }
      for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod$3(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod$3(true)
  };

  var $reduce = arrayReduce.left;

  var aTypedArray$e = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
  exportTypedArrayMethod$e('reduce', function reduce(callbackfn /* , initialValue */) {
    return $reduce(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $reduceRight = arrayReduce.right;

  var aTypedArray$f = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.reduceRicht` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
  exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
    return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$g = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
  var floor$3 = Math.floor;

  // `%TypedArray%.prototype.reverse` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
  exportTypedArrayMethod$g('reverse', function reverse() {
    var that = this;
    var length = aTypedArray$g(that).length;
    var middle = floor$3(length / 2);
    var index = 0;
    var value;
    while (index < middle) {
      value = that[index];
      that[index++] = that[--length];
      that[length] = value;
    } return that;
  });

  var aTypedArray$h = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;

  var FORCED$4 = fails(function () {
    /* global Int8Array -- safe */
    new Int8Array(1).set({});
  });

  // `%TypedArray%.prototype.set` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
  exportTypedArrayMethod$h('set', function set(arrayLike /* , offset */) {
    aTypedArray$h(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError('Wrong length');
    while (index < len) this[offset + index] = src[index++];
  }, FORCED$4);

  var aTypedArray$i = arrayBufferViewCore.aTypedArray;
  var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
  var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
  var $slice = [].slice;

  var FORCED$5 = fails(function () {
    /* global Int8Array -- safe */
    new Int8Array(1).slice();
  });

  // `%TypedArray%.prototype.slice` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
  exportTypedArrayMethod$i('slice', function slice(start, end) {
    var list = $slice.call(aTypedArray$i(this), start, end);
    var C = speciesConstructor(this, this.constructor);
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor$4(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  }, FORCED$5);

  var $some = arrayIteration.some;

  var aTypedArray$j = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.some` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
  exportTypedArrayMethod$j('some', function some(callbackfn /* , thisArg */) {
    return $some(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$k = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
  var $sort = [].sort;

  // `%TypedArray%.prototype.sort` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
  exportTypedArrayMethod$k('sort', function sort(comparefn) {
    return $sort.call(aTypedArray$k(this), comparefn);
  });

  var aTypedArray$l = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.subarray` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
  exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
    var O = aTypedArray$l(this);
    var length = O.length;
    var beginIndex = toAbsoluteIndex(begin, length);
    return new (speciesConstructor(O, O.constructor))(
      O.buffer,
      O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
      toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
    );
  });

  var Int8Array$3 = global$1.Int8Array;
  var aTypedArray$m = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
  var $toLocaleString = [].toLocaleString;
  var $slice$1 = [].slice;

  // iOS Safari 6.x fails here
  var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
    $toLocaleString.call(new Int8Array$3(1));
  });

  var FORCED$6 = fails(function () {
    return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
  }) || !fails(function () {
    Int8Array$3.prototype.toLocaleString.call([1, 2]);
  });

  // `%TypedArray%.prototype.toLocaleString` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
  exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
    return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
  }, FORCED$6);

  var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;



  var Uint8Array$2 = global$1.Uint8Array;
  var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
  var arrayToString = [].toString;
  var arrayJoin = [].join;

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

  // `%TypedArray%.prototype.toString` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
  exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

  var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
  var DataView$1 = arrayBuffer.DataView;
  var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;

  var INCORRECT_SLICE = fails(function () {
    return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
  });

  // `ArrayBuffer.prototype.slice` method
  // https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
  _export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
    slice: function slice(start, end) {
      if (nativeArrayBufferSlice !== undefined && end === undefined) {
        return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
      }
      var length = anObject(this).byteLength;
      var first = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
      var viewSource = new DataView$1(this);
      var viewTarget = new DataView$1(result);
      var index = 0;
      while (first < fin) {
        viewTarget.setUint8(index++, viewSource.getUint8(first++));
      } return result;
    }
  });

  // a string of all valid unicode whitespaces
  var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
    '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var whitespace = '[' + whitespaces + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$');

  // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
  var createMethod$4 = function (TYPE) {
    return function ($this) {
      var string = String(requireObjectCoercible($this));
      if (TYPE & 1) string = string.replace(ltrim, '');
      if (TYPE & 2) string = string.replace(rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod$4(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod$4(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod$4(3)
  };

  var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
  var defineProperty$5 = objectDefineProperty.f;
  var trim = stringTrim.trim;

  var NUMBER = 'Number';
  var NativeNumber = global$1[NUMBER];
  var NumberPrototype = NativeNumber.prototype;

  // Opera ~12 has broken Object#toString
  var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

  // `ToNumber` abstract operation
  // https://tc39.es/ecma262/#sec-tonumber
  var toNumber = function (argument) {
    var it = toPrimitive(argument, false);
    var first, third, radix, maxCode, digits, length, index, code;
    if (typeof it == 'string' && it.length > 2) {
      it = trim(it);
      first = it.charCodeAt(0);
      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
          case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
          default: return +it;
        }
        digits = it.slice(2);
        length = digits.length;
        for (index = 0; index < length; index++) {
          code = digits.charCodeAt(index);
          // parseInt parses a string to a first unavailable symbol
          // but ToNumber should return NaN if a string contains unavailable symbols
          if (code < 48 || code > maxCode) return NaN;
        } return parseInt(digits, radix);
      }
    } return +it;
  };

  // `Number` constructor
  // https://tc39.es/ecma262/#sec-number-constructor
  if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
    var NumberWrapper = function Number(value) {
      var it = arguments.length < 1 ? 0 : value;
      var dummy = this;
      return dummy instanceof NumberWrapper
        // check on 1..constructor(foo) case
        && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
          ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
    };
    for (var keys$3 = descriptors ? getOwnPropertyNames$2(NativeNumber) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES2015 (in case, if modules with ES2015 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +
      // ESNext
      'fromString,range'
    ).split(','), j$1 = 0, key$1; keys$3.length > j$1; j$1++) {
      if (has(NativeNumber, key$1 = keys$3[j$1]) && !has(NumberWrapper, key$1)) {
        defineProperty$5(NumberWrapper, key$1, getOwnPropertyDescriptor$3(NativeNumber, key$1));
      }
    }
    NumberWrapper.prototype = NumberPrototype;
    NumberPrototype.constructor = NumberWrapper;
    redefine(global$1, NUMBER, NumberWrapper);
  }

  /**
   * 通信协议中 fixHeader 第一个字节中的 Qos 数据标识
   * ```
   * fixHeader：command(4 bit) | dup(1 bit) | Qos(2 bit) | retain(1 bit)
   * ```
   */
  var QOS;

  (function (QOS) {
    QOS[QOS["AT_MOST_ONCE"] = 0] = "AT_MOST_ONCE";
    QOS[QOS["AT_LEAST_ONCE"] = 1] = "AT_LEAST_ONCE";
    QOS[QOS["EXACTLY_ONCE"] = 2] = "EXACTLY_ONCE";
    QOS[QOS["DEFAULT"] = 3] = "DEFAULT";
  })(QOS || (QOS = {}));
  /**
   * 通信协议中 fixHeader 第一个字节中的 command 数据标识，用于判断操作类型
   * ```
   * fixHeader：command(4 bit) | dup(1 bit) | Qos(2 bit) | retain(1 bit)
   * ```
   */


  var OperationType;

  (function (OperationType) {
    /** 私有云专用，解密协商指令 */
    OperationType[OperationType["SYMMETRIC"] = 0] = "SYMMETRIC";
    /** 连接请求 */

    OperationType[OperationType["CONNECT"] = 1] = "CONNECT";
    /** 连接应答 */

    OperationType[OperationType["CONN_ACK"] = 2] = "CONN_ACK";
    /** 上行发送消息 */

    OperationType[OperationType["PUBLISH"] = 3] = "PUBLISH";
    /** 上行发送消息的应答 */

    OperationType[OperationType["PUB_ACK"] = 4] = "PUB_ACK";
    /** 上行拉消息 */

    OperationType[OperationType["QUERY"] = 5] = "QUERY";
    /** 上行拉消息的应答 */

    OperationType[OperationType["QUERY_ACK"] = 6] = "QUERY_ACK";
    /** QueryConfirm */

    OperationType[OperationType["QUERY_CONFIRM"] = 7] = "QUERY_CONFIRM";
    OperationType[OperationType["SUBSCRIBE"] = 8] = "SUBSCRIBE";
    OperationType[OperationType["SUB_ACK"] = 9] = "SUB_ACK";
    OperationType[OperationType["UNSUBSCRIBE"] = 10] = "UNSUBSCRIBE";
    OperationType[OperationType["UNSUB_ACK"] = 11] = "UNSUB_ACK";
    OperationType[OperationType["PING_REQ"] = 12] = "PING_REQ";
    OperationType[OperationType["PING_RESP"] = 13] = "PING_RESP";
    /** 连接挂断 */

    OperationType[OperationType["DISCONNECT"] = 14] = "DISCONNECT";
    OperationType[OperationType["RESERVER2"] = 15] = "RESERVER2";
  })(OperationType || (OperationType = {}));

  var MessageName;

  (function (MessageName) {
    MessageName["CONN_ACK"] = "ConnAckMessage";
    MessageName["DISCONNECT"] = "DisconnectMessage";
    MessageName["PING_REQ"] = "PingReqMessage";
    MessageName["PING_RESP"] = "PingRespMessage";
    MessageName["PUBLISH"] = "PublishMessage";
    MessageName["PUB_ACK"] = "PubAckMessage";
    MessageName["QUERY"] = "QueryMessage";
    MessageName["QUERY_CON"] = "QueryConMessage";
    MessageName["QUERY_ACK"] = "QueryAckMessage";
  })(MessageName || (MessageName = {}));
  var IDENTIFIER;

  (function (IDENTIFIER) {
    IDENTIFIER["PUB"] = "pub";
    IDENTIFIER["QUERY"] = "qry";
  })(IDENTIFIER || (IDENTIFIER = {}));

  /**
   * @todo 注释补全
   * @description
   * Header 处理
  */

  var Header = /*#__PURE__*/function () {
    function Header(type) {
      var retain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var qos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QOS.AT_LEAST_ONCE;
      var dup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      _classCallCheck(this, Header);

      this._retain = false;
      this.qos = QOS.AT_LEAST_ONCE;
      this._dup = false;
      this.syncMsg = false;
      var isPlusType = type > 0; // 是否为正数

      if (type && isPlusType && arguments.length === 1) {
        this._retain = (type & 1) > 0;
        this.qos = (type & 6) >> 1; // (_type & 0b110) >> 1

        this._dup = (type & 8) > 0; // (_type & 0b1000) > 0

        this.type = type >> 4 & 15; // (_type >> 0b100) & 0b1111

        this.syncMsg = (type & 8) === 8; // (_type & 0b1000) === 0b1000;
      } else {
        this.type = type;
        this._retain = retain;
        this.qos = qos;
        this._dup = dup;
      }
    }

    _createClass(Header, [{
      key: "encode",
      value: function encode() {
        // const validQosList = [QOS.AT_MOST_ONCE, QOS.AT_LEAST_ONCE, QOS.EXACTLY_ONCE, QOS.DEFAULT]
        // // 如果 qos 为字符串, 此处转为数字
        // for (let i = 0; i < validQosList.length; i++) {
        //   if (this.qos === validQosList[i]) {
        //     this.qos = validQosList[i]
        //   }
        // }
        var byte = this.type << 4; // 4 -> 100

        byte |= this._retain ? 1 : 0;
        byte |= this.qos << 1;
        byte |= this._dup ? 8 : 0; // 8 -> 1000

        return byte;
      }
    }]);

    return Header;
  }();
  /**
   * @description
   * 二进制处理
  */

  var BinaryHelper = /*#__PURE__*/function () {
    function BinaryHelper() {
      _classCallCheck(this, BinaryHelper);
    }

    _createClass(BinaryHelper, null, [{
      key: "writeUTF",
      value:
      /**
       * @description
       * 将字符串转化为 utf8 编码组成的数组
       * @param {string} str 待转化的字符串
       * @param {boolean} isGetBytes 是否向前插入字符长度
       */
      function writeUTF(str, isGetBytes) {
        var back = [];
        var byteSize = 0;

        if (isString(str)) {
          for (var i = 0, len = str.length; i < len; i++) {
            var code = str.charCodeAt(i);

            if (code >= 0 && code <= 127) {
              byteSize += 1;
              back.push(code);
            } else if (code >= 128 && code <= 2047) {
              byteSize += 2;
              back.push(192 | 31 & code >> 6);
              back.push(128 | 63 & code);
            } else if (code >= 2048 && code <= 65535) {
              byteSize += 3;
              back.push(224 | 15 & code >> 12);
              back.push(128 | 63 & code >> 6);
              back.push(128 | 63 & code);
            }
          }
        }

        for (var _i = 0, _len = back.length; _i < _len; _i++) {
          if (back[_i] > 255) {
            back[_i] &= 255;
          }
        }

        if (isGetBytes) {
          return back;
        }

        if (byteSize <= 255) {
          return [0, byteSize].concat(back);
        } else {
          return [byteSize >> 8, byteSize & 255].concat(back);
        }
      }
      /**
       * @description
       * 获取二进制字节流的 utf8 编码结果
       * @param {Array<number>} arr 二进制数据
       */

    }, {
      key: "readUTF",
      value: function readUTF(arr) {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var strBytes = arr;
        var result = '';

        while (++index < strBytes.length) {
          var codePoint = Number(strBytes[index]);

          if (codePoint === (codePoint & 0x7F)) ; else if ((codePoint & 0xF0) === 0xF0) {
            codePoint ^= 0xF0;
            codePoint = codePoint << 6 | strBytes[++index] ^ 0x80;
            codePoint = codePoint << 6 | strBytes[++index] ^ 0x80;
            codePoint = codePoint << 6 | strBytes[++index] ^ 0x80;
          } else if ((codePoint & 0xE0) === 0xE0) {
            codePoint ^= 0xE0;
            codePoint = codePoint << 6 | strBytes[++index] ^ 0x80;
            codePoint = codePoint << 6 | strBytes[++index] ^ 0x80;
          } else if ((codePoint & 0xC0) === 0xC0) {
            codePoint ^= 0xC0;
            codePoint = codePoint << 6 | strBytes[++index] ^ 0x80;
          }

          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || Math.floor(codePoint) !== codePoint) {
            throw RangeError('Invalid code point: ' + codePoint);
          }

          if (codePoint <= 0xFFFF) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 0x10000;
            highSurrogate = codePoint >> 10 | 0xD800;
            lowSurrogate = codePoint % 0x400 | 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }

          if (index + 1 === strBytes.length || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }

        return result;
      }
    }]);

    return BinaryHelper;
  }();
  /**
   * @description
   * 融云读取二进制数据
  */

  var RongStreamReader = /*#__PURE__*/function () {
    function RongStreamReader(arr) {
      _classCallCheck(this, RongStreamReader);

      // 当前流已截取到的位置
      this._position = 0; // 待处理数据的总长度

      this._poolLen = 0;
      this._pool = arr;
      this._poolLen = arr.length;
    }

    _createClass(RongStreamReader, [{
      key: "check",
      value: function check() {
        return this._position >= this._pool.length;
      }
      /**
       * 读 4 位
       */

    }, {
      key: "readInt",
      value: function readInt() {
        var self = this;

        if (self.check()) {
          return -1;
        }

        var end = '';

        for (var i = 0; i < 4; i++) {
          var t = self._pool[self._position++].toString(16);

          if (t.length === 1) {
            t = '0' + t;
          }

          end += t.toString();
        }

        return parseInt(end, 16);
      }
      /**
       * 读 8 位
       */

    }, {
      key: "readLong",
      value: function readLong() {
        var self = this;

        if (self.check()) {
          return -1;
        }

        var end = '';

        for (var i = 0; i < 8; i++) {
          var t = self._pool[self._position++].toString(16);

          if (t.length === 1) {
            t = '0' + t;
          }

          end += t;
        }

        return parseInt(end, 16);
      }
      /**
       * 读 1 位
       */

    }, {
      key: "readByte",
      value: function readByte() {
        if (this.check()) {
          return -1;
        }

        var val = this._pool[this._position++];

        if (val > 255) {
          val &= 255;
        }

        return val;
      }
      /**
       * 获取数据
       */

    }, {
      key: "readUTF",
      value: function readUTF() {
        if (this.check()) {
          return '';
        }

        var big = this.readByte() << 8 | this.readByte();

        var pool = this._pool.subarray(this._position, this._position += big);

        return BinaryHelper.readUTF(pool);
      }
      /**
       * 读剩余的所有值
       */

    }, {
      key: "readAll",
      value: function readAll() {
        return this._pool.subarray(this._position, this._poolLen);
      }
    }]);

    return RongStreamReader;
  }();
  /**
   * @description
   * 融云写入二进制数据
  */

  var RongStreamWriter = /*#__PURE__*/function () {
    function RongStreamWriter() {
      _classCallCheck(this, RongStreamWriter);

      // 待处理的数据, 由 server 直接抛出的数据
      this._pool = []; // 当前流已截取到的位置

      this._position = 0; // 当前流写入的多少字节

      this._writen = 0;
    }
    /**
     * 写入缓存区, writen 值往后移
     */


    _createClass(RongStreamWriter, [{
      key: "write",
      value: function write(byte) {
        // todo
        if (Object.prototype.toString.call(byte).indexOf('Array') !== -1) {
          this._pool = this._pool.concat(byte);
        } else if (byte >= 0) {
          if (byte > 255) {
            byte &= 255;
          }

          this._pool.push(byte);

          this._writen++;
        }

        return byte;
      }
    }, {
      key: "writeArr",
      value: function writeArr(byte) {
        this._pool = this._pool.concat(byte);
        return byte;
      } // PENDING. 用于 ConnectMessage, 暂未知此消息用途
      // writeChat(v: number) {
      //   if (+v != v) {
      //     throw new Error("writeChar:arguments type is error");
      //   }
      //   this.write(v >> 8 & 255);
      //   this.write(v & 255);
      //   this.writen += 2;
      // }

    }, {
      key: "writeUTF",
      value: function writeUTF(str) {
        var val = BinaryHelper.writeUTF(str);
        this._pool = this._pool.concat(val);
        this._writen += val.length;
      } // PENDING. 暂仅知道 write 时使用, 此时 this.poolLen 为 0, 调用无意义
      // toComplements(): any {
      //   var _tPool = this.pool;
      //   for (var i = 0; i < this.poolLen; i++) {
      //     if (_tPool[i] > 128) {
      //       _tPool[i] -= 256;
      //     }
      //   }
      //   return _tPool;
      // }

    }, {
      key: "getBytesArray",
      value: function getBytesArray() {
        return this._pool;
      }
    }]);

    return RongStreamWriter;
  }();

  var PBName = {
    UpStreamMessage: 'UpStreamMessage',
    PushExtra: 'PushExtra',
    DownStreamMessage: 'DownStreamMessage',
    DownStreamMessages: 'DownStreamMessages',
    SessionsAttQryInput: 'SessionsAttQryInput',
    SessionsAttOutput: 'SessionsAttOutput',
    SyncRequestMsg: 'SyncRequestMsg',
    ChrmPullMsg: 'ChrmPullMsg',
    NotifyMsg: 'NotifyMsg',
    HistoryMsgInput: 'HistoryMsgInput',
    HistoryMsgOuput: 'HistoryMsgOuput',
    RelationQryInput: 'RelationQryInput',
    RelationsOutput: 'RelationsOutput',
    DeleteSessionsInput: 'DeleteSessionsInput',
    SessionInfo: 'SessionInfo',
    DeleteSessionsOutput: 'DeleteSessionsOutput',
    RelationsInput: 'RelationsInput',
    DeleteMsgInput: 'DeleteMsgInput',
    CleanHisMsgInput: 'CleanHisMsgInput',
    SessionMsgReadInput: 'SessionMsgReadInput',
    ChrmInput: 'ChrmInput',
    QueryChatRoomInfoInput: 'QueryChatRoomInfoInput',
    QueryChatRoomInfoOutput: 'QueryChatRoomInfoOutput',
    RtcInput: 'RtcInput',
    RtcUserListOutput: 'RtcUserListOutput',
    SetUserStatusInput: 'SetUserStatusInput',
    RtcSetDataInput: 'RtcSetDataInput',
    RtcUserSetDataInput: 'RtcUserSetDataInput',
    RtcDataInput: 'RtcDataInput',
    RtcSetOutDataInput: 'RtcSetOutDataInput',
    MCFollowInput: 'MCFollowInput',
    RtcTokenOutput: 'RtcTokenOutput',
    RtcQryOutput: 'RtcQryOutput',
    RtcQryUserOutDataInput: 'RtcQryUserOutDataInput',
    RtcUserOutDataOutput: 'RtcUserOutDataOutput',
    RtcQueryListInput: 'RtcQueryListInput',
    RtcRoomInfoOutput: 'RtcRoomInfoOutput',
    RtcValueInfo: 'RtcValueInfo',
    RtcKeyDeleteInput: 'RtcKeyDeleteInput',
    GetQNupTokenInput: 'GetQNupTokenInput',
    GetQNupTokenOutput: 'GetQNupTokenOutput',
    GetQNdownloadUrlInput: 'GetQNdownloadUrlInput',
    GetDownloadUrlInput: 'GetDownloadUrlInput',
    GetQNdownloadUrlOutput: 'GetQNdownloadUrlOutput',
    GetDownloadUrlOutput: 'GetDownloadUrlOutput',
    SetChrmKV: 'SetChrmKV',
    ChrmKVOutput: 'ChrmKVOutput',
    QueryChrmKV: 'QueryChrmKV',
    SetUserSettingInput: 'SetUserSettingInput',
    SetUserSettingOutput: 'SetUserSettingOutput',
    PullUserSettingInput: 'PullUserSettingInput',
    PullUserSettingOutput: 'PullUserSettingOutput',
    UserSettingNotification: 'UserSettingNotification',
    SessionReq: 'SessionReq',
    SessionStates: 'SessionStates',
    SessionState: 'SessionState',
    SessionStateItem: 'SessionStateItem',
    SessionStateModifyReq: 'SessionStateModifyReq',
    SessionStateModifyResp: 'SessionStateModifyResp',
    SessionTagAddInput: 'SessionTagAddInput',
    SessionTagItem: 'SessionTagItem',
    SessionTagDelInput: 'SessionTagDelInput',
    SessionDisTagReq: 'SessionDisTagReq' // 解除会话标签关系

  };

  var _SSMsg;
  var SSMsg = (_SSMsg = {}, _defineProperty(_SSMsg, PBName.UpStreamMessage, ['sessionId', 'classname', 'content', 'pushText', 'userId', 'configFlag', 'appData', 'extraContent', 'pushExt']), _defineProperty(_SSMsg, PBName.DownStreamMessages, ['list', 'syncTime', 'finished']), _defineProperty(_SSMsg, PBName.DownStreamMessage, ['fromUserId', 'type', 'groupId', 'classname', 'content', 'dataTime', 'status', 'msgId', 'extraContent', 'pushContent', 'configFlag', 'pushExt']), _defineProperty(_SSMsg, PBName.PushExtra, ['title', 'templateIdNoUse', 'pushId', 'pushConfigs', 'templateId']), _defineProperty(_SSMsg, PBName.SessionsAttQryInput, ['nothing']), _defineProperty(_SSMsg, PBName.SessionsAttOutput, ['inboxTime', 'sendboxTime', 'totalUnreadCount']), _defineProperty(_SSMsg, PBName.SyncRequestMsg, ['syncTime', 'ispolling', 'isweb', 'isPullSend', 'isKeeping', 'sendBoxSyncTime']), _defineProperty(_SSMsg, PBName.ChrmPullMsg, ['syncTime', 'count']), _defineProperty(_SSMsg, PBName.NotifyMsg, ['type', 'time', 'chrmId']), _defineProperty(_SSMsg, PBName.HistoryMsgInput, ['targetId', 'time', 'count', 'order']), _defineProperty(_SSMsg, PBName.HistoryMsgOuput, ['list', 'syncTime', 'hasMsg']), _defineProperty(_SSMsg, PBName.RelationQryInput, ['type', 'count', 'startTime', 'order']), _defineProperty(_SSMsg, PBName.RelationsOutput, ['info']), _defineProperty(_SSMsg, PBName.DeleteSessionsInput, ['sessions']), _defineProperty(_SSMsg, PBName.SessionInfo, ['type', 'channelId']), _defineProperty(_SSMsg, PBName.DeleteSessionsOutput, ['nothing']), _defineProperty(_SSMsg, PBName.RelationsInput, ['type', 'msg', 'count', 'offset', 'startTime', 'endTime']), _defineProperty(_SSMsg, PBName.DeleteMsgInput, ['type', 'conversationId', 'msgs']), _defineProperty(_SSMsg, PBName.CleanHisMsgInput, ['targetId', 'dataTime', 'conversationType']), _defineProperty(_SSMsg, PBName.SessionMsgReadInput, ['type', 'msgTime', 'channelId']), _defineProperty(_SSMsg, PBName.ChrmInput, ['nothing']), _defineProperty(_SSMsg, PBName.QueryChatRoomInfoInput, ['count', 'order']), _defineProperty(_SSMsg, PBName.QueryChatRoomInfoOutput, ['userTotalNums', 'userInfos']), _defineProperty(_SSMsg, PBName.GetQNupTokenInput, ['type', 'key']), _defineProperty(_SSMsg, PBName.GetQNdownloadUrlInput, ['type', 'key', 'fileName']), _defineProperty(_SSMsg, PBName.GetDownloadUrlInput, ['type', 'key', 'fileName']), _defineProperty(_SSMsg, PBName.GetQNupTokenOutput, ['deadline', 'token', 'bosToken', 'bosDate', 'path', 'osskeyId', 'ossPolicy', 'ossSign', 'ossBucketName']), _defineProperty(_SSMsg, PBName.GetQNdownloadUrlOutput, ['downloadUrl']), _defineProperty(_SSMsg, PBName.GetDownloadUrlOutput, ['downloadUrl']), _defineProperty(_SSMsg, PBName.SetChrmKV, ['entry', 'bNotify', 'notification', 'type']), _defineProperty(_SSMsg, PBName.ChrmKVOutput, ['entries', 'bFullUpdate', 'syncTime']), _defineProperty(_SSMsg, PBName.QueryChrmKV, ['timestamp']), _defineProperty(_SSMsg, PBName.SetUserSettingInput, ['version', 'value']), _defineProperty(_SSMsg, PBName.SetUserSettingOutput, ['version', 'reserve']), _defineProperty(_SSMsg, PBName.PullUserSettingInput, ['version', 'reserve']), _defineProperty(_SSMsg, PBName.PullUserSettingOutput, ['items', 'version']), _defineProperty(_SSMsg, "UserSettingItem", ['targetId', 'type', 'key', 'value', 'version', 'status', 'tags']), _defineProperty(_SSMsg, PBName.SessionReq, ['time']), _defineProperty(_SSMsg, PBName.SessionStates, ['version', 'state']), _defineProperty(_SSMsg, PBName.SessionState, ['type', 'channelId', 'time', 'stateItem']), _defineProperty(_SSMsg, PBName.SessionStateItem, ['sessionStateType', 'value', 'tags']), _defineProperty(_SSMsg, PBName.SessionStateModifyReq, ['version', 'state']), _defineProperty(_SSMsg, PBName.SessionStateModifyResp, ['version']), _defineProperty(_SSMsg, PBName.SessionTagAddInput, ['version', 'tags']), _defineProperty(_SSMsg, PBName.SessionTagItem, ['tagId', 'name', 'createdTime', 'isTop']), _defineProperty(_SSMsg, PBName.SessionTagDelInput, ['version', 'tags']), _defineProperty(_SSMsg, PBName.SessionDisTagReq, ['tagId']), _defineProperty(_SSMsg, PBName.UserSettingNotification, ['version', 'reserve']), _SSMsg);

  var Codec = {};

  var _loop = function _loop(key) {
    var paramsList = SSMsg[key];

    Codec[key] = function () {
      var data = {};
      var ins = {
        getArrayData: function getArrayData() {
          return data;
        }
      };

      var _loop2 = function _loop2(i) {
        var param = paramsList[i];
        var setEventName = "set".concat(toUpperCase(param, 0, 1));

        ins[setEventName] = function (item) {
          data[param] = item;
        };
      };

      for (var i = 0; i < paramsList.length; i++) {
        _loop2(i);
      }

      return ins;
    };

    Codec[key].decode = function (data) {
      var decodeResult = {};

      if (isString(data)) {
        data = JSON.parse(data);
      }

      var _loop3 = function _loop3(_key) {
        var getEventName = "get".concat(toUpperCase(_key, 0, 1));
        decodeResult[_key] = data[_key];

        decodeResult[getEventName] = function () {
          return data[_key];
        };
      };

      for (var _key in data) {
        _loop3(_key);
      }

      return decodeResult;
    };
  };

  for (var key$2 in SSMsg) {
    _loop(key$2);
  }

  Codec.getModule = function (pbName) {
    return Codec[pbName]();
  };

  // `Int8Array` constructor
  // https://tc39.es/ecma262/#sec-typedarray-objects
  typedArrayConstructor('Int8', function (init) {
    return function Int8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  var SSMsg$1 = "\npackage Modules;\nmessage probuf {\n  message ".concat(PBName.SetUserStatusInput, "\n  {\n    optional int32 status=1;\n  }\n\n  message SetUserStatusOutput\n  {\n    optional int32 nothing=1;\n  }\n\n  message GetUserStatusInput\n  {\n    optional int32 nothing=1;\n  }\n\n  message GetUserStatusOutput\n  {\n    optional string status=1;\n    optional string subUserId=2;\n  }\n\n  message SubUserStatusInput\n  {\n    repeated string userid =1;\n  }\n\n  message SubUserStatusOutput\n  {\n    optional int32 nothing=1; \n  }\n  message VoipDynamicInput\n  {\n    required int32  engineType = 1;\n    required string channelName = 2;\n    optional string channelExtra = 3;\n  }\n\n  message VoipDynamicOutput\n  {\n      required string dynamicKey=1;\n  }\n  message ").concat(PBName.NotifyMsg, " {\n    required int32 type = 1;\n    optional int64 time = 2;\n    optional string chrmId=3;\n  }\n  message ").concat(PBName.SyncRequestMsg, " {\n    required int64 syncTime = 1;\n    required bool ispolling = 2;\n    optional bool isweb=3;\n    optional bool isPullSend=4;\n    optional bool isKeeping=5;\n    optional int64 sendBoxSyncTime=6;\n  }\n  message ").concat(PBName.UpStreamMessage, " {\n    required int32 sessionId = 1;\n    required string classname = 2;\n    required bytes content = 3;\n    optional string pushText = 4;\n    optional string appData = 5;\n    repeated string userId = 6;\n    optional int64 delMsgTime = 7;\n    optional string delMsgId = 8;\n    optional int32 configFlag = 9;\n    optional int64 clientUniqueId = 10;\n    optional string extraContent = 11;\n    optional PushExtra pushExt = 12;\n  }\n  message ").concat(PBName.PushExtra, " {\n    optional string title = 1;\n    optional int32  templateIdNoUse= 2;\n    optional string pushId = 3;\n    optional string pushConfigs = 4;\n    optional string templateId = 5;\n  }\n  message ").concat(PBName.DownStreamMessages, " {\n    repeated DownStreamMessage list = 1;\n    required int64 syncTime = 2;\n    optional bool finished = 3;\n  }\n  message ").concat(PBName.DownStreamMessage, " {\n    required string fromUserId = 1;\n    required ChannelType type = 2;\n    optional string groupId = 3;\n    required string classname = 4;\n    required bytes content = 5;\n    required int64 dataTime = 6;\n    required int64 status = 7;\n    optional int64 extra = 8;\n    optional string msgId = 9;\n    optional int32 direction = 10;\n    optional int32 plantform =11;\n    optional int32 isRemoved = 12; \n    optional string source = 13; \n    optional int64 clientUniqueId = 14; \n    optional string extraContent = 15;\n    optional string pushContent = 16;\n    optional int32 configFlag = 17;\n    optional PushExtra pushExt = 18;\n  }\n  enum ChannelType {\n    PERSON = 1;\n    PERSONS = 2;\n    GROUP = 3;\n    TEMPGROUP = 4;\n    CUSTOMERSERVICE = 5;\n    NOTIFY = 6;\n    MC=7;\n    MP=8;\n  }\n  message CreateDiscussionInput {\n    optional string name = 1;\n  }\n  message CreateDiscussionOutput {\n    required string id = 1;\n  }\n  message ChannelInvitationInput {\n    repeated string users = 1;\n  }\n  message LeaveChannelInput {\n    required int32 nothing = 1;\n  }\n  message ChannelEvictionInput {\n    required string user = 1;\n  }\n  message RenameChannelInput {\n    required string name = 1;\n  }\n  message ChannelInfoInput {\n    required int32 nothing = 1;\n  }\n  message ChannelInfoOutput {\n    required ChannelType type = 1;\n    required string channelId = 2;\n    required string channelName = 3;\n    required string adminUserId = 4;\n    repeated string firstTenUserIds = 5;\n    required int32 openStatus = 6;\n  }\n  message ChannelInfosInput {\n    required int32 page = 1;\n    optional int32 number = 2;\n  }\n  message ChannelInfosOutput {\n    repeated ChannelInfoOutput channels = 1;\n    required int32 total = 2;\n  }\n  message MemberInfo {\n    required string userId = 1;\n    required string userName = 2;\n    required string userPortrait = 3;\n    required string extension = 4;\n  }\n  message GroupMembersInput {\n    required int32 page = 1;\n    optional int32 number = 2;\n  }\n  message GroupMembersOutput {\n    repeated MemberInfo members = 1;\n    required int32 total = 2;\n  }\n  message GetUserInfoInput {\n    required int32 nothing = 1;\n  }\n  message GetUserInfoOutput {\n    required string userId = 1;\n    required string userName = 2;\n    required string userPortrait = 3;\n  }\n  message GetSessionIdInput {\n    required int32 nothing = 1;\n  }\n  message GetSessionIdOutput {\n    required int32 sessionId = 1;\n  }\n  enum FileType {\n    image = ").concat(FileType$1.IMAGE, ";\n    audio = ").concat(FileType$1.AUDIO, ";\n    video = ").concat(FileType$1.VIDEO, ";\n    file = ").concat(FileType$1.FILE, ";\n  }\n  message ").concat(PBName.GetQNupTokenInput, " {\n    required FileType type = 1;\n    optional string key = 2;\n  }\n  message ").concat(PBName.GetQNdownloadUrlInput, " {\n    required FileType type = 1;\n    required string key = 2;\n    optional string  fileName = 3;\n  }\n  message ").concat(PBName.GetDownloadUrlInput, " {\n    required FileType type = 1;      // \u4E0B\u8F7D\u7684\u6587\u4EF6\u7C7B\u578B\n    required string key = 2;           // \u8BF7\u6C42\u4E0B\u8F7D\u7684\u6587\u4EF6\u540D\n    optional string fileName = 3;     // \u4E0B\u8F7D\u751F\u6210\u7684\u6587\u4EF6\u540D\u5B57\n   }\n  message ").concat(PBName.GetQNupTokenOutput, " {\n    required int64 deadline = 1;\n    required string token = 2;\n    optional string bosToken = 3;\n    optional string bosDate = 4;\n    optional string path = 5;\n    optional string osskeyId = 6;\n    optional string ossPolicy = 7;\n    optional string ossSign = 8;\n    optional string ossBucketName = 9;\n    optional string s3Credential = 10;    // s3 \u8BA4\u8BC1\u51ED\u8BC1\uFF0C\u5BF9\u5E94 post\u4E0A\u4F20 x-amz-credential \u5B57\u6BB5\n    optional string s3Algorithm = 11;    // \u52A0\u5BC6\u7B97\u6CD5\uFF0C\u5BF9\u5E94 post\u4E0A\u4F20 x-amz-algorithm \u5B57\u6BB5  \n    optional string s3Date = 12;    // s3 \u65E5\u671F\uFF0C\u5BF9\u5E94 post\u4E0A\u4F20 x-amz-date \u5B57\u6BB5 \n    optional string s3Policy = 13;    // s3 policy\uFF0C\u5BF9\u5E94 post\u4E0A\u4F20 policy \u5B57\u6BB5 \n    optional string s3Signature = 14;    // s3 \u7B7E\u540D\u4FE1\u606F\uFF0C\u5BF9\u5E94 post\u4E0A\u4F20 x-amz-signature \u5B57\u6BB5\n    optional string s3BucketName = 15;    // s3 \u5B58\u50A8\u7A7A\u95F4\u540D\u79F0\n  }\n  message ").concat(PBName.GetQNdownloadUrlOutput, " {\n    required string downloadUrl = 1;\n  }\n  message ").concat(PBName.GetDownloadUrlOutput, " {\n    required string downloadUrl = 1;\n  }\n  message Add2BlackListInput {\n    required string userId = 1;\n  }\n  message RemoveFromBlackListInput {\n    required string userId = 1;\n  }\n  message QueryBlackListInput {\n    required int32 nothing = 1;\n  }\n  message QueryBlackListOutput {\n    repeated string userIds = 1;\n  }\n  message BlackListStatusInput {\n    required string userId = 1;\n  }\n  message BlockPushInput {\n    required string blockeeId = 1;\n  }\n  message ModifyPermissionInput {\n    required int32 openStatus = 1;\n  }\n  message GroupInput {\n    repeated GroupInfo groupInfo = 1;\n  }\n  message GroupOutput {\n    required int32 nothing = 1;\n  }\n  message GroupInfo {\n    required string id = 1;\n    required string name = 2;\n  }\n  message GroupHashInput {\n    required string userId = 1;\n    required string groupHashCode = 2;\n  }\n  message GroupHashOutput {\n    required GroupHashType result = 1;\n  }\n  enum GroupHashType {\n    group_success = 0x00;\n    group_failure = 0x01;\n  }\n  message ").concat(PBName.ChrmInput, " {\n    required int32 nothing = 1;\n  }\n  message ChrmOutput {\n    required int32 nothing = 1;\n  }\n  message ").concat(PBName.ChrmPullMsg, " {\n    required int64 syncTime = 1;\n    required int32 count = 2;\n  }\n  \n  message ChrmPullMsgNew \n  {\n    required int32 count = 1;\n    required int64 syncTime = 2;\n    optional string chrmId=3;\n  }\n  message ").concat(PBName.RelationQryInput, "\n  {\n    optional ChannelType type = 1;\n    optional int32 count = 2;\n    optional int64 startTime = 3;\n    optional int32 order = 4;\n  }\n  message ").concat(PBName.RelationsInput, "\n  {\n    required ChannelType type = 1;\n    optional DownStreamMessage msg =2;\n    optional int32 count = 3;\n    optional int32 offset = 4;\n    optional int64 startTime = 5;\n    optional int64 endTime = 6;\n  }\n  message ").concat(PBName.RelationsOutput, "\n  {\n    repeated RelationInfo info = 1;\n  }\n  message RelationInfo\n  {\n    required ChannelType type = 1;\n    required string userId = 2;\n    optional DownStreamMessage msg =3;\n    optional int64 readMsgTime= 4;\n    optional int64 unreadCount= 5;\n  }\n  message RelationInfoReadTime\n  {\n    required ChannelType type = 1;\n    required int64 readMsgTime= 2;\n    required string targetId = 3;\n  }\n  message ").concat(PBName.CleanHisMsgInput, "\n  {\n      required string targetId = 1;\n      required int64 dataTime = 2;\n      optional int32 conversationType= 3;\n  }\n  message HistoryMessageInput\n  {\n    required string targetId = 1;\n    required int64 dataTime =2;\n    required int32 size  = 3;\n  }\n\n  message HistoryMessagesOuput\n  {\n    repeated DownStreamMessage list = 1;\n    required int64 syncTime = 2;\n    required int32 hasMsg = 3;\n  }\n  message ").concat(PBName.QueryChatRoomInfoInput, "\n  {\n    required int32 count= 1;\n    optional int32 order= 2;\n  }\n\n  message ").concat(PBName.QueryChatRoomInfoOutput, "\n  {\n    optional int32 userTotalNums = 1;\n    repeated ChrmMember userInfos = 2;\n  }\n  message ChrmMember\n  {\n    required int64 time = 1;\n    required string id = 2;\n  }\n  message MPFollowInput\n  {\n    required string id = 1;\n  }\n\n  message MPFollowOutput\n  {\n    required int32 nothing = 1;\n    optional MpInfo info =2;\n  }\n\n  message ").concat(PBName.MCFollowInput, "\n  {\n    required string id = 1;\n  }\n\n  message MCFollowOutput\n  {\n    required int32 nothing = 1;\n    optional MpInfo info =2;\n  }\n\n  message MpInfo  \n  {\n    required string mpid=1;\n    required string name = 2;\n    required string type = 3;\n    required int64 time=4;\n    optional string portraitUrl=5;\n    optional string extra =6;\n  }\n\n  message SearchMpInput\n  {\n    required int32 type=1;\n    required string id=2;\n  }\n\n  message SearchMpOutput\n  {\n    required int32 nothing=1;\n    repeated MpInfo info = 2;\n  }\n\n  message PullMpInput\n  {\n    required int64 time=1;\n    required string mpid=2;\n  }\n\n  message PullMpOutput\n  {\n    required int32 status=1;\n    repeated MpInfo info = 2;\n  }\n  message ").concat(PBName.HistoryMsgInput, "\n  {\n    optional string targetId = 1;\n    optional int64 time = 2;\n    optional int32 count  = 3;\n    optional int32 order = 4;\n  }\n\n  message ").concat(PBName.HistoryMsgOuput, "\n  {\n    repeated DownStreamMessage list=1;\n    required int64 syncTime=2;\n    required int32 hasMsg=3;\n  }\n  message ").concat(PBName.RtcQueryListInput, "{\n    optional int32 order=1;\n  }\n\n  message ").concat(PBName.RtcKeyDeleteInput, "{\n    repeated string key=1;\n  }\n\n  message ").concat(PBName.RtcValueInfo, "{\n    required string key=1;\n    required string value=2;\n  }\n\n  message RtcUserInfo{\n    required string userId=1;\n    repeated ").concat(PBName.RtcValueInfo, " userData=2;\n  }\n\n  message ").concat(PBName.RtcUserListOutput, "{\n    repeated RtcUserInfo list=1;\n    optional string token=2;\n    optional string sessionId=3;\n  }\n  message RtcRoomInfoOutput{\n    optional string roomId = 1;\n    repeated ").concat(PBName.RtcValueInfo, " roomData = 2;\n    optional int32 userCount = 3;\n    repeated RtcUserInfo list=4;\n  }\n  message ").concat(PBName.RtcInput, "{\n    required int32 roomType=1;\n    optional int32 broadcastType=2;\n  }\n  message RtcQryInput{ \n    required bool isInterior=1;\n    required targetType target=2;\n    repeated string key=3;\n  }\n  message ").concat(PBName.RtcQryOutput, "{\n    repeated ").concat(PBName.RtcValueInfo, " outInfo=1;\n  }\n  message RtcDelDataInput{\n    repeated string key=1;\n    required bool isInterior=2;\n    required targetType target=3;\n  }\n  message ").concat(PBName.RtcDataInput, "{ \n    required bool interior=1;\n    required targetType target=2;\n    repeated string key=3;\n    optional string objectName=4;\n    optional string content=5;\n  }\n  message ").concat(PBName.RtcSetDataInput, "{\n    required bool interior=1;\n    required targetType target=2;\n    required string key=3;\n    required string value=4;\n    optional string objectName=5;\n    optional string content=6;\n  }\n  message ").concat(PBName.RtcUserSetDataInput, " {\n    repeated ").concat(PBName.RtcValueInfo, " valueInfo = 1;\n    required string objectName = 2;\n    repeated ").concat(PBName.RtcValueInfo, " content = 3;\n  }\n  message RtcOutput\n  {\n    optional int32 nothing=1; \n  }\n  message ").concat(PBName.RtcTokenOutput, "{\n    required string rtcToken=1;\n  }\n  enum targetType {\n    ROOM =1 ;\n    PERSON = 2;\n  }\n  message ").concat(PBName.RtcSetOutDataInput, "{\n    required targetType target=1;\n    repeated ").concat(PBName.RtcValueInfo, " valueInfo=2;\n    optional string objectName=3;\n    optional string content=4;\n  }\n  message ").concat(PBName.RtcQryUserOutDataInput, "{\n    repeated string userId = 1;\n  }\n  message ").concat(PBName.RtcUserOutDataOutput, "{\n    repeated RtcUserInfo user = 1;\n  }\n  message ").concat(PBName.SessionsAttQryInput, "{\n    required int32 nothing = 1;\n  }\n  message ").concat(PBName.SessionsAttOutput, "{\n    required int64 inboxTime = 1;\n    required int64 sendboxTime = 2;\n    required int64 totalUnreadCount = 3;\n  }\n  message ").concat(PBName.SessionMsgReadInput, "\n  {\n    required ChannelType type = 1;\n    required int64 msgTime = 2;\n    required string channelId = 3;\n  }\n  message SessionMsgReadOutput\n  {\n    optional int32 nothing=1; \n  }\n  message ").concat(PBName.DeleteSessionsInput, "\n  {\n    repeated SessionInfo sessions = 1;\n  }\n  message ").concat(PBName.SessionInfo, "\n  {\n    required ChannelType type = 1;\n    required string channelId = 2;\n  }\n  message ").concat(PBName.DeleteSessionsOutput, "\n  {\n    optional int32 nothing=1; \n  }\n  message ").concat(PBName.DeleteMsgInput, "\n  {\n    optional ChannelType type = 1;\n    optional string conversationId = 2;\n    repeated DeleteMsg msgs = 3;\n  }\n  message DeleteMsg\n  {\n    optional string msgId = 1;\n    optional int64 msgDataTime = 2;\n    optional int32 direct = 3;\n  }\n  message ChrmKVEntity {\n    required string key = 1;\n    required string value = 2;\n    optional int32 status = 3;\n    optional int64 timestamp = 4;\n    optional string uid = 5;\n  }\n  message ").concat(PBName.SetChrmKV, " {\n    required ChrmKVEntity entry = 1;\n    optional bool bNotify = 2;\n    optional UpStreamMessage notification = 3;\n    optional ChannelType type = 4;\n  }\n  message ").concat(PBName.ChrmKVOutput, " {\n    repeated ChrmKVEntity entries = 1;\n    optional bool bFullUpdate = 2;\n    optional int64 syncTime = 3;\n  }\n  message ").concat(PBName.QueryChrmKV, " {\n    required int64 timestamp = 1;\n  }\n  message ").concat(PBName.SetUserSettingInput, " {\n    required int64 version=1;\n    required string value=2;\n  }\n  message ").concat(PBName.SetUserSettingOutput, " {\n    required int64 version=1;\n    required bool reserve=2;\n  }\n  message ").concat(PBName.PullUserSettingInput, " {\n    required int64 version=1;//\u5F53\u524D\u5BA2\u6237\u7AEF\u7684\u6700\u5927\u7248\u672C\u53F7\n    optional bool reserve=2;\n  }\n  message ").concat(PBName.PullUserSettingOutput, " {\n    repeated UserSettingItem items = 1;\n    required int64 version=2;\n  }\n  message UserSettingItem {\n    required string targetId= 1;\n    required ChannelType type = 2;\n    required string key = 4;\n    required bytes value = 5;\n    required int64 version=6;\n    required int32 status=7;\n    repeated SessionTagItem tags= 8;// key \u4E3A SeTags \u65F6\uFF0C\u8FD9\u4E2A\u5B57\u6BB5\u6709\u503C\n  }\n  message ").concat(PBName.SessionReq, " {\n    required int64 time = 1;\n  }\n  message ").concat(PBName.SessionStates, " {\n    required int64 version=1;\n    repeated SessionState state= 2;\n  }\n  message ").concat(PBName.SessionState, " {\n    required ChannelType type = 1;\n    required string channelId = 2;  \n    optional int64 time = 3;\n    repeated SessionStateItem stateItem = 4;\n  }\n  message ").concat(PBName.SessionStateItem, " {\n    required SessionStateType sessionStateType = 1;\n    required string value = 2;\n    repeated SessionTagItem tags = 3;\n  }\n  enum SessionStateType {\n    IsSilent = 1;\n    IsTop = 2;\n    Tags = 3;//\u6807\u7B7E\u5217\u8868\n  }\n  message ").concat(PBName.SessionStateModifyReq, " {\n    required int64 version=1;\n    repeated SessionState state= 2;\n  }\n  message ").concat(PBName.SessionStateModifyResp, " {\n    required int64 version=1;\n  }\n  message ").concat(PBName.SessionTagAddInput, " {\n    required int64 version=1;//\u5BA2\u6237\u7AEF\u5F53\u524D\u7684\u6700\u5927\u7248\u672C\u53F7\n    repeated SessionTagItem tags=2;\n  }\n  message ").concat(PBName.SessionTagItem, " {\n    required string tagId=1;\n    optional string name=2;\n    optional int64 createdTime=3;\n    optional bool isTop=4;\n  }\n  message ").concat(PBName.SessionTagDelInput, " {\n    required int64 version=1;//\u5F53\u524D\u7684\u6700\u5927\u7248\u672C\u53F7\n    repeated SessionTagItem tags=2;\n  }\n  message ").concat(PBName.SessionDisTagReq, " {\n    repeated string tagId=1;\n  }\n  message ").concat(PBName.UserSettingNotification, " {\n    required int64 version=1;//\u5F53\u524D\u5BA2\u6237\u7AEF\u7684\u6700\u5927\u7248\u672C\u53F7\n    required bool reserve=2;\n  }\n}\n");

  var quot = /"/g;

  // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
  // https://tc39.es/ecma262/#sec-createhtml
  var createHtml = function (string, tag, attribute, value) {
    var S = String(requireObjectCoercible(string));
    var p1 = '<' + tag;
    if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
    return p1 + '>' + S + '</' + tag + '>';
  };

  // check the existence of a method, lowercase
  // of a tag and escaping quotes in arguments
  var stringHtmlForced = function (METHOD_NAME) {
    return fails(function () {
      var test = ''[METHOD_NAME]('"');
      return test !== test.toLowerCase() || test.split('"').length > 3;
    });
  };

  // `String.prototype.sub` method
  // https://tc39.es/ecma262/#sec-string.prototype.sub
  _export({ target: 'String', proto: true, forced: stringHtmlForced('sub') }, {
    sub: function sub() {
      return createHtml(this, 'sub', '', '');
    }
  });

  var ARRAY_BUFFER$1 = 'ArrayBuffer';
  var ArrayBuffer$3 = arrayBuffer[ARRAY_BUFFER$1];
  var NativeArrayBuffer$1 = global$1[ARRAY_BUFFER$1];

  // `ArrayBuffer` constructor
  // https://tc39.es/ecma262/#sec-arraybuffer-constructor
  _export({ global: true, forced: NativeArrayBuffer$1 !== ArrayBuffer$3 }, {
    ArrayBuffer: ArrayBuffer$3
  });

  setSpecies(ARRAY_BUFFER$1);

  // `Array.prototype.fill` method
  // https://tc39.es/ecma262/#sec-array.prototype.fill
  _export({ target: 'Array', proto: true }, {
    fill: arrayFill
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('fill');

  function protobuf (a) {

    var c = function () {
      function a(a, b, c) {
        this.low = 0 | a, this.high = 0 | b, this.unsigned = !!c;
      }

      function b(a) {
        return (a && a.__isLong__) === !0;
      }

      function e(a, b) {
        var e, f, h;
        return b ? (a >>>= 0, (h = a >= 0 && a < 256) && (f = d[a]) ? f : (e = g(a, (0 | a) < 0 ? -1 : 0, !0), h && (d[a] = e), e)) : (a |= 0, (h = a >= -128 && a < 128) && (f = c[a]) ? f : (e = g(a, a < 0 ? -1 : 0, !1), h && (c[a] = e), e));
      }

      function f(a, b) {
        if (isNaN(a) || !isFinite(a)) return b ? r : q;

        if (b) {
          if (a < 0) return r;
          if (a >= n) return w;
        } else {
          if (-o >= a) return x;
          if (a + 1 >= o) return v;
        }

        return a < 0 ? f(-a, b).neg() : g(0 | a % m, 0 | a / m, b);
      }

      function g(b, c, d) {
        return new a(b, c, d);
      }

      function i(a, b, c) {
        var d, e, g, j, k, l, m;
        if (a.length === 0) throw Error('empty string');
        if (a === 'NaN' || a === 'Infinity' || a === '+Infinity' || a === '-Infinity') return q;
        if (typeof b === 'number' ? (c = b, b = !1) : b = !!b, c = c || 10, c < 2 || c > 36) throw RangeError('radix');
        if ((d = a.indexOf('-')) > 0) throw Error('interior hyphen');
        if (d === 0) return i(a.substring(1), b, c).neg();

        for (e = f(h(c, 8)), g = q, j = 0; j < a.length; j += 8) {
          k = Math.min(8, a.length - j), l = parseInt(a.substring(j, j + k), c), k < 8 ? (m = f(h(c, k)), g = g.mul(m).add(f(l))) : (g = g.mul(e), g = g.add(f(l)));
        }

        return g.unsigned = b, g;
      }

      function j(b) {
        return b instanceof a ? b : typeof b === 'number' ? f(b) : typeof b === 'string' ? i(b) : g(b.low, b.high, b.unsigned);
      }

      var c, d, h, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y;
      return a.prototype.__isLong__, Object.defineProperty(a.prototype, '__isLong__', {
        value: !0,
        enumerable: !1,
        configurable: !1
      }), a.isLong = b, c = {}, d = {}, a.fromInt = e, a.fromNumber = f, a.fromBits = g, h = Math.pow, a.fromString = i, a.fromValue = j, k = 65536, l = 1 << 24, m = k * k, n = m * m, o = n / 2, p = e(l), q = e(0), a.ZERO = q, r = e(0, !0), a.UZERO = r, s = e(1), a.ONE = s, t = e(1, !0), a.UONE = t, u = e(-1), a.NEG_ONE = u, v = g(-1, 2147483647, !1), a.MAX_VALUE = v, w = g(-1, -1, !0), a.MAX_UNSIGNED_VALUE = w, x = g(0, -2147483648, !1), a.MIN_VALUE = x, y = a.prototype, y.toInt = function () {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, y.toNumber = function () {
        return this.unsigned ? (this.high >>> 0) * m + (this.low >>> 0) : this.high * m + (this.low >>> 0);
      }, y.toString = function (a) {
        var b, c, d, e, g, i, j, k, l;
        if (a = a || 10, a < 2 || a > 36) throw RangeError('radix');
        if (this.isZero()) return '0';
        if (this.isNegative()) return this.eq(x) ? (b = f(a), c = this.div(b), d = c.mul(b).sub(this), c.toString(a) + d.toInt().toString(a)) : '-' + this.neg().toString(a);

        for (e = f(h(a, 6), this.unsigned), g = this, i = '';;) {
          if (j = g.div(e), k = g.sub(j.mul(e)).toInt() >>> 0, l = k.toString(a), g = j, g.isZero()) return l + i;

          for (; l.length < 6;) {
            l = '0' + l;
          }

          i = '' + l + i;
        }
      }, y.getHighBits = function () {
        return this.high;
      }, y.getHighBitsUnsigned = function () {
        return this.high >>> 0;
      }, y.getLowBits = function () {
        return this.low;
      }, y.getLowBitsUnsigned = function () {
        return this.low >>> 0;
      }, y.getNumBitsAbs = function () {
        var a, b;
        if (this.isNegative()) return this.eq(x) ? 64 : this.neg().getNumBitsAbs();

        for (a = this.high != 0 ? this.high : this.low, b = 31; b > 0 && (a & 1 << b) == 0; b--) {
        }

        return this.high != 0 ? b + 33 : b + 1;
      }, y.isZero = function () {
        return this.high === 0 && this.low === 0;
      }, y.isNegative = function () {
        return !this.unsigned && this.high < 0;
      }, y.isPositive = function () {
        return this.unsigned || this.high >= 0;
      }, y.isOdd = function () {
        return (1 & this.low) === 1;
      }, y.isEven = function () {
        return (1 & this.low) === 0;
      }, y.equals = function (a) {
        return b(a) || (a = j(a)), this.unsigned !== a.unsigned && this.high >>> 31 === 1 && a.high >>> 31 === 1 ? !1 : this.high === a.high && this.low === a.low;
      }, y.eq = y.equals, y.notEquals = function (a) {
        return !this.eq(a);
      }, y.neq = y.notEquals, y.lessThan = function (a) {
        return this.comp(a) < 0;
      }, y.lt = y.lessThan, y.lessThanOrEqual = function (a) {
        return this.comp(a) <= 0;
      }, y.lte = y.lessThanOrEqual, y.greaterThan = function (a) {
        return this.comp(a) > 0;
      }, y.gt = y.greaterThan, y.greaterThanOrEqual = function (a) {
        return this.comp(a) >= 0;
      }, y.gte = y.greaterThanOrEqual, y.compare = function (a) {
        if (b(a) || (a = j(a)), this.eq(a)) return 0;
        var c = this.isNegative();
        var d = a.isNegative();
        return c && !d ? -1 : !c && d ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(a).isNegative() ? -1 : 1;
      }, y.comp = y.compare, y.negate = function () {
        return !this.unsigned && this.eq(x) ? x : this.not().add(s);
      }, y.neg = y.negate, y.add = function (a) {
        var c, d, e, f, h, i, k, l, m, n, o, p;
        return b(a) || (a = j(a)), c = this.high >>> 16, d = 65535 & this.high, e = this.low >>> 16, f = 65535 & this.low, h = a.high >>> 16, i = 65535 & a.high, k = a.low >>> 16, l = 65535 & a.low, m = 0, n = 0, o = 0, p = 0, p += f + l, o += p >>> 16, p &= 65535, o += e + k, n += o >>> 16, o &= 65535, n += d + i, m += n >>> 16, n &= 65535, m += c + h, m &= 65535, g(o << 16 | p, m << 16 | n, this.unsigned);
      }, y.subtract = function (a) {
        return b(a) || (a = j(a)), this.add(a.neg());
      }, y.sub = y.subtract, y.multiply = function (a) {
        var c, d, e, h, i, k, l, m, n, o, r, s;
        return this.isZero() ? q : (b(a) || (a = j(a)), a.isZero() ? q : this.eq(x) ? a.isOdd() ? x : q : a.eq(x) ? this.isOdd() ? x : q : this.isNegative() ? a.isNegative() ? this.neg().mul(a.neg()) : this.neg().mul(a).neg() : a.isNegative() ? this.mul(a.neg()).neg() : this.lt(p) && a.lt(p) ? f(this.toNumber() * a.toNumber(), this.unsigned) : (c = this.high >>> 16, d = 65535 & this.high, e = this.low >>> 16, h = 65535 & this.low, i = a.high >>> 16, k = 65535 & a.high, l = a.low >>> 16, m = 65535 & a.low, n = 0, o = 0, r = 0, s = 0, s += h * m, r += s >>> 16, s &= 65535, r += e * m, o += r >>> 16, r &= 65535, r += h * l, o += r >>> 16, r &= 65535, o += d * m, n += o >>> 16, o &= 65535, o += e * l, n += o >>> 16, o &= 65535, o += h * k, n += o >>> 16, o &= 65535, n += c * m + d * l + e * k + h * i, n &= 65535, g(r << 16 | s, n << 16 | o, this.unsigned)));
      }, y.mul = y.multiply, y.divide = function (a) {
        var c, d, e, g, i, k, l, m;
        if (b(a) || (a = j(a)), a.isZero()) throw Error('division by zero');
        if (this.isZero()) return this.unsigned ? r : q;

        if (this.unsigned) {
          if (a.unsigned || (a = a.toUnsigned()), a.gt(this)) return r;
          if (a.gt(this.shru(1))) return t;
          e = r;
        } else {
          if (this.eq(x)) return a.eq(s) || a.eq(u) ? x : a.eq(x) ? s : (g = this.shr(1), c = g.div(a).shl(1), c.eq(q) ? a.isNegative() ? s : u : (d = this.sub(a.mul(c)), e = c.add(d.div(a))));
          if (a.eq(x)) return this.unsigned ? r : q;
          if (this.isNegative()) return a.isNegative() ? this.neg().div(a.neg()) : this.neg().div(a).neg();
          if (a.isNegative()) return this.div(a.neg()).neg();
          e = q;
        }

        for (d = this; d.gte(a);) {
          for (c = Math.max(1, Math.floor(d.toNumber() / a.toNumber())), i = Math.ceil(Math.log(c) / Math.LN2), k = i <= 48 ? 1 : h(2, i - 48), l = f(c), m = l.mul(a); m.isNegative() || m.gt(d);) {
            c -= k, l = f(c, this.unsigned), m = l.mul(a);
          }

          l.isZero() && (l = s), e = e.add(l), d = d.sub(m);
        }

        return e;
      }, y.div = y.divide, y.modulo = function (a) {
        return b(a) || (a = j(a)), this.sub(this.div(a).mul(a));
      }, y.mod = y.modulo, y.not = function () {
        return g(~this.low, ~this.high, this.unsigned);
      }, y.and = function (a) {
        return b(a) || (a = j(a)), g(this.low & a.low, this.high & a.high, this.unsigned);
      }, y.or = function (a) {
        return b(a) || (a = j(a)), g(this.low | a.low, this.high | a.high, this.unsigned);
      }, y.xor = function (a) {
        return b(a) || (a = j(a)), g(this.low ^ a.low, this.high ^ a.high, this.unsigned);
      }, y.shiftLeft = function (a) {
        return b(a) && (a = a.toInt()), (a &= 63) === 0 ? this : a < 32 ? g(this.low << a, this.high << a | this.low >>> 32 - a, this.unsigned) : g(0, this.low << a - 32, this.unsigned);
      }, y.shl = y.shiftLeft, y.shiftRight = function (a) {
        return b(a) && (a = a.toInt()), (a &= 63) === 0 ? this : a < 32 ? g(this.low >>> a | this.high << 32 - a, this.high >> a, this.unsigned) : g(this.high >> a - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }, y.shr = y.shiftRight, y.shiftRightUnsigned = function (a) {
        var c, d;
        return b(a) && (a = a.toInt()), a &= 63, a === 0 ? this : (c = this.high, a < 32 ? (d = this.low, g(d >>> a | c << 32 - a, c >>> a, this.unsigned)) : a === 32 ? g(c, 0, this.unsigned) : g(c >>> a - 32, 0, this.unsigned));
      }, y.shru = y.shiftRightUnsigned, y.toSigned = function () {
        return this.unsigned ? g(this.low, this.high, !1) : this;
      }, y.toUnsigned = function () {
        return this.unsigned ? this : g(this.low, this.high, !0);
      }, y.toBytes = function (a) {
        return a ? this.toBytesLE() : this.toBytesBE();
      }, y.toBytesLE = function () {
        var a = this.high;
        var b = this.low;
        return [255 & b, 255 & b >>> 8, 255 & b >>> 16, 255 & b >>> 24, 255 & a, 255 & a >>> 8, 255 & a >>> 16, 255 & a >>> 24];
      }, y.toBytesBE = function () {
        var a = this.high;
        var b = this.low;
        return [255 & a >>> 24, 255 & a >>> 16, 255 & a >>> 8, 255 & a, 255 & b >>> 24, 255 & b >>> 16, 255 & b >>> 8, 255 & b];
      }, a;
    }();

    var d = function (a) {
      function f(a) {
        var b = 0;
        return function () {
          return b < a.length ? a.charCodeAt(b++) : null;
        };
      }

      function g() {
        var a = [];
        var b = [];
        return function () {
          return arguments.length === 0 ? b.join('') + e.apply(String, a) : (a.length + arguments.length > 1024 && (b.push(e.apply(String, a)), a.length = 0), Array.prototype.push.apply(a, arguments), void 0);
        };
      }

      function h(a, b, c, d, e) {
        var f;
        var g;
        var h = 8 * e - d - 1;
        var i = (1 << h) - 1;
        var j = i >> 1;
        var k = -7;
        var l = c ? e - 1 : 0;
        var m = c ? -1 : 1;
        var n = a[b + l];

        for (l += m, f = n & (1 << -k) - 1, n >>= -k, k += h; k > 0; f = 256 * f + a[b + l], l += m, k -= 8) {
        }

        for (g = f & (1 << -k) - 1, f >>= -k, k += d; k > 0; g = 256 * g + a[b + l], l += m, k -= 8) {
        }

        if (f === 0) f = 1 - j;else {
          if (f === i) return g ? 0 / 0 : 1 / 0 * (n ? -1 : 1);
          g += Math.pow(2, d), f -= j;
        }
        return (n ? -1 : 1) * g * Math.pow(2, f - d);
      }

      function i(a, b, c, d, e, f) {
        var g;
        var h;
        var i;
        var j = 8 * f - e - 1;
        var k = (1 << j) - 1;
        var l = k >> 1;
        var m = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var n = d ? 0 : f - 1;
        var o = d ? 1 : -1;
        var p = b < 0 || b === 0 && 1 / b < 0 ? 1 : 0;

        for (b = Math.abs(b), isNaN(b) || 1 / 0 === b ? (h = isNaN(b) ? 1 : 0, g = k) : (g = Math.floor(Math.log(b) / Math.LN2), b * (i = Math.pow(2, -g)) < 1 && (g--, i *= 2), b += g + l >= 1 ? m / i : m * Math.pow(2, 1 - l), b * i >= 2 && (g++, i /= 2), g + l >= k ? (h = 0, g = k) : g + l >= 1 ? (h = (b * i - 1) * Math.pow(2, e), g += l) : (h = b * Math.pow(2, l - 1) * Math.pow(2, e), g = 0)); e >= 8; a[c + n] = 255 & h, n += o, h /= 256, e -= 8) {
        }

        for (g = g << e | h, j += e; j > 0; a[c + n] = 255 & g, n += o, g /= 256, j -= 8) {
        }

        a[c + n - o] |= 128 * p;
      }

      var c;
      var d;
      var e;
      var j;
      var k;

      var b = function b(a, c, e) {
        if (typeof a === 'undefined' && (a = b.DEFAULT_CAPACITY), typeof c === 'undefined' && (c = b.DEFAULT_ENDIAN), typeof e === 'undefined' && (e = b.DEFAULT_NOASSERT), !e) {
          if (a = 0 | a, a < 0) throw RangeError('Illegal capacity');
          c = !!c, e = !!e;
        }

        this.buffer = a === 0 ? d : new ArrayBuffer(a), this.view = a === 0 ? null : new Uint8Array(this.buffer), this.offset = 0, this.markedOffset = -1, this.limit = a, this.littleEndian = c, this.noAssert = e;
      };

      return b.VERSION = '5.0.1', b.LITTLE_ENDIAN = !0, b.BIG_ENDIAN = !1, b.DEFAULT_CAPACITY = 16, b.DEFAULT_ENDIAN = b.BIG_ENDIAN, b.DEFAULT_NOASSERT = !1, b.Long = a || null, c = b.prototype, c.__isByteBuffer__, Object.defineProperty(c, '__isByteBuffer__', {
        value: !0,
        enumerable: !1,
        configurable: !1
      }), d = new ArrayBuffer(0), e = String.fromCharCode, b.accessor = function () {
        return Uint8Array;
      }, b.allocate = function (a, c, d) {
        return new b(a, c, d);
      }, b.concat = function (a, c, d, e) {
        var f, i, g, h, k, j;

        for ((typeof c === 'boolean' || typeof c !== 'string') && (e = d, d = c, c = void 0), f = 0, g = 0, h = a.length; h > g; ++g) {
          b.isByteBuffer(a[g]) || (a[g] = b.wrap(a[g], c)), i = a[g].limit - a[g].offset, i > 0 && (f += i);
        }

        if (f === 0) return new b(0, d, e);

        for (j = new b(f, d, e), g = 0; h > g;) {
          k = a[g++], i = k.limit - k.offset, i <= 0 || (j.view.set(k.view.subarray(k.offset, k.limit), j.offset), j.offset += i);
        }

        return j.limit = j.offset, j.offset = 0, j;
      }, b.isByteBuffer = function (a) {
        return (a && a.__isByteBuffer__) === !0;
      }, b.type = function () {
        return ArrayBuffer;
      }, b.wrap = function (a, d, e, f) {
        var g, h;
        if (typeof d !== 'string' && (f = e, e = d, d = void 0), typeof a === 'string') switch (typeof d === 'undefined' && (d = 'utf8'), d) {
          case 'base64':
            return b.fromBase64(a, e);

          case 'hex':
            return b.fromHex(a, e);

          case 'binary':
            return b.fromBinary(a, e);

          case 'utf8':
            return b.fromUTF8(a, e);

          case 'debug':
            return b.fromDebug(a, e);

          default:
            throw Error('Unsupported encoding: ' + d);
        }
        if (a === null || _typeof(a) !== 'object') throw TypeError('Illegal buffer');
        if (b.isByteBuffer(a)) return g = c.clone.call(a), g.markedOffset = -1, g;
        if (a instanceof Uint8Array) g = new b(0, e, f), a.length > 0 && (g.buffer = a.buffer, g.offset = a.byteOffset, g.limit = a.byteOffset + a.byteLength, g.view = new Uint8Array(a.buffer));else if (a instanceof ArrayBuffer) g = new b(0, e, f), a.byteLength > 0 && (g.buffer = a, g.offset = 0, g.limit = a.byteLength, g.view = a.byteLength > 0 ? new Uint8Array(a) : null);else {
          if (Object.prototype.toString.call(a) !== '[object Array]') throw TypeError('Illegal buffer');

          for (g = new b(a.length, e, f), g.limit = a.length, h = 0; h < a.length; ++h) {
            g.view[h] = a[h];
          }
        }
        return g;
      }, c.writeBitSet = function (a, b) {
        var h;
        var d;
        var e;
        var f;
        var g;
        var i;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (!(a instanceof Array)) throw TypeError('Illegal BitSet: Not an array');
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        for (d = b, e = a.length, f = e >> 3, g = 0, b += this.writeVarint32(e, b); f--;) {
          h = 1 & !!a[g++] | (1 & !!a[g++]) << 1 | (1 & !!a[g++]) << 2 | (1 & !!a[g++]) << 3 | (1 & !!a[g++]) << 4 | (1 & !!a[g++]) << 5 | (1 & !!a[g++]) << 6 | (1 & !!a[g++]) << 7, this.writeByte(h, b++);
        }

        if (e > g) {
          for (i = 0, h = 0; e > g;) {
            h |= (1 & !!a[g++]) << i++;
          }

          this.writeByte(h, b++);
        }

        return c ? (this.offset = b, this) : b - d;
      }, c.readBitSet = function (a) {
        var h;
        var c;
        var d;
        var e;
        var f;
        var g;
        var i;
        var b = typeof a === 'undefined';

        for (b && (a = this.offset), c = this.readVarint32(a), d = c.value, e = d >> 3, f = 0, g = [], a += c.length; e--;) {
          h = this.readByte(a++), g[f++] = !!(1 & h), g[f++] = !!(2 & h), g[f++] = !!(4 & h), g[f++] = !!(8 & h), g[f++] = !!(16 & h), g[f++] = !!(32 & h), g[f++] = !!(64 & h), g[f++] = !!(128 & h);
        }

        if (d > f) for (i = 0, h = this.readByte(a++); d > f;) {
          g[f++] = !!(1 & h >> i++);
        }
        return b && (this.offset = a), g;
      }, c.readBytes = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + a > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + a + ') <= ' + this.buffer.byteLength);
        }

        return d = this.slice(b, b + a), c && (this.offset += a), d;
      }, c.writeBytes = c.append, c.writeInt8 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a |= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 1, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 1, this.view[b] = a, c && (this.offset += 1), this;
      }, c.writeByte = c.writeInt8, c.readInt8 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 1 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 1 + ') <= ' + this.buffer.byteLength);
        }

        return c = this.view[a], (128 & c) === 128 && (c = -(255 - c + 1)), b && (this.offset += 1), c;
      }, c.readByte = c.readInt8, c.writeUint8 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 1, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 1, this.view[b] = a, c && (this.offset += 1), this;
      }, c.writeUInt8 = c.writeUint8, c.readUint8 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 1 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 1 + ') <= ' + this.buffer.byteLength);
        }

        return c = this.view[a], b && (this.offset += 1), c;
      }, c.readUInt8 = c.readUint8, c.writeInt16 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a |= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 2, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 2, this.littleEndian ? (this.view[b + 1] = (65280 & a) >>> 8, this.view[b] = 255 & a) : (this.view[b] = (65280 & a) >>> 8, this.view[b + 1] = 255 & a), c && (this.offset += 2), this;
      }, c.writeShort = c.writeInt16, c.readInt16 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 2 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 2 + ') <= ' + this.buffer.byteLength);
        }

        return c = 0, this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]), (32768 & c) === 32768 && (c = -(65535 - c + 1)), b && (this.offset += 2), c;
      }, c.readShort = c.readInt16, c.writeUint16 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 2, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 2, this.littleEndian ? (this.view[b + 1] = (65280 & a) >>> 8, this.view[b] = 255 & a) : (this.view[b] = (65280 & a) >>> 8, this.view[b + 1] = 255 & a), c && (this.offset += 2), this;
      }, c.writeUInt16 = c.writeUint16, c.readUint16 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 2 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 2 + ') <= ' + this.buffer.byteLength);
        }

        return c = 0, this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]), b && (this.offset += 2), c;
      }, c.readUInt16 = c.readUint16, c.writeInt32 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a |= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 4, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 4, this.littleEndian ? (this.view[b + 3] = 255 & a >>> 24, this.view[b + 2] = 255 & a >>> 16, this.view[b + 1] = 255 & a >>> 8, this.view[b] = 255 & a) : (this.view[b] = 255 & a >>> 24, this.view[b + 1] = 255 & a >>> 16, this.view[b + 2] = 255 & a >>> 8, this.view[b + 3] = 255 & a), c && (this.offset += 4), this;
      }, c.writeInt = c.writeInt32, c.readInt32 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 4 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 4 + ') <= ' + this.buffer.byteLength);
        }

        return c = 0, this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0), c |= 0, b && (this.offset += 4), c;
      }, c.readInt = c.readInt32, c.writeUint32 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 4, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 4, this.littleEndian ? (this.view[b + 3] = 255 & a >>> 24, this.view[b + 2] = 255 & a >>> 16, this.view[b + 1] = 255 & a >>> 8, this.view[b] = 255 & a) : (this.view[b] = 255 & a >>> 24, this.view[b + 1] = 255 & a >>> 16, this.view[b + 2] = 255 & a >>> 8, this.view[b + 3] = 255 & a), c && (this.offset += 4), this;
      }, c.writeUInt32 = c.writeUint32, c.readUint32 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 4 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 4 + ') <= ' + this.buffer.byteLength);
        }

        return c = 0, this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0), b && (this.offset += 4), c;
      }, c.readUInt32 = c.readUint32, a && (c.writeInt64 = function (b, c) {
        var e;
        var f;
        var g;
        var d = typeof c === 'undefined';

        if (d && (c = this.offset), !this.noAssert) {
          if (typeof b === 'number') b = a.fromNumber(b);else if (typeof b === 'string') b = a.fromString(b);else if (!(b && b instanceof a)) throw TypeError('Illegal value: ' + b + ' (not an integer or Long)');
          if (typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal offset: ' + c + ' (not an integer)');
          if (c >>>= 0, c < 0 || c + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + c + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return typeof b === 'number' ? b = a.fromNumber(b) : typeof b === 'string' && (b = a.fromString(b)), c += 8, e = this.buffer.byteLength, c > e && this.resize((e *= 2) > c ? e : c), c -= 8, f = b.low, g = b.high, this.littleEndian ? (this.view[c + 3] = 255 & f >>> 24, this.view[c + 2] = 255 & f >>> 16, this.view[c + 1] = 255 & f >>> 8, this.view[c] = 255 & f, c += 4, this.view[c + 3] = 255 & g >>> 24, this.view[c + 2] = 255 & g >>> 16, this.view[c + 1] = 255 & g >>> 8, this.view[c] = 255 & g) : (this.view[c] = 255 & g >>> 24, this.view[c + 1] = 255 & g >>> 16, this.view[c + 2] = 255 & g >>> 8, this.view[c + 3] = 255 & g, c += 4, this.view[c] = 255 & f >>> 24, this.view[c + 1] = 255 & f >>> 16, this.view[c + 2] = 255 & f >>> 8, this.view[c + 3] = 255 & f), d && (this.offset += 8), this;
      }, c.writeLong = c.writeInt64, c.readInt64 = function (b) {
        var d;
        var e;
        var f;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 8 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 8 + ') <= ' + this.buffer.byteLength);
        }

        return d = 0, e = 0, this.littleEndian ? (d = this.view[b + 2] << 16, d |= this.view[b + 1] << 8, d |= this.view[b], d += this.view[b + 3] << 24 >>> 0, b += 4, e = this.view[b + 2] << 16, e |= this.view[b + 1] << 8, e |= this.view[b], e += this.view[b + 3] << 24 >>> 0) : (e = this.view[b + 1] << 16, e |= this.view[b + 2] << 8, e |= this.view[b + 3], e += this.view[b] << 24 >>> 0, b += 4, d = this.view[b + 1] << 16, d |= this.view[b + 2] << 8, d |= this.view[b + 3], d += this.view[b] << 24 >>> 0), f = new a(d, e, !1), c && (this.offset += 8), f;
      }, c.readLong = c.readInt64, c.writeUint64 = function (b, c) {
        var e;
        var f;
        var g;
        var d = typeof c === 'undefined';

        if (d && (c = this.offset), !this.noAssert) {
          if (typeof b === 'number') b = a.fromNumber(b);else if (typeof b === 'string') b = a.fromString(b);else if (!(b && b instanceof a)) throw TypeError('Illegal value: ' + b + ' (not an integer or Long)');
          if (typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal offset: ' + c + ' (not an integer)');
          if (c >>>= 0, c < 0 || c + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + c + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return typeof b === 'number' ? b = a.fromNumber(b) : typeof b === 'string' && (b = a.fromString(b)), c += 8, e = this.buffer.byteLength, c > e && this.resize((e *= 2) > c ? e : c), c -= 8, f = b.low, g = b.high, this.littleEndian ? (this.view[c + 3] = 255 & f >>> 24, this.view[c + 2] = 255 & f >>> 16, this.view[c + 1] = 255 & f >>> 8, this.view[c] = 255 & f, c += 4, this.view[c + 3] = 255 & g >>> 24, this.view[c + 2] = 255 & g >>> 16, this.view[c + 1] = 255 & g >>> 8, this.view[c] = 255 & g) : (this.view[c] = 255 & g >>> 24, this.view[c + 1] = 255 & g >>> 16, this.view[c + 2] = 255 & g >>> 8, this.view[c + 3] = 255 & g, c += 4, this.view[c] = 255 & f >>> 24, this.view[c + 1] = 255 & f >>> 16, this.view[c + 2] = 255 & f >>> 8, this.view[c + 3] = 255 & f), d && (this.offset += 8), this;
      }, c.writeUInt64 = c.writeUint64, c.readUint64 = function (b) {
        var d;
        var e;
        var f;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 8 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 8 + ') <= ' + this.buffer.byteLength);
        }

        return d = 0, e = 0, this.littleEndian ? (d = this.view[b + 2] << 16, d |= this.view[b + 1] << 8, d |= this.view[b], d += this.view[b + 3] << 24 >>> 0, b += 4, e = this.view[b + 2] << 16, e |= this.view[b + 1] << 8, e |= this.view[b], e += this.view[b + 3] << 24 >>> 0) : (e = this.view[b + 1] << 16, e |= this.view[b + 2] << 8, e |= this.view[b + 3], e += this.view[b] << 24 >>> 0, b += 4, d = this.view[b + 1] << 16, d |= this.view[b + 2] << 8, d |= this.view[b + 3], d += this.view[b] << 24 >>> 0), f = new a(d, e, !0), c && (this.offset += 8), f;
      }, c.readUInt64 = c.readUint64), c.writeFloat32 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number') throw TypeError('Illegal value: ' + a + ' (not a number)');
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 4, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 4, i(this.view, a, b, this.littleEndian, 23, 4), c && (this.offset += 4), this;
      }, c.writeFloat = c.writeFloat32, c.readFloat32 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 4 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 4 + ') <= ' + this.buffer.byteLength);
        }

        return c = h(this.view, a, this.littleEndian, 23, 4), b && (this.offset += 4), c;
      }, c.readFloat = c.readFloat32, c.writeFloat64 = function (a, b) {
        var d;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'number') throw TypeError('Illegal value: ' + a + ' (not a number)');
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return b += 8, d = this.buffer.byteLength, b > d && this.resize((d *= 2) > b ? d : b), b -= 8, i(this.view, a, b, this.littleEndian, 52, 8), c && (this.offset += 8), this;
      }, c.writeDouble = c.writeFloat64, c.readFloat64 = function (a) {
        var c;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 8 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 8 + ') <= ' + this.buffer.byteLength);
        }

        return c = h(this.view, a, this.littleEndian, 52, 8), b && (this.offset += 8), c;
      }, c.readDouble = c.readFloat64, b.MAX_VARINT32_BYTES = 5, b.calculateVarint32 = function (a) {
        return a >>>= 0, a < 128 ? 1 : a < 16384 ? 2 : 1 << 21 > a ? 3 : 1 << 28 > a ? 4 : 5;
      }, b.zigZagEncode32 = function (a) {
        return ((a |= 0) << 1 ^ a >> 31) >>> 0;
      }, b.zigZagDecode32 = function (a) {
        return 0 | a >>> 1 ^ -(1 & a);
      }, c.writeVarint32 = function (a, c) {
        var f;
        var e;
        var g;
        var d = typeof c === 'undefined';

        if (d && (c = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a |= 0, typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal offset: ' + c + ' (not an integer)');
          if (c >>>= 0, c < 0 || c + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + c + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        for (e = b.calculateVarint32(a), c += e, g = this.buffer.byteLength, c > g && this.resize((g *= 2) > c ? g : c), c -= e, a >>>= 0; a >= 128;) {
          f = 128 | 127 & a, this.view[c++] = f, a >>>= 7;
        }

        return this.view[c++] = a, d ? (this.offset = c, this) : e;
      }, c.writeVarint32ZigZag = function (a, c) {
        return this.writeVarint32(b.zigZagEncode32(a), c);
      }, c.readVarint32 = function (a) {
        var e;
        var c;
        var d;
        var f;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 1 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 1 + ') <= ' + this.buffer.byteLength);
        }

        c = 0, d = 0;

        do {
          if (!this.noAssert && a > this.limit) throw f = Error('Truncated'), f.truncated = !0, f;
          e = this.view[a++], c < 5 && (d |= (127 & e) << 7 * c), ++c;
        } while ((128 & e) !== 0);

        return d |= 0, b ? (this.offset = a, d) : {
          value: d,
          length: c
        };
      }, c.readVarint32ZigZag = function (a) {
        var c = this.readVarint32(a);
        return _typeof(c) === 'object' ? c.value = b.zigZagDecode32(c.value) : c = b.zigZagDecode32(c), c;
      }, a && (b.MAX_VARINT64_BYTES = 10, b.calculateVarint64 = function (b) {
        typeof b === 'number' ? b = a.fromNumber(b) : typeof b === 'string' && (b = a.fromString(b));
        var c = b.toInt() >>> 0;
        var d = b.shiftRightUnsigned(28).toInt() >>> 0;
        var e = b.shiftRightUnsigned(56).toInt() >>> 0;
        return e == 0 ? d == 0 ? c < 16384 ? c < 128 ? 1 : 2 : 1 << 21 > c ? 3 : 4 : d < 16384 ? d < 128 ? 5 : 6 : 1 << 21 > d ? 7 : 8 : e < 128 ? 9 : 10;
      }, b.zigZagEncode64 = function (b) {
        return typeof b === 'number' ? b = a.fromNumber(b, !1) : typeof b === 'string' ? b = a.fromString(b, !1) : b.unsigned !== !1 && (b = b.toSigned()), b.shiftLeft(1).xor(b.shiftRight(63)).toUnsigned();
      }, b.zigZagDecode64 = function (b) {
        return typeof b === 'number' ? b = a.fromNumber(b, !1) : typeof b === 'string' ? b = a.fromString(b, !1) : b.unsigned !== !1 && (b = b.toSigned()), b.shiftRightUnsigned(1).xor(b.and(a.ONE).toSigned().negate()).toSigned();
      }, c.writeVarint64 = function (c, d) {
        var f;
        var g;
        var h;
        var i;
        var j;
        var e = typeof d === 'undefined';

        if (e && (d = this.offset), !this.noAssert) {
          if (typeof c === 'number') c = a.fromNumber(c);else if (typeof c === 'string') c = a.fromString(c);else if (!(c && c instanceof a)) throw TypeError('Illegal value: ' + c + ' (not an integer or Long)');
          if (typeof d !== 'number' || d % 1 !== 0) throw TypeError('Illegal offset: ' + d + ' (not an integer)');
          if (d >>>= 0, d < 0 || d + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + d + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        switch (typeof c === 'number' ? c = a.fromNumber(c, !1) : typeof c === 'string' ? c = a.fromString(c, !1) : c.unsigned !== !1 && (c = c.toSigned()), f = b.calculateVarint64(c), g = c.toInt() >>> 0, h = c.shiftRightUnsigned(28).toInt() >>> 0, i = c.shiftRightUnsigned(56).toInt() >>> 0, d += f, j = this.buffer.byteLength, d > j && this.resize((j *= 2) > d ? j : d), d -= f, f) {
          case 10:
            this.view[d + 9] = 1 & i >>> 7;

          case 9:
            this.view[d + 8] = f !== 9 ? 128 | i : 127 & i;

          case 8:
            this.view[d + 7] = f !== 8 ? 128 | h >>> 21 : 127 & h >>> 21;

          case 7:
            this.view[d + 6] = f !== 7 ? 128 | h >>> 14 : 127 & h >>> 14;

          case 6:
            this.view[d + 5] = f !== 6 ? 128 | h >>> 7 : 127 & h >>> 7;

          case 5:
            this.view[d + 4] = f !== 5 ? 128 | h : 127 & h;

          case 4:
            this.view[d + 3] = f !== 4 ? 128 | g >>> 21 : 127 & g >>> 21;

          case 3:
            this.view[d + 2] = f !== 3 ? 128 | g >>> 14 : 127 & g >>> 14;

          case 2:
            this.view[d + 1] = f !== 2 ? 128 | g >>> 7 : 127 & g >>> 7;

          case 1:
            this.view[d] = f !== 1 ? 128 | g : 127 & g;
        }

        return e ? (this.offset += f, this) : f;
      }, c.writeVarint64ZigZag = function (a, c) {
        return this.writeVarint64(b.zigZagEncode64(a), c);
      }, c.readVarint64 = function (b) {
        var d;
        var e;
        var f;
        var g;
        var h;
        var i;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 1 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 1 + ') <= ' + this.buffer.byteLength);
        }

        if (d = b, e = 0, f = 0, g = 0, h = 0, h = this.view[b++], e = 127 & h, 128 & h && (h = this.view[b++], e |= (127 & h) << 7, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], e |= (127 & h) << 14, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], e |= (127 & h) << 21, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], f = 127 & h, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], f |= (127 & h) << 7, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], f |= (127 & h) << 14, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], f |= (127 & h) << 21, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], g = 127 & h, (128 & h || this.noAssert && typeof h === 'undefined') && (h = this.view[b++], g |= (127 & h) << 7, 128 & h || this.noAssert && typeof h === 'undefined')))))))))) throw Error('Buffer overrun');
        return i = a.fromBits(e | f << 28, f >>> 4 | g << 24, !1), c ? (this.offset = b, i) : {
          value: i,
          length: b - d
        };
      }, c.readVarint64ZigZag = function (c) {
        var d = this.readVarint64(c);
        return d && d.value instanceof a ? d.value = b.zigZagDecode64(d.value) : d = b.zigZagDecode64(d), d;
      }), c.writeCString = function (a, b) {
        var d;
        var e;
        var g;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), e = a.length, !this.noAssert) {
          if (typeof a !== 'string') throw TypeError('Illegal str: Not a string');

          for (d = 0; e > d; ++d) {
            if (a.charCodeAt(d) === 0) throw RangeError('Illegal str: Contains NULL-characters');
          }

          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return e = k.calculateUTF16asUTF8(f(a))[1], b += e + 1, g = this.buffer.byteLength, b > g && this.resize((g *= 2) > b ? g : b), b -= e + 1, k.encodeUTF16toUTF8(f(a), function (a) {
          this.view[b++] = a;
        }.bind(this)), this.view[b++] = 0, c ? (this.offset = b, this) : e;
      }, c.readCString = function (a) {
        var c;
        var e;
        var f;
        var b = typeof a === 'undefined';

        if (b && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 1 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 1 + ') <= ' + this.buffer.byteLength);
        }

        return c = a, f = -1, k.decodeUTF8toUTF16(function () {
          if (f === 0) return null;
          if (a >= this.limit) throw RangeError('Illegal range: Truncated data, ' + a + ' < ' + this.limit);
          return f = this.view[a++], f === 0 ? null : f;
        }.bind(this), e = g(), !0), b ? (this.offset = a, e()) : {
          string: e(),
          length: a - c
        };
      }, c.writeIString = function (a, b) {
        var e;
        var d;
        var g;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof a !== 'string') throw TypeError('Illegal str: Not a string');
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        if (d = b, e = k.calculateUTF16asUTF8(f(a), this.noAssert)[1], b += 4 + e, g = this.buffer.byteLength, b > g && this.resize((g *= 2) > b ? g : b), b -= 4 + e, this.littleEndian ? (this.view[b + 3] = 255 & e >>> 24, this.view[b + 2] = 255 & e >>> 16, this.view[b + 1] = 255 & e >>> 8, this.view[b] = 255 & e) : (this.view[b] = 255 & e >>> 24, this.view[b + 1] = 255 & e >>> 16, this.view[b + 2] = 255 & e >>> 8, this.view[b + 3] = 255 & e), b += 4, k.encodeUTF16toUTF8(f(a), function (a) {
          this.view[b++] = a;
        }.bind(this)), b !== d + 4 + e) throw RangeError('Illegal range: Truncated data, ' + b + ' == ' + (b + 4 + e));
        return c ? (this.offset = b, this) : b - d;
      }, c.readIString = function (a) {
        var d;
        var e;
        var f;
        var c = typeof a === 'undefined';

        if (c && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 4 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 4 + ') <= ' + this.buffer.byteLength);
        }

        return d = a, e = this.readUint32(a), f = this.readUTF8String(e, b.METRICS_BYTES, a += 4), a += f.length, c ? (this.offset = a, f.string) : {
          string: f.string,
          length: a - d
        };
      }, b.METRICS_CHARS = 'c', b.METRICS_BYTES = 'b', c.writeUTF8String = function (a, b) {
        var d;
        var e;
        var g;
        var c = typeof b === 'undefined';

        if (c && (b = this.offset), !this.noAssert) {
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: ' + b + ' (not an integer)');
          if (b >>>= 0, b < 0 || b + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + b + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return e = b, d = k.calculateUTF16asUTF8(f(a))[1], b += d, g = this.buffer.byteLength, b > g && this.resize((g *= 2) > b ? g : b), b -= d, k.encodeUTF16toUTF8(f(a), function (a) {
          this.view[b++] = a;
        }.bind(this)), c ? (this.offset = b, this) : b - e;
      }, c.writeString = c.writeUTF8String, b.calculateUTF8Chars = function (a) {
        return k.calculateUTF16asUTF8(f(a))[0];
      }, b.calculateUTF8Bytes = function (a) {
        return k.calculateUTF16asUTF8(f(a))[1];
      }, b.calculateString = b.calculateUTF8Bytes, c.readUTF8String = function (a, c, d) {
        var e, i, f, h, j;

        if (typeof c === 'number' && (d = c, c = void 0), e = typeof d === 'undefined', e && (d = this.offset), typeof c === 'undefined' && (c = b.METRICS_CHARS), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal length: ' + a + ' (not an integer)');
          if (a |= 0, typeof d !== 'number' || d % 1 !== 0) throw TypeError('Illegal offset: ' + d + ' (not an integer)');
          if (d >>>= 0, d < 0 || d + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + d + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        if (f = 0, h = d, c === b.METRICS_CHARS) {
          if (i = g(), k.decodeUTF8(function () {
            return a > f && d < this.limit ? this.view[d++] : null;
          }.bind(this), function (a) {
            ++f, k.UTF8toUTF16(a, i);
          }), f !== a) throw RangeError('Illegal range: Truncated data, ' + f + ' == ' + a);
          return e ? (this.offset = d, i()) : {
            string: i(),
            length: d - h
          };
        }

        if (c === b.METRICS_BYTES) {
          if (!this.noAssert) {
            if (typeof d !== 'number' || d % 1 !== 0) throw TypeError('Illegal offset: ' + d + ' (not an integer)');
            if (d >>>= 0, d < 0 || d + a > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + d + ' (+' + a + ') <= ' + this.buffer.byteLength);
          }

          if (j = d + a, k.decodeUTF8toUTF16(function () {
            return j > d ? this.view[d++] : null;
          }.bind(this), i = g(), this.noAssert), d !== j) throw RangeError('Illegal range: Truncated data, ' + d + ' == ' + j);
          return e ? (this.offset = d, i()) : {
            string: i(),
            length: d - h
          };
        }

        throw TypeError('Unsupported metrics: ' + c);
      }, c.readString = c.readUTF8String, c.writeVString = function (a, c) {
        var g;
        var h;
        var e;
        var i;
        var d = typeof c === 'undefined';

        if (d && (c = this.offset), !this.noAssert) {
          if (typeof a !== 'string') throw TypeError('Illegal str: Not a string');
          if (typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal offset: ' + c + ' (not an integer)');
          if (c >>>= 0, c < 0 || c + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + c + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        if (e = c, g = k.calculateUTF16asUTF8(f(a), this.noAssert)[1], h = b.calculateVarint32(g), c += h + g, i = this.buffer.byteLength, c > i && this.resize((i *= 2) > c ? i : c), c -= h + g, c += this.writeVarint32(g, c), k.encodeUTF16toUTF8(f(a), function (a) {
          this.view[c++] = a;
        }.bind(this)), c !== e + g + h) throw RangeError('Illegal range: Truncated data, ' + c + ' == ' + (c + g + h));
        return d ? (this.offset = c, this) : c - e;
      }, c.readVString = function (a) {
        var d;
        var e;
        var f;
        var c = typeof a === 'undefined';

        if (c && (a = this.offset), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 1 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 1 + ') <= ' + this.buffer.byteLength);
        }

        return d = a, e = this.readVarint32(a), f = this.readUTF8String(e.value, b.METRICS_BYTES, a += e.length), a += f.length, c ? (this.offset = a, f.string) : {
          string: f.string,
          length: a - d
        };
      }, c.append = function (a, c, d) {
        var e, f, g;

        if ((typeof c === 'number' || typeof c !== 'string') && (d = c, c = void 0), e = typeof d === 'undefined', e && (d = this.offset), !this.noAssert) {
          if (typeof d !== 'number' || d % 1 !== 0) throw TypeError('Illegal offset: ' + d + ' (not an integer)');
          if (d >>>= 0, d < 0 || d + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + d + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return a instanceof b || (a = b.wrap(a, c)), f = a.limit - a.offset, f <= 0 ? this : (d += f, g = this.buffer.byteLength, d > g && this.resize((g *= 2) > d ? g : d), d -= f, this.view.set(a.view.subarray(a.offset, a.limit), d), a.offset += f, e && (this.offset += f), this);
      }, c.appendTo = function (a, b) {
        return a.append(this, b), this;
      }, c.assert = function (a) {
        return this.noAssert = !a, this;
      }, c.capacity = function () {
        return this.buffer.byteLength;
      }, c.clear = function () {
        return this.offset = 0, this.limit = this.buffer.byteLength, this.markedOffset = -1, this;
      }, c.clone = function (a) {
        var c = new b(0, this.littleEndian, this.noAssert);
        return a ? (c.buffer = new ArrayBuffer(this.buffer.byteLength), c.view = new Uint8Array(c.buffer)) : (c.buffer = this.buffer, c.view = this.view), c.offset = this.offset, c.markedOffset = this.markedOffset, c.limit = this.limit, c;
      }, c.compact = function (a, b) {
        var c, e, f;

        if (typeof a === 'undefined' && (a = this.offset), typeof b === 'undefined' && (b = this.limit), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (b >>>= 0, a < 0 || a > b || b > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + a + ' <= ' + b + ' <= ' + this.buffer.byteLength);
        }

        return a === 0 && b === this.buffer.byteLength ? this : (c = b - a, c === 0 ? (this.buffer = d, this.view = null, this.markedOffset >= 0 && (this.markedOffset -= a), this.offset = 0, this.limit = 0, this) : (e = new ArrayBuffer(c), f = new Uint8Array(e), f.set(this.view.subarray(a, b)), this.buffer = e, this.view = f, this.markedOffset >= 0 && (this.markedOffset -= a), this.offset = 0, this.limit = c, this));
      }, c.copy = function (a, c) {
        if (typeof a === 'undefined' && (a = this.offset), typeof c === 'undefined' && (c = this.limit), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (a >>>= 0, typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (c >>>= 0, a < 0 || a > c || c > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + a + ' <= ' + c + ' <= ' + this.buffer.byteLength);
        }

        if (a === c) return new b(0, this.littleEndian, this.noAssert);
        var d = c - a;
        var e = new b(d, this.littleEndian, this.noAssert);
        return e.offset = 0, e.limit = d, e.markedOffset >= 0 && (e.markedOffset -= a), this.copyTo(e, 0, a, c), e;
      }, c.copyTo = function (a, c, d, e) {
        var f, g, h;
        if (!this.noAssert && !b.isByteBuffer(a)) throw TypeError('Illegal target: Not a ByteBuffer');
        if (c = (g = typeof c === 'undefined') ? a.offset : 0 | c, d = (f = typeof d === 'undefined') ? this.offset : 0 | d, e = typeof e === 'undefined' ? this.limit : 0 | e, c < 0 || c > a.buffer.byteLength) throw RangeError('Illegal target range: 0 <= ' + c + ' <= ' + a.buffer.byteLength);
        if (d < 0 || e > this.buffer.byteLength) throw RangeError('Illegal source range: 0 <= ' + d + ' <= ' + this.buffer.byteLength);
        return h = e - d, h === 0 ? a : (a.ensureCapacity(c + h), a.view.set(this.view.subarray(d, e), c), f && (this.offset += h), g && (a.offset += h), this);
      }, c.ensureCapacity = function (a) {
        var b = this.buffer.byteLength;
        return a > b ? this.resize((b *= 2) > a ? b : a) : this;
      }, c.fill = function (a, b, c) {
        var d = typeof b === 'undefined';

        if (d && (b = this.offset), typeof a === 'string' && a.length > 0 && (a = a.charCodeAt(0)), typeof b === 'undefined' && (b = this.offset), typeof c === 'undefined' && (c = this.limit), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal value: ' + a + ' (not an integer)');
          if (a |= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (b >>>= 0, typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (c >>>= 0, b < 0 || b > c || c > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + b + ' <= ' + c + ' <= ' + this.buffer.byteLength);
        }

        if (b >= c) return this;

        for (; c > b;) {
          this.view[b++] = a;
        }

        return d && (this.offset = b), this;
      }, c.flip = function () {
        return this.limit = this.offset, this.offset = 0, this;
      }, c.mark = function (a) {
        if (a = typeof a === 'undefined' ? this.offset : a, !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal offset: ' + a + ' (not an integer)');
          if (a >>>= 0, a < 0 || a + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + a + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return this.markedOffset = a, this;
      }, c.order = function (a) {
        if (!this.noAssert && typeof a !== 'boolean') throw TypeError('Illegal littleEndian: Not a boolean');
        return this.littleEndian = !!a, this;
      }, c.LE = function (a) {
        return this.littleEndian = typeof a !== 'undefined' ? !!a : !0, this;
      }, c.BE = function (a) {
        return this.littleEndian = typeof a !== 'undefined' ? !a : !1, this;
      }, c.prepend = function (a, c, d) {
        var e, f, g, h, i;

        if ((typeof c === 'number' || typeof c !== 'string') && (d = c, c = void 0), e = typeof d === 'undefined', e && (d = this.offset), !this.noAssert) {
          if (typeof d !== 'number' || d % 1 !== 0) throw TypeError('Illegal offset: ' + d + ' (not an integer)');
          if (d >>>= 0, d < 0 || d + 0 > this.buffer.byteLength) throw RangeError('Illegal offset: 0 <= ' + d + ' (+' + 0 + ') <= ' + this.buffer.byteLength);
        }

        return a instanceof b || (a = b.wrap(a, c)), f = a.limit - a.offset, f <= 0 ? this : (g = f - d, g > 0 ? (h = new ArrayBuffer(this.buffer.byteLength + g), i = new Uint8Array(h), i.set(this.view.subarray(d, this.buffer.byteLength), f), this.buffer = h, this.view = i, this.offset += g, this.markedOffset >= 0 && (this.markedOffset += g), this.limit += g, d += g) : new Uint8Array(this.buffer), this.view.set(a.view.subarray(a.offset, a.limit), d - f), a.offset = a.limit, e && (this.offset -= f), this);
      }, c.prependTo = function (a, b) {
        return a.prepend(this, b), this;
      }, c.printDebug = function (a) {
        typeof a !== 'function' && (a = console.log.bind(console)), a(this.toString() + '\n-------------------------------------------------------------------\n' + this.toDebug(!0));
      }, c.remaining = function () {
        return this.limit - this.offset;
      }, c.reset = function () {
        return this.markedOffset >= 0 ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0, this;
      }, c.resize = function (a) {
        var b, c;

        if (!this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal capacity: ' + a + ' (not an integer)');
          if (a |= 0, a < 0) throw RangeError('Illegal capacity: 0 <= ' + a);
        }

        return this.buffer.byteLength < a && (b = new ArrayBuffer(a), c = new Uint8Array(b), c.set(this.view), this.buffer = b, this.view = c), this;
      }, c.reverse = function (a, b) {
        if (typeof a === 'undefined' && (a = this.offset), typeof b === 'undefined' && (b = this.limit), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (b >>>= 0, a < 0 || a > b || b > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + a + ' <= ' + b + ' <= ' + this.buffer.byteLength);
        }

        return a === b ? this : (Array.prototype.reverse.call(this.view.subarray(a, b)), this);
      }, c.skip = function (a) {
        if (!this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal length: ' + a + ' (not an integer)');
          a |= 0;
        }

        var b = this.offset + a;
        if (!this.noAssert && (b < 0 || b > this.buffer.byteLength)) throw RangeError('Illegal length: 0 <= ' + this.offset + ' + ' + a + ' <= ' + this.buffer.byteLength);
        return this.offset = b, this;
      }, c.slice = function (a, b) {
        if (typeof a === 'undefined' && (a = this.offset), typeof b === 'undefined' && (b = this.limit), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (b >>>= 0, a < 0 || a > b || b > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + a + ' <= ' + b + ' <= ' + this.buffer.byteLength);
        }

        var c = this.clone();
        return c.offset = a, c.limit = b, c;
      }, c.toBuffer = function (a) {
        var e;
        var b = this.offset;
        var c = this.limit;

        if (!this.noAssert) {
          if (typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal offset: Not an integer');
          if (b >>>= 0, typeof c !== 'number' || c % 1 !== 0) throw TypeError('Illegal limit: Not an integer');
          if (c >>>= 0, b < 0 || b > c || c > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + b + ' <= ' + c + ' <= ' + this.buffer.byteLength);
        }

        return a || b !== 0 || c !== this.buffer.byteLength ? b === c ? d : (e = new ArrayBuffer(c - b), new Uint8Array(e).set(new Uint8Array(this.buffer).subarray(b, c), 0), e) : this.buffer;
      }, c.toArrayBuffer = c.toBuffer, c.toString = function (a, b, c) {
        if (typeof a === 'undefined') return 'ByteBufferAB(offset=' + this.offset + ',markedOffset=' + this.markedOffset + ',limit=' + this.limit + ',capacity=' + this.capacity() + ')';

        switch (typeof a === 'number' && (a = 'utf8', b = a, c = b), a) {
          case 'utf8':
            return this.toUTF8(b, c);

          case 'base64':
            return this.toBase64(b, c);

          case 'hex':
            return this.toHex(b, c);

          case 'binary':
            return this.toBinary(b, c);

          case 'debug':
            return this.toDebug();

          case 'columns':
            return this.toColumns();

          default:
            throw Error('Unsupported encoding: ' + a);
        }
      }, j = function () {
        var d;
        var e;
        var a = {};
        var b = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47];
        var c = [];

        for (d = 0, e = b.length; e > d; ++d) {
          c[b[d]] = d;
        }

        return a.encode = function (a, c) {
          for (var d, e; (d = a()) !== null;) {
            c(b[63 & d >> 2]), e = (3 & d) << 4, (d = a()) !== null ? (e |= 15 & d >> 4, c(b[63 & (e | 15 & d >> 4)]), e = (15 & d) << 2, (d = a()) !== null ? (c(b[63 & (e | 3 & d >> 6)]), c(b[63 & d])) : (c(b[63 & e]), c(61))) : (c(b[63 & e]), c(61), c(61));
          }
        }, a.decode = function (a, b) {
          function g(a) {
            throw Error('Illegal character code: ' + a);
          }

          for (var d, e, f; (d = a()) !== null;) {
            if (e = c[d], typeof e === 'undefined' && g(d), (d = a()) !== null && (f = c[d], typeof f === 'undefined' && g(d), b(e << 2 >>> 0 | (48 & f) >> 4), (d = a()) !== null)) {
              if (e = c[d], typeof e === 'undefined') {
                if (d === 61) break;
                g(d);
              }

              if (b((15 & f) << 4 >>> 0 | (60 & e) >> 2), (d = a()) !== null) {
                if (f = c[d], typeof f === 'undefined') {
                  if (d === 61) break;
                  g(d);
                }

                b((3 & e) << 6 >>> 0 | f);
              }
            }
          }
        }, a.test = function (a) {
          return /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(a);
        }, a;
      }(), c.toBase64 = function (a, b) {
        if (typeof a === 'undefined' && (a = this.offset), typeof b === 'undefined' && (b = this.limit), a = 0 | a, b = 0 | b, a < 0 || b > this.capacity || a > b) throw RangeError('begin, end');
        var c;
        return j.encode(function () {
          return b > a ? this.view[a++] : null;
        }.bind(this), c = g()), c();
      }, b.fromBase64 = function (a, c) {
        if (typeof a !== 'string') throw TypeError('str');
        var d = new b(3 * (a.length / 4), c);
        var e = 0;
        return j.decode(f(a), function (a) {
          d.view[e++] = a;
        }), d.limit = e, d;
      }, b.btoa = function (a) {
        return b.fromBinary(a).toBase64();
      }, b.atob = function (a) {
        return b.fromBase64(a).toBinary();
      }, c.toBinary = function (a, b) {
        if (typeof a === 'undefined' && (a = this.offset), typeof b === 'undefined' && (b = this.limit), a |= 0, b |= 0, a < 0 || b > this.capacity() || a > b) throw RangeError('begin, end');
        if (a === b) return '';

        for (var c = [], d = []; b > a;) {
          c.push(this.view[a++]), c.length >= 1024 && (d.push(String.fromCharCode.apply(String, c)), c = []);
        }

        return d.join('') + String.fromCharCode.apply(String, c);
      }, b.fromBinary = function (a, c) {
        if (typeof a !== 'string') throw TypeError('str');

        for (var f, d = 0, e = a.length, g = new b(e, c); e > d;) {
          if (f = a.charCodeAt(d), f > 255) throw RangeError('illegal char code: ' + f);
          g.view[d++] = f;
        }

        return g.limit = e, g;
      }, c.toDebug = function (a) {
        for (var d, b = -1, c = this.buffer.byteLength, e = '', f = '', g = ''; c > b;) {
          if (b !== -1 && (d = this.view[b], e += d < 16 ? '0' + d.toString(16).toUpperCase() : d.toString(16).toUpperCase(), a && (f += d > 32 && d < 127 ? String.fromCharCode(d) : '.')), ++b, a && b > 0 && b % 16 === 0 && b !== c) {
            for (; e.length < 51;) {
              e += ' ';
            }

            g += e + f + '\n', e = f = '';
          }

          e += b === this.offset && b === this.limit ? b === this.markedOffset ? '!' : '|' : b === this.offset ? b === this.markedOffset ? '[' : '<' : b === this.limit ? b === this.markedOffset ? ']' : '>' : b === this.markedOffset ? "'" : a || b !== 0 && b !== c ? ' ' : '';
        }

        if (a && e !== ' ') {
          for (; e.length < 51;) {
            e += ' ';
          }

          g += e + f + '\n';
        }

        return a ? g : e;
      }, b.fromDebug = function (a, c, d) {
        for (var i, j, e = a.length, f = new b(0 | (e + 1) / 3, c, d), g = 0, h = 0, k = !1, l = !1, m = !1, n = !1, o = !1; e > g;) {
          switch (i = a.charAt(g++)) {
            case '!':
              if (!d) {
                if (l || m || n) {
                  o = !0;
                  break;
                }

                l = m = n = !0;
              }

              f.offset = f.markedOffset = f.limit = h, k = !1;
              break;

            case '|':
              if (!d) {
                if (l || n) {
                  o = !0;
                  break;
                }

                l = n = !0;
              }

              f.offset = f.limit = h, k = !1;
              break;

            case '[':
              if (!d) {
                if (l || m) {
                  o = !0;
                  break;
                }

                l = m = !0;
              }

              f.offset = f.markedOffset = h, k = !1;
              break;

            case '<':
              if (!d) {
                if (l) {
                  o = !0;
                  break;
                }

                l = !0;
              }

              f.offset = h, k = !1;
              break;

            case ']':
              if (!d) {
                if (n || m) {
                  o = !0;
                  break;
                }

                n = m = !0;
              }

              f.limit = f.markedOffset = h, k = !1;
              break;

            case '>':
              if (!d) {
                if (n) {
                  o = !0;
                  break;
                }

                n = !0;
              }

              f.limit = h, k = !1;
              break;

            case "'":
              if (!d) {
                if (m) {
                  o = !0;
                  break;
                }

                m = !0;
              }

              f.markedOffset = h, k = !1;
              break;

            case ' ':
              k = !1;
              break;

            default:
              if (!d && k) {
                o = !0;
                break;
              }

              if (j = parseInt(i + a.charAt(g++), 16), !d && (isNaN(j) || j < 0 || j > 255)) throw TypeError('Illegal str: Not a debug encoded string');
              f.view[h++] = j, k = !0;
          }

          if (o) throw TypeError('Illegal str: Invalid symbol at ' + g);
        }

        if (!d) {
          if (!l || !n) throw TypeError('Illegal str: Missing offset or limit');
          if (h < f.buffer.byteLength) throw TypeError('Illegal str: Not a debug encoded string (is it hex?) ' + h + ' < ' + e);
        }

        return f;
      }, c.toHex = function (a, b) {
        if (a = typeof a === 'undefined' ? this.offset : a, b = typeof b === 'undefined' ? this.limit : b, !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (b >>>= 0, a < 0 || a > b || b > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + a + ' <= ' + b + ' <= ' + this.buffer.byteLength);
        }

        for (var d, c = new Array(b - a); b > a;) {
          d = this.view[a++], d < 16 ? c.push('0', d.toString(16)) : c.push(d.toString(16));
        }

        return c.join('');
      }, b.fromHex = function (a, c, d) {
        var g, e, f, h, i;

        if (!d) {
          if (typeof a !== 'string') throw TypeError('Illegal str: Not a string');
          if (a.length % 2 !== 0) throw TypeError('Illegal str: Length not a multiple of 2');
        }

        for (e = a.length, f = new b(0 | e / 2, c), h = 0, i = 0; e > h; h += 2) {
          if (g = parseInt(a.substring(h, h + 2), 16), !d && (!isFinite(g) || g < 0 || g > 255)) throw TypeError('Illegal str: Contains non-hex characters');
          f.view[i++] = g;
        }

        return f.limit = i, f;
      }, k = function () {
        var a = {};
        return a.MAX_CODEPOINT = 1114111, a.encodeUTF8 = function (a, b) {
          var c = null;

          for (typeof a === 'number' && (c = a, a = function a() {
            return null;
          }); c !== null || (c = a()) !== null;) {
            c < 128 ? b(127 & c) : c < 2048 ? (b(192 | 31 & c >> 6), b(128 | 63 & c)) : c < 65536 ? (b(224 | 15 & c >> 12), b(128 | 63 & c >> 6), b(128 | 63 & c)) : (b(240 | 7 & c >> 18), b(128 | 63 & c >> 12), b(128 | 63 & c >> 6), b(128 | 63 & c)), c = null;
          }
        }, a.decodeUTF8 = function (a, b) {
          for (var c, d, e, f, g = function g(a) {
            a = a.slice(0, a.indexOf(null));
            var b = Error(a.toString());
            throw b.name = 'TruncatedError', b.bytes = a, b;
          }; (c = a()) !== null;) {
            if ((128 & c) === 0) b(c);else if ((224 & c) === 192) (d = a()) === null && g([c, d]), b((31 & c) << 6 | 63 & d);else if ((240 & c) === 224) ((d = a()) === null || (e = a()) === null) && g([c, d, e]), b((15 & c) << 12 | (63 & d) << 6 | 63 & e);else {
              if ((248 & c) !== 240) throw RangeError('Illegal starting byte: ' + c);
              ((d = a()) === null || (e = a()) === null || (f = a()) === null) && g([c, d, e, f]), b((7 & c) << 18 | (63 & d) << 12 | (63 & e) << 6 | 63 & f);
            }
          }
        }, a.UTF16toUTF8 = function (a, b) {
          for (var c, d = null;;) {
            if ((c = d !== null ? d : a()) === null) break;
            c >= 55296 && c <= 57343 && (d = a()) !== null && d >= 56320 && d <= 57343 ? (b(1024 * (c - 55296) + d - 56320 + 65536), d = null) : b(c);
          }

          d !== null && b(d);
        }, a.UTF8toUTF16 = function (a, b) {
          var c = null;

          for (typeof a === 'number' && (c = a, a = function a() {
            return null;
          }); c !== null || (c = a()) !== null;) {
            c <= 65535 ? b(c) : (c -= 65536, b((c >> 10) + 55296), b(c % 1024 + 56320)), c = null;
          }
        }, a.encodeUTF16toUTF8 = function (b, c) {
          a.UTF16toUTF8(b, function (b) {
            a.encodeUTF8(b, c);
          });
        }, a.decodeUTF8toUTF16 = function (b, c) {
          a.decodeUTF8(b, function (b) {
            a.UTF8toUTF16(b, c);
          });
        }, a.calculateCodePoint = function (a) {
          return a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
        }, a.calculateUTF8 = function (a) {
          for (var b, c = 0; (b = a()) !== null;) {
            c += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
          }

          return c;
        }, a.calculateUTF16asUTF8 = function (b) {
          var c = 0;
          var d = 0;
          return a.UTF16toUTF8(b, function (a) {
            ++c, d += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
          }), [c, d];
        }, a;
      }(), c.toUTF8 = function (a, b) {
        if (typeof a === 'undefined' && (a = this.offset), typeof b === 'undefined' && (b = this.limit), !this.noAssert) {
          if (typeof a !== 'number' || a % 1 !== 0) throw TypeError('Illegal begin: Not an integer');
          if (a >>>= 0, typeof b !== 'number' || b % 1 !== 0) throw TypeError('Illegal end: Not an integer');
          if (b >>>= 0, a < 0 || a > b || b > this.buffer.byteLength) throw RangeError('Illegal range: 0 <= ' + a + ' <= ' + b + ' <= ' + this.buffer.byteLength);
        }

        var c;

        try {
          k.decodeUTF8toUTF16(function () {
            return b > a ? this.view[a++] : null;
          }.bind(this), c = g());
        } catch (d) {
          if (a !== b) throw RangeError('Illegal range: Truncated data, ' + a + ' != ' + b);
        }

        return c();
      }, b.fromUTF8 = function (a, c, d) {
        if (!d && typeof a !== 'string') throw TypeError('Illegal str: Not a string');
        var e = new b(k.calculateUTF16asUTF8(f(a), !0)[1], c, d);
        var g = 0;
        return k.encodeUTF16toUTF8(f(a), function (a) {
          e.view[g++] = a;
        }), e.limit = g, e;
      }, b;
    }(c);

    var e = function (b, c) {
      var f;
      var h;
      var e = {};
      return e.ByteBuffer = b, e.c = b, f = b, e.Long = c || null, e.VERSION = '5.0.1', e.WIRE_TYPES = {}, e.WIRE_TYPES.VARINT = 0, e.WIRE_TYPES.BITS64 = 1, e.WIRE_TYPES.LDELIM = 2, e.WIRE_TYPES.STARTGROUP = 3, e.WIRE_TYPES.ENDGROUP = 4, e.WIRE_TYPES.BITS32 = 5, e.PACKABLE_WIRE_TYPES = [e.WIRE_TYPES.VARINT, e.WIRE_TYPES.BITS64, e.WIRE_TYPES.BITS32], e.TYPES = {
        int32: {
          name: 'int32',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: 0
        },
        uint32: {
          name: 'uint32',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: 0
        },
        sint32: {
          name: 'sint32',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: 0
        },
        int64: {
          name: 'int64',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: e.Long ? e.Long.ZERO : void 0
        },
        uint64: {
          name: 'uint64',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: e.Long ? e.Long.UZERO : void 0
        },
        sint64: {
          name: 'sint64',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: e.Long ? e.Long.ZERO : void 0
        },
        bool: {
          name: 'bool',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: !1
        },
        double: {
          name: 'double',
          wireType: e.WIRE_TYPES.BITS64,
          defaultValue: 0
        },
        string: {
          name: 'string',
          wireType: e.WIRE_TYPES.LDELIM,
          defaultValue: ''
        },
        bytes: {
          name: 'bytes',
          wireType: e.WIRE_TYPES.LDELIM,
          defaultValue: null
        },
        fixed32: {
          name: 'fixed32',
          wireType: e.WIRE_TYPES.BITS32,
          defaultValue: 0
        },
        sfixed32: {
          name: 'sfixed32',
          wireType: e.WIRE_TYPES.BITS32,
          defaultValue: 0
        },
        fixed64: {
          name: 'fixed64',
          wireType: e.WIRE_TYPES.BITS64,
          defaultValue: e.Long ? e.Long.UZERO : void 0
        },
        sfixed64: {
          name: 'sfixed64',
          wireType: e.WIRE_TYPES.BITS64,
          defaultValue: e.Long ? e.Long.ZERO : void 0
        },
        float: {
          name: 'float',
          wireType: e.WIRE_TYPES.BITS32,
          defaultValue: 0
        },
        enum: {
          name: 'enum',
          wireType: e.WIRE_TYPES.VARINT,
          defaultValue: 0
        },
        message: {
          name: 'message',
          wireType: e.WIRE_TYPES.LDELIM,
          defaultValue: null
        },
        group: {
          name: 'group',
          wireType: e.WIRE_TYPES.STARTGROUP,
          defaultValue: null
        }
      }, e.MAP_KEY_TYPES = [e.TYPES.int32, e.TYPES.sint32, e.TYPES.sfixed32, e.TYPES.uint32, e.TYPES.fixed32, e.TYPES.int64, e.TYPES.sint64, e.TYPES.sfixed64, e.TYPES.uint64, e.TYPES.fixed64, e.TYPES.bool, e.TYPES.string, e.TYPES.bytes], e.ID_MIN = 1, e.ID_MAX = 536870911, e.convertFieldsToCamelCase = !1, e.populateAccessors = !0, e.populateDefaults = !0, e.Util = function () {
        var a = {};
        return a.IS_NODE = !((typeof process === "undefined" ? "undefined" : _typeof(process)) !== 'object' || process + '' != '[object process]' || process.browser), a.XHR = function () {
          var c;
          var a = [function () {
            return new XMLHttpRequest();
          }, function () {
            return new ActiveXObject('Msxml2.XMLHTTP');
          }, function () {
            return new ActiveXObject('Msxml3.XMLHTTP');
          }, function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
          }];
          var b = null;

          for (c = 0; c < a.length; c++) {
            try {
              b = a[c]();
            } catch (d) {
              continue;
            }

            break;
          }

          if (!b) throw Error('XMLHttpRequest is not supported');
          return b;
        }, a.fetch = function (b, c) {
          if (c && typeof c !== 'function' && (c = null), a.IS_NODE) {
            if (c) g.readFile(b, function (a, b) {
              a ? c(null) : c('' + b);
            });else try {
              return g.readFileSync(b);
            } catch (d) {
              return null;
            }
          } else {
            var e = a.XHR();
            if (e.open('GET', b, c ? !0 : !1), e.setRequestHeader('Accept', 'text/plain'), typeof e.overrideMimeType === 'function' && e.overrideMimeType('text/plain'), !c) return e.send(null), e.status == 200 || e.status == 0 && typeof e.responseText === 'string' ? e.responseText : null;
            if (e.onreadystatechange = function () {
              e.readyState == 4 && (e.status == 200 || e.status == 0 && typeof e.responseText === 'string' ? c(e.responseText) : c(null));
            }, e.readyState == 4) return;
            e.send(null);
          }
        }, a.toCamelCase = function (a) {
          return a.replace(/_([a-zA-Z])/g, function (a, b) {
            return b.toUpperCase();
          });
        }, a;
      }(), e.Lang = {
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,
        RULE: /^(?:required|optional|repeated|map)$/,
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,
        NUMBER_OCT: /^0[0-7]+$/,
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,
        BOOL: /^(?:true|false)$/i,
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
        WHITESPACE: /\s/,
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
      }, e.DotProto = function (a, b) {
        function h(a, c) {
          var d = -1;
          var e = 1;
          if (a.charAt(0) == '-' && (e = -1, a = a.substring(1)), b.NUMBER_DEC.test(a)) d = parseInt(a);else if (b.NUMBER_HEX.test(a)) d = parseInt(a.substring(2), 16);else {
            if (!b.NUMBER_OCT.test(a)) throw Error('illegal id value: ' + (e < 0 ? '-' : '') + a);
            d = parseInt(a.substring(1), 8);
          }
          if (d = 0 | e * d, !c && d < 0) throw Error('illegal id value: ' + (e < 0 ? '-' : '') + a);
          return d;
        }

        function i(a) {
          var c = 1;
          if (a.charAt(0) == '-' && (c = -1, a = a.substring(1)), b.NUMBER_DEC.test(a)) return c * parseInt(a, 10);
          if (b.NUMBER_HEX.test(a)) return c * parseInt(a.substring(2), 16);
          if (b.NUMBER_OCT.test(a)) return c * parseInt(a.substring(1), 8);
          if (a === 'inf') return 1 / 0 * c;
          if (a === 'nan') return 0 / 0;
          if (b.NUMBER_FLT.test(a)) return c * parseFloat(a);
          throw Error('illegal number value: ' + (c < 0 ? '-' : '') + a);
        }

        function j(a, b, c) {
          typeof a[b] === 'undefined' ? a[b] = c : (Array.isArray(a[b]) || (a[b] = [a[b]]), a[b].push(c));
        }

        var f;
        var g;
        var c = {};

        var d = function d(a) {
          this.source = a + '', this.index = 0, this.line = 1, this.stack = [], this._stringOpen = null;
        };

        var e = d.prototype;
        return e._readString = function () {
          var c;
          var a = this._stringOpen === '"' ? b.STRING_DQ : b.STRING_SQ;
          if (a.lastIndex = this.index - 1, c = a.exec(this.source), !c) throw Error('unterminated string');
          return this.index = a.lastIndex, this.stack.push(this._stringOpen), this._stringOpen = null, c[1];
        }, e.next = function () {
          var a, c, d, e, f, g;
          if (this.stack.length > 0) return this.stack.shift();
          if (this.index >= this.source.length) return null;
          if (this._stringOpen !== null) return this._readString();

          do {
            for (a = !1; b.WHITESPACE.test(d = this.source.charAt(this.index));) {
              if (d === '\n' && ++this.line, ++this.index === this.source.length) return null;
            }

            if (this.source.charAt(this.index) === '/') if (++this.index, this.source.charAt(this.index) === '/') {
              for (; this.source.charAt(++this.index) !== '\n';) {
                if (this.index == this.source.length) return null;
              }

              ++this.index, ++this.line, a = !0;
            } else {
              if ((d = this.source.charAt(this.index)) !== '*') return '/';

              do {
                if (d === '\n' && ++this.line, ++this.index === this.source.length) return null;
                c = d, d = this.source.charAt(this.index);
              } while (c !== '*' || d !== '/');

              ++this.index, a = !0;
            }
          } while (a);

          if (this.index === this.source.length) return null;
          if (e = this.index, b.DELIM.lastIndex = 0, f = b.DELIM.test(this.source.charAt(e++)), !f) for (; e < this.source.length && !b.DELIM.test(this.source.charAt(e));) {
            ++e;
          }
          return g = this.source.substring(this.index, this.index = e), (g === '"' || g === "'") && (this._stringOpen = g), g;
        }, e.peek = function () {
          if (this.stack.length === 0) {
            var a = this.next();
            if (a === null) return null;
            this.stack.push(a);
          }

          return this.stack[0];
        }, e.skip = function (a) {
          var b = this.next();
          if (b !== a) throw Error("illegal '" + b + "', '" + a + "' expected");
        }, e.omit = function (a) {
          return this.peek() === a ? (this.next(), !0) : !1;
        }, e.toString = function () {
          return 'Tokenizer (' + this.index + '/' + this.source.length + ' at line ' + this.line + ')';
        }, c.Tokenizer = d, f = function f(a) {
          this.tn = new d(a), this.proto3 = !1;
        }, g = f.prototype, g.parse = function () {
          var c;
          var a = {
            name: '[ROOT]',
            package: null,
            messages: [],
            enums: [],
            imports: [],
            options: {},
            services: []
          };
          var d = !0;

          try {
            for (; c = this.tn.next();) {
              switch (c) {
                case 'package':
                  if (!d || a.package !== null) throw Error("unexpected 'package'");
                  if (c = this.tn.next(), !b.TYPEREF.test(c)) throw Error('illegal package name: ' + c);
                  this.tn.skip(';'), a.package = c;
                  break;

                case 'import':
                  if (!d) throw Error("unexpected 'import'");
                  c = this.tn.peek(), c === 'public' && this.tn.next(), c = this._readString(), this.tn.skip(';'), a.imports.push(c);
                  break;

                case 'syntax':
                  if (!d) throw Error("unexpected 'syntax'");
                  this.tn.skip('='), (a.syntax = this._readString()) === 'proto3' && (this.proto3 = !0), this.tn.skip(';');
                  break;

                case 'message':
                  this._parseMessage(a, null), d = !1;
                  break;

                case 'enum':
                  this._parseEnum(a), d = !1;
                  break;

                case 'option':
                  this._parseOption(a);

                  break;

                case 'service':
                  this._parseService(a);

                  break;

                case 'extend':
                  this._parseExtend(a);

                  break;

                default:
                  throw Error("unexpected '" + c + "'");
              }
            }
          } catch (e) {
            throw e.message = 'Parse error at line ' + this.tn.line + ': ' + e.message, e;
          }

          return delete a.name, a;
        }, f.parse = function (a) {
          return new f(a).parse();
        }, g._readString = function () {
          var b;
          var c;
          var a = '';

          do {
            if (c = this.tn.next(), c !== "'" && c !== '"') throw Error('illegal string delimiter: ' + c);
            a += this.tn.next(), this.tn.skip(c), b = this.tn.peek();
          } while (b === '"' || b === '"');

          return a;
        }, g._readValue = function (a) {
          var c = this.tn.peek();
          if (c === '"' || c === "'") return this._readString();
          if (this.tn.next(), b.NUMBER.test(c)) return i(c);
          if (b.BOOL.test(c)) return c.toLowerCase() === 'true';
          if (a && b.TYPEREF.test(c)) return c;
          throw Error('illegal value: ' + c);
        }, g._parseOption = function (a, c) {
          var f;
          var d = this.tn.next();
          var e = !1;
          if (d === '(' && (e = !0, d = this.tn.next()), !b.TYPEREF.test(d)) throw Error('illegal option name: ' + d);
          f = d, e && (this.tn.skip(')'), f = '(' + f + ')', d = this.tn.peek(), b.FQTYPEREF.test(d) && (f += d, this.tn.next())), this.tn.skip('='), this._parseOptionValue(a, f), c || this.tn.skip(';');
        }, g._parseOptionValue = function (a, c) {
          var d = this.tn.peek();
          if (d !== '{') j(a.options, c, this._readValue(!0));else for (this.tn.skip('{'); (d = this.tn.next()) !== '}';) {
            if (!b.NAME.test(d)) throw Error('illegal option name: ' + c + '.' + d);
            this.tn.omit(':') ? j(a.options, c + '.' + d, this._readValue(!0)) : this._parseOptionValue(a, c + '.' + d);
          }
        }, g._parseService = function (a) {
          var d;
          var e;
          var c = this.tn.next();
          if (!b.NAME.test(c)) throw Error('illegal service name at line ' + this.tn.line + ': ' + c);

          for (d = c, e = {
            name: d,
            rpc: {},
            options: {}
          }, this.tn.skip('{'); (c = this.tn.next()) !== '}';) {
            if (c === 'option') this._parseOption(e);else {
              if (c !== 'rpc') throw Error('illegal service token: ' + c);

              this._parseServiceRPC(e);
            }
          }

          this.tn.omit(';'), a.services.push(e);
        }, g._parseServiceRPC = function (a) {
          var e;
          var f;
          var c = 'rpc';
          var d = this.tn.next();
          if (!b.NAME.test(d)) throw Error('illegal rpc service method name: ' + d);
          if (e = d, f = {
            request: null,
            response: null,
            request_stream: !1,
            response_stream: !1,
            options: {}
          }, this.tn.skip('('), d = this.tn.next(), d.toLowerCase() === 'stream' && (f.request_stream = !0, d = this.tn.next()), !b.TYPEREF.test(d)) throw Error('illegal rpc service request type: ' + d);
          if (f.request = d, this.tn.skip(')'), d = this.tn.next(), d.toLowerCase() !== 'returns') throw Error('illegal rpc service request type delimiter: ' + d);

          if (this.tn.skip('('), d = this.tn.next(), d.toLowerCase() === 'stream' && (f.response_stream = !0, d = this.tn.next()), f.response = d, this.tn.skip(')'), d = this.tn.peek(), d === '{') {
            for (this.tn.next(); (d = this.tn.next()) !== '}';) {
              if (d !== 'option') throw Error('illegal rpc service token: ' + d);

              this._parseOption(f);
            }

            this.tn.omit(';');
          } else this.tn.skip(';');

          typeof a[c] === 'undefined' && (a[c] = {}), a[c][e] = f;
        }, g._parseMessage = function (a, c) {
          var d = !!c;
          var e = this.tn.next();
          var f = {
            name: '',
            fields: [],
            enums: [],
            messages: [],
            options: {},
            services: [],
            oneofs: {}
          };
          if (!b.NAME.test(e)) throw Error('illegal ' + (d ? 'group' : 'message') + ' name: ' + e);

          for (f.name = e, d && (this.tn.skip('='), c.id = h(this.tn.next()), f.isGroup = !0), e = this.tn.peek(), e === '[' && c && this._parseFieldOptions(c), this.tn.skip('{'); (e = this.tn.next()) !== '}';) {
            if (b.RULE.test(e)) this._parseMessageField(f, e);else if (e === 'oneof') this._parseMessageOneOf(f);else if (e === 'enum') this._parseEnum(f);else if (e === 'message') this._parseMessage(f);else if (e === 'option') this._parseOption(f);else if (e === 'service') this._parseService(f);else if (e === 'extensions') f.extensions = this._parseExtensionRanges();else if (e === 'reserved') this._parseIgnored();else if (e === 'extend') this._parseExtend(f);else {
              if (!b.TYPEREF.test(e)) throw Error('illegal message token: ' + e);
              if (!this.proto3) throw Error('illegal field rule: ' + e);

              this._parseMessageField(f, 'optional', e);
            }
          }

          return this.tn.omit(';'), a.messages.push(f), f;
        }, g._parseIgnored = function () {
          for (; this.tn.peek() !== ';';) {
            this.tn.next();
          }

          this.tn.skip(';');
        }, g._parseMessageField = function (a, c, d) {
          var e, f, g;
          if (!b.RULE.test(c)) throw Error('illegal message field rule: ' + c);

          if (e = {
            rule: c,
            type: '',
            name: '',
            options: {},
            id: 0
          }, c === 'map') {
            if (d) throw Error('illegal type: ' + d);
            if (this.tn.skip('<'), f = this.tn.next(), !b.TYPE.test(f) && !b.TYPEREF.test(f)) throw Error('illegal message field type: ' + f);
            if (e.keytype = f, this.tn.skip(','), f = this.tn.next(), !b.TYPE.test(f) && !b.TYPEREF.test(f)) throw Error('illegal message field: ' + f);
            if (e.type = f, this.tn.skip('>'), f = this.tn.next(), !b.NAME.test(f)) throw Error('illegal message field name: ' + f);
            e.name = f, this.tn.skip('='), e.id = h(this.tn.next()), f = this.tn.peek(), f === '[' && this._parseFieldOptions(e), this.tn.skip(';');
          } else if (d = typeof d !== 'undefined' ? d : this.tn.next(), d === 'group') {
            if (g = this._parseMessage(a, e), !/^[A-Z]/.test(g.name)) throw Error('illegal group name: ' + g.name);
            e.type = g.name, e.name = g.name.toLowerCase(), this.tn.omit(';');
          } else {
            if (!b.TYPE.test(d) && !b.TYPEREF.test(d)) throw Error('illegal message field type: ' + d);
            if (e.type = d, f = this.tn.next(), !b.NAME.test(f)) throw Error('illegal message field name: ' + f);
            e.name = f, this.tn.skip('='), e.id = h(this.tn.next()), f = this.tn.peek(), f === '[' && this._parseFieldOptions(e), this.tn.skip(';');
          }

          return a.fields.push(e), e;
        }, g._parseMessageOneOf = function (a) {
          var e;
          var d;
          var f;
          var c = this.tn.next();
          if (!b.NAME.test(c)) throw Error('illegal oneof name: ' + c);

          for (d = c, f = [], this.tn.skip('{'); (c = this.tn.next()) !== '}';) {
            e = this._parseMessageField(a, 'optional', c), e.oneof = d, f.push(e.id);
          }

          this.tn.omit(';'), a.oneofs[d] = f;
        }, g._parseFieldOptions = function (a) {
          this.tn.skip('[');

          for (var c = !0; (this.tn.peek()) !== ']';) {
            c || this.tn.skip(','), this._parseOption(a, !0), c = !1;
          }

          this.tn.next();
        }, g._parseEnum = function (a) {
          var e;
          var c = {
            name: '',
            values: [],
            options: {}
          };
          var d = this.tn.next();
          if (!b.NAME.test(d)) throw Error('illegal name: ' + d);

          for (c.name = d, this.tn.skip('{'); (d = this.tn.next()) !== '}';) {
            if (d === 'option') this._parseOption(c);else {
              if (!b.NAME.test(d)) throw Error('illegal name: ' + d);
              this.tn.skip('='), e = {
                name: d,
                id: h(this.tn.next(), !0)
              }, d = this.tn.peek(), d === '[' && this._parseFieldOptions({
                options: {}
              }), this.tn.skip(';'), c.values.push(e);
            }
          }

          this.tn.omit(';'), a.enums.push(c);
        }, g._parseExtensionRanges = function () {
          var c;
          var d;
          var e;
          var b = [];

          do {
            for (d = [];;) {
              switch (c = this.tn.next()) {
                case 'min':
                  e = a.ID_MIN;
                  break;

                case 'max':
                  e = a.ID_MAX;
                  break;

                default:
                  e = i(c);
              }

              if (d.push(e), d.length === 2) break;

              if (this.tn.peek() !== 'to') {
                d.push(e);
                break;
              }

              this.tn.next();
            }

            b.push(d);
          } while (this.tn.omit(','));

          return this.tn.skip(';'), b;
        }, g._parseExtend = function (a) {
          var d;
          var c = this.tn.next();
          if (!b.TYPEREF.test(c)) throw Error('illegal extend reference: ' + c);

          for (d = {
            ref: c,
            fields: []
          }, this.tn.skip('{'); (c = this.tn.next()) !== '}';) {
            if (b.RULE.test(c)) this._parseMessageField(d, c);else {
              if (!b.TYPEREF.test(c)) throw Error('illegal extend token: ' + c);
              if (!this.proto3) throw Error('illegal field rule: ' + c);

              this._parseMessageField(d, 'optional', c);
            }
          }

          return this.tn.omit(';'), a.messages.push(d), d;
        }, g.toString = function () {
          return 'Parser at line ' + this.tn.line;
        }, c.Parser = f, c;
      }(e, e.Lang), e.Reflect = function (a) {
        function k(b) {
          if (typeof b === 'string' && (b = a.TYPES[b]), typeof b.defaultValue === 'undefined') throw Error('default value for type ' + b.name + ' is not supported');
          return b == a.TYPES.bytes ? new f(0) : b.defaultValue;
        }

        function l(b, c) {
          if (b && typeof b.low === 'number' && typeof b.high === 'number' && typeof b.unsigned === 'boolean' && b.low === b.low && b.high === b.high) return new a.Long(b.low, b.high, typeof c === 'undefined' ? b.unsigned : c);
          if (typeof b === 'string') return a.Long.fromString(b, c || !1, 10);
          if (typeof b === 'number') return a.Long.fromNumber(b, c || !1);
          throw Error('not convertible to Long');
        }

        function o(b, c) {
          var d = c.readVarint32();
          var e = 7 & d;
          var f = d >>> 3;

          switch (e) {
            case a.WIRE_TYPES.VARINT:
              do {
                d = c.readUint8();
              } while ((128 & d) === 128);

              break;

            case a.WIRE_TYPES.BITS64:
              c.offset += 8;
              break;

            case a.WIRE_TYPES.LDELIM:
              d = c.readVarint32(), c.offset += d;
              break;

            case a.WIRE_TYPES.STARTGROUP:
              o(f, c);
              break;

            case a.WIRE_TYPES.ENDGROUP:
              if (f === b) return !1;
              throw Error('Illegal GROUPEND after unknown group: ' + f + ' (' + b + ' expected)');

            case a.WIRE_TYPES.BITS32:
              c.offset += 4;
              break;

            default:
              throw Error('Illegal wire type in unknown group ' + b + ': ' + e);
          }

          return !0;
        }

        var g;
        var h;
        var i;
        var j;
        var m;
        var n;
        var p;
        var q;
        var r;
        var s;
        var t;
        var u;
        var v;
        var w;
        var x;
        var y;
        var z;
        var A;
        var B;
        var c = {};

        var d = function d(a, b, c) {
          this.builder = a, this.parent = b, this.name = c, this.className;
        };

        var e = d.prototype;
        return e.fqn = function () {
          for (var a = this.name, b = this;;) {
            if (b = b.parent, b == null) break;
            a = b.name + '.' + a;
          }

          return a;
        }, e.toString = function (a) {
          return (a ? this.className + ' ' : '') + this.fqn();
        }, e.build = function () {
          throw Error(this.toString(!0) + ' cannot be built directly');
        }, c.T = d, g = function g(a, b, c, e, f) {
          d.call(this, a, b, c), this.className = 'Namespace', this.children = [], this.options = e || {}, this.syntax = f || 'proto2';
        }, h = g.prototype = Object.create(d.prototype), h.getChildren = function (a) {
          var b, c, d;
          if (a = a || null, a == null) return this.children.slice();

          for (b = [], c = 0, d = this.children.length; d > c; ++c) {
            this.children[c] instanceof a && b.push(this.children[c]);
          }

          return b;
        }, h.addChild = function (a) {
          var b;
          if (b = this.getChild(a.name)) if (b instanceof m.Field && b.name !== b.originalName && this.getChild(b.originalName) === null) b.name = b.originalName;else {
            if (!(a instanceof m.Field && a.name !== a.originalName && this.getChild(a.originalName) === null)) throw Error('Duplicate name in namespace ' + this.toString(!0) + ': ' + a.name);
            a.name = a.originalName;
          }
          this.children.push(a);
        }, h.getChild = function (a) {
          var c;
          var d;
          var b = typeof a === 'number' ? 'id' : 'name';

          for (c = 0, d = this.children.length; d > c; ++c) {
            if (this.children[c][b] === a) return this.children[c];
          }

          return null;
        }, h.resolve = function (a, b) {
          var g;
          var d = typeof a === 'string' ? a.split('.') : a;
          var e = this;
          var f = 0;

          if (d[f] === '') {
            for (; e.parent !== null;) {
              e = e.parent;
            }

            f++;
          }

          do {
            do {
              if (!(e instanceof c.Namespace)) {
                e = null;
                break;
              }

              if (g = e.getChild(d[f]), !(g && g instanceof c.T && (!b || g instanceof c.Namespace))) {
                e = null;
                break;
              }

              e = g, f++;
            } while (f < d.length);

            if (e != null) break;
            if (this.parent !== null) return this.parent.resolve(a, b);
          } while (e != null);

          return e;
        }, h.qn = function (a) {
          var e;
          var f;
          var b = [];
          var d = a;

          do {
            b.unshift(d.name), d = d.parent;
          } while (d !== null);

          for (e = 1; e <= b.length; e++) {
            if (f = b.slice(b.length - e), a === this.resolve(f, a instanceof c.Namespace)) return f.join('.');
          }

          return a.fqn();
        }, h.build = function () {
          var e;
          var c;
          var d;
          var a = {};
          var b = this.children;

          for (c = 0, d = b.length; d > c; ++c) {
            e = b[c], e instanceof g && (a[e.name] = e.build());
          }

          return Object.defineProperty && Object.defineProperty(a, '$options', {
            value: this.buildOpt()
          }), a;
        }, h.buildOpt = function () {
          var c;
          var d;
          var e;
          var f;
          var a = {};
          var b = Object.keys(this.options);

          for (c = 0, d = b.length; d > c; ++c) {
            e = b[c], f = this.options[b[c]], a[e] = f;
          }

          return a;
        }, h.getOption = function (a) {
          return typeof a === 'undefined' ? this.options : typeof this.options[a] !== 'undefined' ? this.options[a] : null;
        }, c.Namespace = g, i = function i(b, c, d, e) {
          if (this.type = b, this.resolvedType = c, this.isMapKey = d, this.syntax = e, d && a.MAP_KEY_TYPES.indexOf(b) < 0) throw Error('Invalid map key type: ' + b.name);
        }, j = i.prototype, i.defaultFieldValue = k, j.verifyValue = function (c) {
          var f;
          var g;
          var h;

          var d = function (a, b) {
            throw Error('Illegal value for ' + this.toString(!0) + ' of type ' + this.type.name + ': ' + a + ' (' + b + ')');
          }.bind(this);

          switch (this.type) {
            case a.TYPES.int32:
            case a.TYPES.sint32:
            case a.TYPES.sfixed32:
              return (typeof c !== 'number' || c === c && c % 1 !== 0) && d(_typeof(c), 'not an integer'), c > 4294967295 ? 0 | c : c;

            case a.TYPES.uint32:
            case a.TYPES.fixed32:
              return (typeof c !== 'number' || c === c && c % 1 !== 0) && d(_typeof(c), 'not an integer'), c < 0 ? c >>> 0 : c;

            case a.TYPES.int64:
            case a.TYPES.sint64:
            case a.TYPES.sfixed64:
              if (a.Long) try {
                return l(c, !1);
              } catch (e) {
                d(_typeof(c), e.message);
              } else d(_typeof(c), 'requires Long.js');

            case a.TYPES.uint64:
            case a.TYPES.fixed64:
              if (a.Long) try {
                return l(c, !0);
              } catch (e) {
                d(_typeof(c), e.message);
              } else d(_typeof(c), 'requires Long.js');

            case a.TYPES.bool:
              return typeof c !== 'boolean' && d(_typeof(c), 'not a boolean'), c;

            case a.TYPES.float:
            case a.TYPES.double:
              return typeof c !== 'number' && d(_typeof(c), 'not a number'), c;

            case a.TYPES.string:
              return typeof c === 'string' || c && c instanceof String || d(_typeof(c), 'not a string'), '' + c;

            case a.TYPES.bytes:
              return b.isByteBuffer(c) ? c : b.wrap(c);

            case a.TYPES.enum:
              for (f = this.resolvedType.getChildren(a.Reflect.Enum.Value), h = 0; h < f.length; h++) {
                if (f[h].name == c) return f[h].id;
                if (f[h].id == c) return f[h].id;
              }

              if (this.syntax === 'proto3') return (typeof c !== 'number' || c === c && c % 1 !== 0) && d(_typeof(c), 'not an integer'), (c > 4294967295 || c < 0) && d(_typeof(c), 'not in range for uint32'), c;
              d(c, 'not a valid enum value');

            case a.TYPES.group:
            case a.TYPES.message:
              if (c && _typeof(c) === 'object' || d(_typeof(c), 'object expected'), c instanceof this.resolvedType.clazz) return c;

              if (c instanceof a.Builder.Message) {
                g = {};

                for (h in c) {
                  c.hasOwnProperty(h) && (g[h] = c[h]);
                }

                c = g;
              }

              return new this.resolvedType.clazz(c);
          }

          throw Error('[INTERNAL] Illegal value for ' + this.toString(!0) + ': ' + c + ' (undefined type ' + this.type + ')');
        }, j.calculateLength = function (b, c) {
          if (c === null) return 0;
          var d;

          switch (this.type) {
            case a.TYPES.int32:
              return c < 0 ? f.calculateVarint64(c) : f.calculateVarint32(c);

            case a.TYPES.uint32:
              return f.calculateVarint32(c);

            case a.TYPES.sint32:
              return f.calculateVarint32(f.zigZagEncode32(c));

            case a.TYPES.fixed32:
            case a.TYPES.sfixed32:
            case a.TYPES.float:
              return 4;

            case a.TYPES.int64:
            case a.TYPES.uint64:
              return f.calculateVarint64(c);

            case a.TYPES.sint64:
              return f.calculateVarint64(f.zigZagEncode64(c));

            case a.TYPES.fixed64:
            case a.TYPES.sfixed64:
              return 8;

            case a.TYPES.bool:
              return 1;

            case a.TYPES.enum:
              return f.calculateVarint32(c);

            case a.TYPES.double:
              return 8;

            case a.TYPES.string:
              return d = f.calculateUTF8Bytes(c), f.calculateVarint32(d) + d;

            case a.TYPES.bytes:
              if (c.remaining() < 0) throw Error('Illegal value for ' + this.toString(!0) + ': ' + c.remaining() + ' bytes remaining');
              return f.calculateVarint32(c.remaining()) + c.remaining();

            case a.TYPES.message:
              return d = this.resolvedType.calculate(c), f.calculateVarint32(d) + d;

            case a.TYPES.group:
              return d = this.resolvedType.calculate(c), d + f.calculateVarint32(b << 3 | a.WIRE_TYPES.ENDGROUP);
          }

          throw Error('[INTERNAL] Illegal value to encode in ' + this.toString(!0) + ': ' + c + ' (unknown type)');
        }, j.encodeValue = function (b, c, d) {
          var e, g;
          if (c === null) return d;

          switch (this.type) {
            case a.TYPES.int32:
              c < 0 ? d.writeVarint64(c) : d.writeVarint32(c);
              break;

            case a.TYPES.uint32:
              d.writeVarint32(c);
              break;

            case a.TYPES.sint32:
              d.writeVarint32ZigZag(c);
              break;

            case a.TYPES.fixed32:
              d.writeUint32(c);
              break;

            case a.TYPES.sfixed32:
              d.writeInt32(c);
              break;

            case a.TYPES.int64:
            case a.TYPES.uint64:
              d.writeVarint64(c);
              break;

            case a.TYPES.sint64:
              d.writeVarint64ZigZag(c);
              break;

            case a.TYPES.fixed64:
              d.writeUint64(c);
              break;

            case a.TYPES.sfixed64:
              d.writeInt64(c);
              break;

            case a.TYPES.bool:
              typeof c === 'string' ? d.writeVarint32(c.toLowerCase() === 'false' ? 0 : !!c) : d.writeVarint32(c ? 1 : 0);
              break;

            case a.TYPES.enum:
              d.writeVarint32(c);
              break;

            case a.TYPES.float:
              d.writeFloat32(c);
              break;

            case a.TYPES.double:
              d.writeFloat64(c);
              break;

            case a.TYPES.string:
              d.writeVString(c);
              break;

            case a.TYPES.bytes:
              if (c.remaining() < 0) throw Error('Illegal value for ' + this.toString(!0) + ': ' + c.remaining() + ' bytes remaining');
              e = c.offset, d.writeVarint32(c.remaining()), d.append(c), c.offset = e;
              break;

            case a.TYPES.message:
              g = new f().LE(), this.resolvedType.encode(c, g), d.writeVarint32(g.offset), d.append(g.flip());
              break;

            case a.TYPES.group:
              this.resolvedType.encode(c, d), d.writeVarint32(b << 3 | a.WIRE_TYPES.ENDGROUP);
              break;

            default:
              throw Error('[INTERNAL] Illegal value to encode in ' + this.toString(!0) + ': ' + c + ' (unknown type)');
          }

          return d;
        }, j.decode = function (b, c, d) {
          if (c != this.type.wireType) throw Error('Unexpected wire type for element');
          var e, f;

          switch (this.type) {
            case a.TYPES.int32:
              return 0 | b.readVarint32();

            case a.TYPES.uint32:
              return b.readVarint32() >>> 0;

            case a.TYPES.sint32:
              return 0 | b.readVarint32ZigZag();

            case a.TYPES.fixed32:
              return b.readUint32() >>> 0;

            case a.TYPES.sfixed32:
              return 0 | b.readInt32();

            case a.TYPES.int64:
              return b.readVarint64();

            case a.TYPES.uint64:
              return b.readVarint64().toUnsigned();

            case a.TYPES.sint64:
              return b.readVarint64ZigZag();

            case a.TYPES.fixed64:
              return b.readUint64();

            case a.TYPES.sfixed64:
              return b.readInt64();

            case a.TYPES.bool:
              return !!b.readVarint32();

            case a.TYPES.enum:
              return b.readVarint32();

            case a.TYPES.float:
              return b.readFloat();

            case a.TYPES.double:
              return b.readDouble();

            case a.TYPES.string:
              return b.readVString();

            case a.TYPES.bytes:
              if (f = b.readVarint32(), b.remaining() < f) throw Error('Illegal number of bytes for ' + this.toString(!0) + ': ' + f + ' required but got only ' + b.remaining());
              return e = b.clone(), e.limit = e.offset + f, b.offset += f, e;

            case a.TYPES.message:
              return f = b.readVarint32(), this.resolvedType.decode(b, f);

            case a.TYPES.group:
              return this.resolvedType.decode(b, -1, d);
          }

          throw Error('[INTERNAL] Illegal decode type');
        }, j.valueFromString = function (b) {
          if (!this.isMapKey) throw Error('valueFromString() called on non-map-key element');

          switch (this.type) {
            case a.TYPES.int32:
            case a.TYPES.sint32:
            case a.TYPES.sfixed32:
            case a.TYPES.uint32:
            case a.TYPES.fixed32:
              return this.verifyValue(parseInt(b));

            case a.TYPES.int64:
            case a.TYPES.sint64:
            case a.TYPES.sfixed64:
            case a.TYPES.uint64:
            case a.TYPES.fixed64:
              return this.verifyValue(b);

            case a.TYPES.bool:
              return b === 'true';

            case a.TYPES.string:
              return this.verifyValue(b);

            case a.TYPES.bytes:
              return f.fromBinary(b);
          }
        }, j.valueToString = function (b) {
          if (!this.isMapKey) throw Error('valueToString() called on non-map-key element');
          return this.type === a.TYPES.bytes ? b.toString('binary') : b.toString();
        }, c.Element = i, m = function m(a, b, c, d, e, f) {
          g.call(this, a, b, c, d, f), this.className = 'Message', this.extensions = void 0, this.clazz = null, this.isGroup = !!e, this._fields = null, this._fieldsById = null, this._fieldsByName = null;
        }, n = m.prototype = Object.create(g.prototype), n.build = function (c) {
          var d, h, e, g;
          if (this.clazz && !c) return this.clazz;

          for (d = function (a, c) {
            function k(b, c, d, e) {
              var g, h, i, j, l, m, n;
              if (b === null || _typeof(b) !== 'object') return e && e instanceof a.Reflect.Enum && (g = a.Reflect.Enum.getName(e.object, b), g !== null) ? g : b;
              if (f.isByteBuffer(b)) return c ? b.toBase64() : b.toBuffer();
              if (a.Long.isLong(b)) return d ? b.toString() : a.Long.fromValue(b);
              if (Array.isArray(b)) return h = [], b.forEach(function (a, b) {
                h[b] = k(a, c, d, e);
              }), h;

              if (h = {}, b instanceof a.Map) {
                for (i = b.entries(), j = i.next(); !j.done; j = i.next()) {
                  h[b.keyElem.valueToString(j.value[0])] = k(j.value[1], c, d, b.valueElem.resolvedType);
                }

                return h;
              }

              l = b.$type, m = void 0;

              for (n in b) {
                b.hasOwnProperty(n) && (h[n] = l && (m = l.getChild(n)) ? k(b[n], c, d, m.resolvedType) : k(b[n], c, d));
              }

              return h;
            }

            var i;
            var j;
            var d = c.getChildren(a.Reflect.Message.Field);
            var e = c.getChildren(a.Reflect.Message.OneOf);

            var g = function g(b) {
              var i, j, k, l;

              for (a.Builder.Message.call(this), i = 0, j = e.length; j > i; ++i) {
                this[e[i].name] = null;
              }

              for (i = 0, j = d.length; j > i; ++i) {
                k = d[i], this[k.name] = k.repeated ? [] : k.map ? new a.Map(k) : null, !k.required && c.syntax !== 'proto3' || k.defaultValue === null || (this[k.name] = k.defaultValue);
              }

              if (arguments.length > 0) if (arguments.length !== 1 || b === null || _typeof(b) !== 'object' || !(typeof b.encode !== 'function' || b instanceof g) || Array.isArray(b) || b instanceof a.Map || f.isByteBuffer(b) || b instanceof ArrayBuffer || a.Long && b instanceof a.Long) for (i = 0, j = arguments.length; j > i; ++i) {
                typeof (l = arguments[i]) !== 'undefined' && this.$set(d[i].name, l);
              } else this.$set(b);
            };

            var h = g.prototype = Object.create(a.Builder.Message.prototype);

            for (h.add = function (b, d, e) {
              var f = c._fieldsByName[b];

              if (!e) {
                if (!f) throw Error(this + '#' + b + ' is undefined');
                if (!(f instanceof a.Reflect.Message.Field)) throw Error(this + '#' + b + ' is not a field: ' + f.toString(!0));
                if (!f.repeated) throw Error(this + '#' + b + ' is not a repeated field');
                d = f.verifyValue(d, !0);
              }

              return this[b] === null && (this[b] = []), this[b].push(d), this;
            }, h.$add = h.add, h.set = function (b, d, e) {
              var f, g, h;

              if (b && _typeof(b) === 'object') {
                e = d;

                for (f in b) {
                  b.hasOwnProperty(f) && typeof (d = b[f]) !== 'undefined' && this.$set(f, d, e);
                }

                return this;
              }

              if (g = c._fieldsByName[b], e) this[b] = d;else {
                if (!g) throw Error(this + '#' + b + ' is not a field: undefined');
                if (!(g instanceof a.Reflect.Message.Field)) throw Error(this + '#' + b + ' is not a field: ' + g.toString(!0));
                this[g.name] = d = g.verifyValue(d);
              }
              return g && g.oneof && (h = this[g.oneof.name], d !== null ? (h !== null && h !== g.name && (this[h] = null), this[g.oneof.name] = g.name) : h === b && (this[g.oneof.name] = null)), this;
            }, h.$set = h.set, h.get = function (b, d) {
              if (d) return this[b];
              var e = c._fieldsByName[b];
              if (!(e && e instanceof a.Reflect.Message.Field)) throw Error(this + '#' + b + ' is not a field: undefined');
              if (!(e instanceof a.Reflect.Message.Field)) throw Error(this + '#' + b + ' is not a field: ' + e.toString(!0));
              return this[e.name];
            }, h.$get = h.get, i = 0; i < d.length; i++) {
              j = d[i], j instanceof a.Reflect.Message.ExtensionField || c.builder.options.populateAccessors && function (a) {
                var d;
                var e;
                var f;
                var b = a.originalName.replace(/(_[a-zA-Z])/g, function (a) {
                  return a.toUpperCase().replace('_', '');
                });
                b = b.substring(0, 1).toUpperCase() + b.substring(1), d = a.originalName.replace(/([A-Z])/g, function (a) {
                  return '_' + a;
                }), e = function e(b, c) {
                  return this[a.name] = c ? b : a.verifyValue(b), this;
                }, f = function f() {
                  return this[a.name];
                }, c.getChild('set' + b) === null && (h['set' + b] = e), c.getChild('set_' + d) === null && (h['set_' + d] = e), c.getChild('get' + b) === null && (h['get' + b] = f), c.getChild('get_' + d) === null && (h['get_' + d] = f);
              }(j);
            }

            return h.encode = function (a, d) {
              var e, f;
              typeof a === 'boolean' && (d = a, a = void 0), e = !1, a || (a = new b(), e = !0), f = a.littleEndian;

              try {
                return c.encode(this, a.LE(), d), (e ? a.flip() : a).LE(f);
              } catch (g) {
                throw a.LE(f), g;
              }
            }, g.encode = function (a, b, c) {
              return new g(a).encode(b, c);
            }, h.calculate = function () {
              return c.calculate(this);
            }, h.encodeDelimited = function (a) {
              var d;
              var b = !1;
              return a || (a = new f(), b = !0), d = new f().LE(), c.encode(this, d).flip(), a.writeVarint32(d.remaining()), a.append(d), b ? a.flip() : a;
            }, h.encodeAB = function () {
              try {
                return this.encode().toArrayBuffer();
              } catch (a) {
                throw a.encoded && (a.encoded = a.encoded.toArrayBuffer()), a;
              }
            }, h.toArrayBuffer = h.encodeAB, h.encodeNB = function () {
              try {
                return this.encode().toBuffer();
              } catch (a) {
                throw a.encoded && (a.encoded = a.encoded.toBuffer()), a;
              }
            }, h.toBuffer = h.encodeNB, h.encode64 = function () {
              try {
                return this.encode().toBase64();
              } catch (a) {
                throw a.encoded && (a.encoded = a.encoded.toBase64()), a;
              }
            }, h.toBase64 = h.encode64, h.encodeHex = function () {
              try {
                return this.encode().toHex();
              } catch (a) {
                throw a.encoded && (a.encoded = a.encoded.toHex()), a;
              }
            }, h.toHex = h.encodeHex, h.toRaw = function (a, b) {
              return k(this, !!a, !!b, this.$type);
            }, h.encodeJSON = function () {
              return JSON.stringify(k(this, !0, !0, this.$type));
            }, g.decode = function (a, b) {
              var d, e;
              typeof a === 'string' && (a = f.wrap(a, b || 'base64')), a = f.isByteBuffer(a) ? a : f.wrap(a), d = a.littleEndian;

              try {
                return e = c.decode(a.LE()), a.LE(d), e;
              } catch (g) {
                throw a.LE(d), g;
              }
            }, g.decodeDelimited = function (a, b) {
              var d, e, g;
              if (typeof a === 'string' && (a = f.wrap(a, b || 'base64')), a = f.isByteBuffer(a) ? a : f.wrap(a), a.remaining() < 1) return null;
              if (d = a.offset, e = a.readVarint32(), a.remaining() < e) return a.offset = d, null;

              try {
                return g = c.decode(a.slice(a.offset, a.offset + e).LE()), a.offset += e, g;
              } catch (h) {
                throw a.offset += e, h;
              }
            }, g.decode64 = function (a) {
              return g.decode(a, 'base64');
            }, g.decodeHex = function (a) {
              return g.decode(a, 'hex');
            }, g.decodeJSON = function (a) {
              return new g(JSON.parse(a));
            }, h.toString = function () {
              return c.toString();
            }, Object.defineProperty && (Object.defineProperty(g, '$options', {
              value: c.buildOpt()
            }), Object.defineProperty(h, '$options', {
              value: g.$options
            }), Object.defineProperty(g, '$type', {
              value: c
            }), Object.defineProperty(h, '$type', {
              value: c
            })), g;
          }(a, this), this._fields = [], this._fieldsById = {}, this._fieldsByName = {}, e = 0, g = this.children.length; g > e; e++) {
            if (h = this.children[e], h instanceof t || h instanceof m || h instanceof x) {
              if (d.hasOwnProperty(h.name)) throw Error('Illegal reflect child of ' + this.toString(!0) + ': ' + h.toString(!0) + " cannot override static property '" + h.name + "'");
              d[h.name] = h.build();
            } else if (h instanceof m.Field) h.build(), this._fields.push(h), this._fieldsById[h.id] = h, this._fieldsByName[h.name] = h;else if (!(h instanceof m.OneOf || h instanceof w)) throw Error('Illegal reflect child of ' + this.toString(!0) + ': ' + this.children[e].toString(!0));
          }

          return this.clazz = d;
        }, n.encode = function (a, b, c) {
          var e;
          var h;
          var f;
          var g;
          var i;
          var d = null;

          for (f = 0, g = this._fields.length; g > f; ++f) {
            e = this._fields[f], h = a[e.name], e.required && h === null ? d === null && (d = e) : e.encode(c ? h : e.verifyValue(h), b, a);
          }

          if (d !== null) throw i = Error('Missing at least one required field for ' + this.toString(!0) + ': ' + d), i.encoded = b, i;
          return b;
        }, n.calculate = function (a) {
          for (var e, f, b = 0, c = 0, d = this._fields.length; d > c; ++c) {
            if (e = this._fields[c], f = a[e.name], e.required && f === null) throw Error('Missing at least one required field for ' + this.toString(!0) + ': ' + e);
            b += e.calculate(f, a);
          }

          return b;
        }, n.decode = function (b, c, d) {
          var g, h, i, j, e, f, k, l, m, n, p, q;

          for (c = typeof c === 'number' ? c : -1, e = b.offset, f = new this.clazz(); b.offset < e + c || c === -1 && b.remaining() > 0;) {
            if (g = b.readVarint32(), h = 7 & g, i = g >>> 3, h === a.WIRE_TYPES.ENDGROUP) {
              if (i !== d) throw Error('Illegal group end indicator for ' + this.toString(!0) + ': ' + i + ' (' + (d ? d + ' expected' : 'not a group') + ')');
              break;
            }

            if (j = this._fieldsById[i]) j.repeated && !j.options.packed ? f[j.name].push(j.decode(h, b)) : j.map ? (l = j.decode(h, b), f[j.name].set(l[0], l[1])) : (f[j.name] = j.decode(h, b), j.oneof && (m = f[j.oneof.name], m !== null && m !== j.name && (f[m] = null), f[j.oneof.name] = j.name));else switch (h) {
              case a.WIRE_TYPES.VARINT:
                b.readVarint32();
                break;

              case a.WIRE_TYPES.BITS32:
                b.offset += 4;
                break;

              case a.WIRE_TYPES.BITS64:
                b.offset += 8;
                break;

              case a.WIRE_TYPES.LDELIM:
                k = b.readVarint32(), b.offset += k;
                break;

              case a.WIRE_TYPES.STARTGROUP:
                for (; o(i, b);) {
                }

                break;

              default:
                throw Error('Illegal wire type for unknown field ' + i + ' in ' + this.toString(!0) + '#decode: ' + h);
            }
          }

          for (n = 0, p = this._fields.length; p > n; ++n) {
            if (j = this._fields[n], f[j.name] === null) if (this.syntax === 'proto3') f[j.name] = j.defaultValue;else {
              if (j.required) throw q = Error('Missing at least one required field for ' + this.toString(!0) + ': ' + j.name), q.decoded = f, q;
              a.populateDefaults && j.defaultValue !== null && (f[j.name] = j.defaultValue);
            }
          }

          return f;
        }, c.Message = m, p = function p(b, c, e, f, g, h, i, j, k, l) {
          d.call(this, b, c, h), this.className = 'Message.Field', this.required = e === 'required', this.repeated = e === 'repeated', this.map = e === 'map', this.keyType = f || null, this.type = g, this.resolvedType = null, this.id = i, this.options = j || {}, this.defaultValue = null, this.oneof = k || null, this.syntax = l || 'proto2', this.originalName = this.name, this.element = null, this.keyElement = null, !this.builder.options.convertFieldsToCamelCase || this instanceof m.ExtensionField || (this.name = a.Util.toCamelCase(this.name));
        }, q = p.prototype = Object.create(d.prototype), q.build = function () {
          this.element = new i(this.type, this.resolvedType, !1, this.syntax), this.map && (this.keyElement = new i(this.keyType, void 0, !0, this.syntax)), this.syntax !== 'proto3' || this.repeated || this.map ? typeof this.options.default !== 'undefined' && (this.defaultValue = this.verifyValue(this.options.default)) : this.defaultValue = i.defaultFieldValue(this.type);
        }, q.verifyValue = function (b, c) {
          var d, e, f;
          if (c = c || !1, d = function (a, b) {
            throw Error('Illegal value for ' + this.toString(!0) + ' of type ' + this.type.name + ': ' + a + ' (' + b + ')');
          }.bind(this), b === null) return this.required && d(_typeof(b), 'required'), this.syntax === 'proto3' && this.type !== a.TYPES.message && d(_typeof(b), 'proto3 field without field presence cannot be null'), null;

          if (this.repeated && !c) {
            for (Array.isArray(b) || (b = [b]), f = [], e = 0; e < b.length; e++) {
              f.push(this.element.verifyValue(b[e]));
            }

            return f;
          }

          return this.map && !c ? b instanceof a.Map ? b : (b instanceof Object || d(_typeof(b), 'expected ProtoBuf.Map or raw object for map field'), new a.Map(this, b)) : (!this.repeated && Array.isArray(b) && d(_typeof(b), 'no array expected'), this.element.verifyValue(b));
        }, q.hasWirePresence = function (b, c) {
          if (this.syntax !== 'proto3') return b !== null;
          if (this.oneof && c[this.oneof.name] === this.name) return !0;

          switch (this.type) {
            case a.TYPES.int32:
            case a.TYPES.sint32:
            case a.TYPES.sfixed32:
            case a.TYPES.uint32:
            case a.TYPES.fixed32:
              return b !== 0;

            case a.TYPES.int64:
            case a.TYPES.sint64:
            case a.TYPES.sfixed64:
            case a.TYPES.uint64:
            case a.TYPES.fixed64:
              return b.low !== 0 || b.high !== 0;

            case a.TYPES.bool:
              return b;

            case a.TYPES.float:
            case a.TYPES.double:
              return b !== 0;

            case a.TYPES.string:
              return b.length > 0;

            case a.TYPES.bytes:
              return b.remaining() > 0;

            case a.TYPES.enum:
              return b !== 0;

            case a.TYPES.message:
              return b !== null;

            default:
              return !0;
          }
        }, q.encode = function (b, c, d) {
          var e, g, h, i, j;
          if (this.type === null || _typeof(this.type) !== 'object') throw Error('[INTERNAL] Unresolved type in ' + this.toString(!0) + ': ' + this.type);
          if (b === null || this.repeated && b.length == 0) return c;

          try {
            if (this.repeated) {
              if (this.options.packed && a.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                for (c.writeVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM), c.ensureCapacity(c.offset += 1), g = c.offset, e = 0; e < b.length; e++) {
                  this.element.encodeValue(this.id, b[e], c);
                }

                h = c.offset - g, i = f.calculateVarint32(h), i > 1 && (j = c.slice(g, c.offset), g += i - 1, c.offset = g, c.append(j)), c.writeVarint32(h, g - i);
              } else for (e = 0; e < b.length; e++) {
                c.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, b[e], c);
              }
            } else this.map ? b.forEach(function (b, d) {
              var g = f.calculateVarint32(8 | this.keyType.wireType) + this.keyElement.calculateLength(1, d) + f.calculateVarint32(16 | this.type.wireType) + this.element.calculateLength(2, b);
              c.writeVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM), c.writeVarint32(g), c.writeVarint32(8 | this.keyType.wireType), this.keyElement.encodeValue(1, d, c), c.writeVarint32(16 | this.type.wireType), this.element.encodeValue(2, b, c);
            }, this) : this.hasWirePresence(b, d) && (c.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, b, c));
          } catch (k) {
            throw Error('Illegal value for ' + this.toString(!0) + ': ' + b + ' (' + k + ')');
          }

          return c;
        }, q.calculate = function (b, c) {
          var d, e, g;
          if (b = this.verifyValue(b), this.type === null || _typeof(this.type) !== 'object') throw Error('[INTERNAL] Unresolved type in ' + this.toString(!0) + ': ' + this.type);
          if (b === null || this.repeated && b.length == 0) return 0;
          d = 0;

          try {
            if (this.repeated) {
              if (this.options.packed && a.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                for (d += f.calculateVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM), g = 0, e = 0; e < b.length; e++) {
                  g += this.element.calculateLength(this.id, b[e]);
                }

                d += f.calculateVarint32(g), d += g;
              } else for (e = 0; e < b.length; e++) {
                d += f.calculateVarint32(this.id << 3 | this.type.wireType), d += this.element.calculateLength(this.id, b[e]);
              }
            } else this.map ? b.forEach(function (b, c) {
              var g = f.calculateVarint32(8 | this.keyType.wireType) + this.keyElement.calculateLength(1, c) + f.calculateVarint32(16 | this.type.wireType) + this.element.calculateLength(2, b);
              d += f.calculateVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM), d += f.calculateVarint32(g), d += g;
            }, this) : this.hasWirePresence(b, c) && (d += f.calculateVarint32(this.id << 3 | this.type.wireType), d += this.element.calculateLength(this.id, b));
          } catch (h) {
            throw Error('Illegal value for ' + this.toString(!0) + ': ' + b + ' (' + h + ')');
          }

          return d;
        }, q.decode = function (b, c, d) {
          var e;
          var f;
          var h;
          var j;
          var k;
          var l;
          var m;
          var g = !this.map && b == this.type.wireType || !d && this.repeated && this.options.packed && b == a.WIRE_TYPES.LDELIM || this.map && b == a.WIRE_TYPES.LDELIM;
          if (!g) throw Error('Illegal wire type for field ' + this.toString(!0) + ': ' + b + ' (' + this.type.wireType + ' expected)');

          if (b == a.WIRE_TYPES.LDELIM && this.repeated && this.options.packed && a.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0 && !d) {
            for (f = c.readVarint32(), f = c.offset + f, h = []; c.offset < f;) {
              h.push(this.decode(this.type.wireType, c, !0));
            }

            return h;
          }

          if (this.map) {
            if (j = i.defaultFieldValue(this.keyType), e = i.defaultFieldValue(this.type), f = c.readVarint32(), c.remaining() < f) throw Error('Illegal number of bytes for ' + this.toString(!0) + ': ' + f + ' required but got only ' + c.remaining());

            for (k = c.clone(), k.limit = k.offset + f, c.offset += f; k.remaining() > 0;) {
              if (l = k.readVarint32(), b = 7 & l, m = l >>> 3, m === 1) j = this.keyElement.decode(k, b, m);else {
                if (m !== 2) throw Error('Unexpected tag in map field key/value submessage');
                e = this.element.decode(k, b, m);
              }
            }

            return [j, e];
          }

          return this.element.decode(c, b, this.id);
        }, c.Message.Field = p, r = function r(a, b, c, d, e, f, g) {
          p.call(this, a, b, c, null, d, e, f, g), this.extension;
        }, r.prototype = Object.create(p.prototype), c.Message.ExtensionField = r, s = function s(a, b, c) {
          d.call(this, a, b, c), this.fields = [];
        }, c.Message.OneOf = s, t = function t(a, b, c, d, e) {
          g.call(this, a, b, c, d, e), this.className = 'Enum', this.object = null;
        }, t.getName = function (a, b) {
          var e;
          var d;
          var c = Object.keys(a);

          for (d = 0; d < c.length; ++d) {
            if (a[e = c[d]] === b) return e;
          }

          return null;
        }, u = t.prototype = Object.create(g.prototype), u.build = function (b) {
          var c, d, e, f;
          if (this.object && !b) return this.object;

          for (c = new a.Builder.Enum(), d = this.getChildren(t.Value), e = 0, f = d.length; f > e; ++e) {
            c[d[e].name] = d[e].id;
          }

          return Object.defineProperty && Object.defineProperty(c, '$options', {
            value: this.buildOpt(),
            enumerable: !1
          }), this.object = c;
        }, c.Enum = t, v = function v(a, b, c, e) {
          d.call(this, a, b, c), this.className = 'Enum.Value', this.id = e;
        }, v.prototype = Object.create(d.prototype), c.Enum.Value = v, w = function w(a, b, c, e) {
          d.call(this, a, b, c), this.field = e;
        }, w.prototype = Object.create(d.prototype), c.Extension = w, x = function x(a, b, c, d) {
          g.call(this, a, b, c, d), this.className = 'Service', this.clazz = null;
        }, y = x.prototype = Object.create(g.prototype), y.build = function (b) {
          return this.clazz && !b ? this.clazz : this.clazz = function (a, b) {
            var g;

            var c = function c(b) {
              a.Builder.Service.call(this), this.rpcImpl = b || function (a, b, c) {
                setTimeout(c.bind(this, Error('Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services')), 0);
              };
            };

            var d = c.prototype = Object.create(a.Builder.Service.prototype);
            var e = b.getChildren(a.Reflect.Service.RPCMethod);

            for (g = 0; g < e.length; g++) {
              !function (a) {
                d[a.name] = function (c, d) {
                  try {
                    try {
                      c = a.resolvedRequestType.clazz.decode(f.wrap(c));
                    } catch (e) {
                      if (!(e instanceof TypeError)) throw e;
                    }

                    if (c === null || _typeof(c) !== 'object') throw Error('Illegal arguments');
                    c instanceof a.resolvedRequestType.clazz || (c = new a.resolvedRequestType.clazz(c)), this.rpcImpl(a.fqn(), c, function (c, e) {
                      if (c) return d(c), void 0;

                      try {
                        e = a.resolvedResponseType.clazz.decode(e);
                      } catch (f) {}

                      return e && e instanceof a.resolvedResponseType.clazz ? (d(null, e), void 0) : (d(Error('Illegal response type received in service method ' + b.name + '#' + a.name)), void 0);
                    });
                  } catch (e) {
                    setTimeout(d.bind(this, e), 0);
                  }
                }, c[a.name] = function (b, d, e) {
                  new c(b)[a.name](d, e);
                }, Object.defineProperty && (Object.defineProperty(c[a.name], '$options', {
                  value: a.buildOpt()
                }), Object.defineProperty(d[a.name], '$options', {
                  value: c[a.name].$options
                }));
              }(e[g]);
            }

            return Object.defineProperty && (Object.defineProperty(c, '$options', {
              value: b.buildOpt()
            }), Object.defineProperty(d, '$options', {
              value: c.$options
            }), Object.defineProperty(c, '$type', {
              value: b
            }), Object.defineProperty(d, '$type', {
              value: b
            })), c;
          }(a, this);
        }, c.Service = x, z = function z(a, b, c, e) {
          d.call(this, a, b, c), this.className = 'Service.Method', this.options = e || {};
        }, A = z.prototype = Object.create(d.prototype), A.buildOpt = h.buildOpt, c.Service.Method = z, B = function B(a, b, c, d, e, f, g, h) {
          z.call(this, a, b, c, h), this.className = 'Service.RPCMethod', this.requestName = d, this.responseName = e, this.requestStream = f, this.responseStream = g, this.resolvedRequestType = null, this.resolvedResponseType = null;
        }, B.prototype = Object.create(z.prototype), c.Service.RPCMethod = B, c;
      }(e), e.Builder = function (a, b, c) {
        function f(a) {
          a.messages && a.messages.forEach(function (b) {
            b.syntax = a.syntax, f(b);
          }), a.enums && a.enums.forEach(function (b) {
            b.syntax = a.syntax;
          });
        }

        var d = function d(a) {
          this.ns = new c.Namespace(this, null, ''), this.ptr = this.ns, this.resolved = !1, this.result = null, this.files = {}, this.importRoot = null, this.options = a || {};
        };

        var e = d.prototype;
        return d.isMessage = function (a) {
          return typeof a.name !== 'string' ? !1 : typeof a.values !== 'undefined' || typeof a.rpc !== 'undefined' ? !1 : !0;
        }, d.isMessageField = function (a) {
          return typeof a.rule !== 'string' || typeof a.name !== 'string' || typeof a.type !== 'string' || typeof a.id === 'undefined' ? !1 : !0;
        }, d.isEnum = function (a) {
          return typeof a.name !== 'string' ? !1 : typeof a.values !== 'undefined' && Array.isArray(a.values) && a.values.length !== 0 ? !0 : !1;
        }, d.isService = function (a) {
          return typeof a.name === 'string' && _typeof(a.rpc) === 'object' && a.rpc ? !0 : !1;
        }, d.isExtend = function (a) {
          return typeof a.ref !== 'string' ? !1 : !0;
        }, e.reset = function () {
          return this.ptr = this.ns, this;
        }, e.define = function (a) {
          if (typeof a !== 'string' || !b.TYPEREF.test(a)) throw Error('illegal namespace: ' + a);
          return a.split('.').forEach(function (a) {
            var b = this.ptr.getChild(a);
            b === null && this.ptr.addChild(b = new c.Namespace(this, this.ptr, a)), this.ptr = b;
          }, this), this;
        }, e.create = function (b) {
          var e, f, g, h, i;
          if (!b) return this;

          if (Array.isArray(b)) {
            if (b.length === 0) return this;
            b = b.slice();
          } else b = [b];

          for (e = [b]; e.length > 0;) {
            if (b = e.pop(), !Array.isArray(b)) throw Error('not a valid namespace: ' + JSON.stringify(b));

            for (; b.length > 0;) {
              if (f = b.shift(), d.isMessage(f)) {
                if (g = new c.Message(this, this.ptr, f.name, f.options, f.isGroup, f.syntax), h = {}, f.oneofs && Object.keys(f.oneofs).forEach(function (a) {
                  g.addChild(h[a] = new c.Message.OneOf(this, g, a));
                }, this), f.fields && f.fields.forEach(function (a) {
                  if (g.getChild(0 | a.id) !== null) throw Error('duplicate or invalid field id in ' + g.name + ': ' + a.id);
                  if (a.options && _typeof(a.options) !== 'object') throw Error('illegal field options in ' + g.name + '#' + a.name);
                  var b = null;
                  if (typeof a.oneof === 'string' && !(b = h[a.oneof])) throw Error('illegal oneof in ' + g.name + '#' + a.name + ': ' + a.oneof);
                  a = new c.Message.Field(this, g, a.rule, a.keytype, a.type, a.name, a.id, a.options, b, f.syntax), b && b.fields.push(a), g.addChild(a);
                }, this), i = [], f.enums && f.enums.forEach(function (a) {
                  i.push(a);
                }), f.messages && f.messages.forEach(function (a) {
                  i.push(a);
                }), f.services && f.services.forEach(function (a) {
                  i.push(a);
                }), f.extensions && (g.extensions = typeof f.extensions[0] === 'number' ? [f.extensions] : f.extensions), this.ptr.addChild(g), i.length > 0) {
                  e.push(b), b = i, i = null, this.ptr = g, g = null;
                  continue;
                }

                i = null;
              } else if (d.isEnum(f)) g = new c.Enum(this, this.ptr, f.name, f.options, f.syntax), f.values.forEach(function (a) {
                g.addChild(new c.Enum.Value(this, g, a.name, a.id));
              }, this), this.ptr.addChild(g);else if (d.isService(f)) g = new c.Service(this, this.ptr, f.name, f.options), Object.keys(f.rpc).forEach(function (a) {
                var b = f.rpc[a];
                g.addChild(new c.Service.RPCMethod(this, g, a, b.request, b.response, !!b.request_stream, !!b.response_stream, b.options));
              }, this), this.ptr.addChild(g);else {
                if (!d.isExtend(f)) throw Error('not a valid definition: ' + JSON.stringify(f));

                if (g = this.ptr.resolve(f.ref, !0)) {
                  f.fields.forEach(function (b) {
                    var d, e, f, h;
                    if (g.getChild(0 | b.id) !== null) throw Error('duplicate extended field id in ' + g.name + ': ' + b.id);
                    if (g.extensions && (d = !1, g.extensions.forEach(function (a) {
                      b.id >= a[0] && b.id <= a[1] && (d = !0);
                    }), !d)) throw Error('illegal extended field id in ' + g.name + ': ' + b.id + ' (not within valid ranges)');
                    e = b.name, this.options.convertFieldsToCamelCase && (e = a.Util.toCamelCase(e)), f = new c.Message.ExtensionField(this, g, b.rule, b.type, this.ptr.fqn() + '.' + e, b.id, b.options), h = new c.Extension(this, this.ptr, b.name, f), f.extension = h, this.ptr.addChild(h), g.addChild(f);
                  }, this);
                } else if (!/\.?google\.protobuf\./.test(f.ref)) throw Error('extended message ' + f.ref + ' is not defined');
              }

              f = null, g = null;
            }

            b = null, this.ptr = this.ptr.parent;
          }

          return this.resolved = !1, this.result = null, this;
        }, e.import = function (b, c) {
          var e;
          var g;
          var h;
          var i;
          var j;
          var k;
          var l;
          var m;
          var d = '/';

          if (typeof c === 'string') {
            if (a.Util.IS_NODE, this.files[c] === !0) return this.reset();
            this.files[c] = !0;
          } else if (_typeof(c) === 'object') {
            if (e = c.root, a.Util.IS_NODE, (e.indexOf('\\') >= 0 || c.file.indexOf('\\') >= 0) && (d = '\\'), g = e + d + c.file, this.files[g] === !0) return this.reset();
            this.files[g] = !0;
          }

          if (b.imports && b.imports.length > 0) {
            for (i = !1, _typeof(c) === 'object' ? (this.importRoot = c.root, i = !0, h = this.importRoot, c = c.file, (h.indexOf('\\') >= 0 || c.indexOf('\\') >= 0) && (d = '\\')) : typeof c === 'string' ? this.importRoot ? h = this.importRoot : c.indexOf('/') >= 0 ? (h = c.replace(/\/[^\/]*$/, ''), h === '' && (h = '/')) : c.indexOf('\\') >= 0 ? (h = c.replace(/\\[^\\]*$/, ''), d = '\\') : h = '.' : h = null, j = 0; j < b.imports.length; j++) {
              if (typeof b.imports[j] === 'string') {
                if (!h) throw Error('cannot determine import root');
                if (k = b.imports[j], k === 'google/protobuf/descriptor.proto') continue;
                if (k = h + d + k, this.files[k] === !0) continue;
                if (/\.proto$/i.test(k) && !a.DotProto && (k = k.replace(/\.proto$/, '.json')), l = a.Util.fetch(k), l === null) throw Error("failed to import '" + k + "' in '" + c + "': file not found");
                /\.json$/i.test(k) ? this.import(JSON.parse(l + ''), k) : this.import(a.DotProto.Parser.parse(l), k);
              } else c ? /\.(\w+)$/.test(c) ? this.import(b.imports[j], c.replace(/^(.+)\.(\w+)$/, function (a, b, c) {
                return b + '_import' + j + '.' + c;
              })) : this.import(b.imports[j], c + '_import' + j) : this.import(b.imports[j]);
            }

            i && (this.importRoot = null);
          }

          return b.package && this.define(b.package), b.syntax && f(b), m = this.ptr, b.options && Object.keys(b.options).forEach(function (a) {
            m.options[a] = b.options[a];
          }), b.messages && (this.create(b.messages), this.ptr = m), b.enums && (this.create(b.enums), this.ptr = m), b.services && (this.create(b.services), this.ptr = m), b.extends && this.create(b.extends), this.reset();
        }, e.resolveAll = function () {
          var d;
          if (this.ptr == null || _typeof(this.ptr.type) === 'object') return this;
          if (this.ptr instanceof c.Namespace) this.ptr.children.forEach(function (a) {
            this.ptr = a, this.resolveAll();
          }, this);else if (this.ptr instanceof c.Message.Field) {
            if (b.TYPE.test(this.ptr.type)) this.ptr.type = a.TYPES[this.ptr.type];else {
              if (!b.TYPEREF.test(this.ptr.type)) throw Error('illegal type reference in ' + this.ptr.toString(!0) + ': ' + this.ptr.type);
              if (d = (this.ptr instanceof c.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, !0), !d) throw Error('unresolvable type reference in ' + this.ptr.toString(!0) + ': ' + this.ptr.type);

              if (this.ptr.resolvedType = d, d instanceof c.Enum) {
                if (this.ptr.type = a.TYPES.enum, this.ptr.syntax === 'proto3' && d.syntax !== 'proto3') throw Error('proto3 message cannot reference proto2 enum');
              } else {
                if (!(d instanceof c.Message)) throw Error('illegal type reference in ' + this.ptr.toString(!0) + ': ' + this.ptr.type);
                this.ptr.type = d.isGroup ? a.TYPES.group : a.TYPES.message;
              }
            }

            if (this.ptr.map) {
              if (!b.TYPE.test(this.ptr.keyType)) throw Error('illegal key type for map field in ' + this.ptr.toString(!0) + ': ' + this.ptr.keyType);
              this.ptr.keyType = a.TYPES[this.ptr.keyType];
            }
          } else if (this.ptr instanceof a.Reflect.Service.Method) {
            if (!(this.ptr instanceof a.Reflect.Service.RPCMethod)) throw Error('illegal service type in ' + this.ptr.toString(!0));
            if (d = this.ptr.parent.resolve(this.ptr.requestName, !0), !(d && d instanceof a.Reflect.Message)) throw Error('Illegal type reference in ' + this.ptr.toString(!0) + ': ' + this.ptr.requestName);
            if (this.ptr.resolvedRequestType = d, d = this.ptr.parent.resolve(this.ptr.responseName, !0), !(d && d instanceof a.Reflect.Message)) throw Error('Illegal type reference in ' + this.ptr.toString(!0) + ': ' + this.ptr.responseName);
            this.ptr.resolvedResponseType = d;
          } else if (!(this.ptr instanceof a.Reflect.Message.OneOf || this.ptr instanceof a.Reflect.Extension || this.ptr instanceof a.Reflect.Enum.Value)) throw Error('illegal object in namespace: ' + _typeof(this.ptr) + ': ' + this.ptr);
          return this.reset();
        }, e.build = function (a) {
          var b, c, d;
          if (this.reset(), this.resolved || (this.resolveAll(), this.resolved = !0, this.result = null), this.result === null && (this.result = this.ns.build()), !a) return this.result;

          for (b = typeof a === 'string' ? a.split('.') : a, c = this.result, d = 0; d < b.length; d++) {
            if (!c[b[d]]) {
              c = null;
              break;
            }

            c = c[b[d]];
          }

          return c;
        }, e.lookup = function (a, b) {
          return a ? this.ns.resolve(a, b) : this.ns;
        }, e.toString = function () {
          return 'Builder';
        }, d.Message = function () {}, d.Enum = function () {}, d.Service = function () {}, d;
      }(e, e.Lang, e.Reflect), e.Map = function (a, b) {
        function e(a) {
          var b = 0;
          return {
            next: function next() {
              return b < a.length ? {
                done: !1,
                value: a[b++]
              } : {
                done: !0
              };
            }
          };
        }

        var c = function c(a, _c) {
          var d, e, f, g;
          if (!a.map) throw Error('field is not a map');
          if (this.field = a, this.keyElem = new b.Element(a.keyType, null, !0, a.syntax), this.valueElem = new b.Element(a.type, a.resolvedType, !1, a.syntax), this.map = {}, Object.defineProperty(this, 'size', {
            get: function get() {
              return Object.keys(this.map).length;
            }
          }), _c) for (d = Object.keys(_c), e = 0; e < d.length; e++) {
            f = this.keyElem.valueFromString(d[e]), g = this.valueElem.verifyValue(_c[d[e]]), this.map[this.keyElem.valueToString(f)] = {
              key: f,
              value: g
            };
          }
        };

        var d = c.prototype;
        return d.clear = function () {
          this.map = {};
        }, d.delete = function (a) {
          var b = this.keyElem.valueToString(this.keyElem.verifyValue(a));
          var c = (b in this.map);
          return delete this.map[b], c;
        }, d.entries = function () {
          var d;
          var c;
          var a = [];
          var b = Object.keys(this.map);

          for (c = 0; c < b.length; c++) {
            a.push([(d = this.map[b[c]]).key, d.value]);
          }

          return e(a);
        }, d.keys = function () {
          var c;
          var a = [];
          var b = Object.keys(this.map);

          for (c = 0; c < b.length; c++) {
            a.push(this.map[b[c]].key);
          }

          return e(a);
        }, d.values = function () {
          var c;
          var a = [];
          var b = Object.keys(this.map);

          for (c = 0; c < b.length; c++) {
            a.push(this.map[b[c]].value);
          }

          return e(a);
        }, d.forEach = function (a, b) {
          var e;
          var d;
          var c = Object.keys(this.map);

          for (d = 0; d < c.length; d++) {
            a.call(b, (e = this.map[c[d]]).value, e.key, this);
          }
        }, d.set = function (a, b) {
          var c = this.keyElem.verifyValue(a);
          var d = this.valueElem.verifyValue(b);
          return this.map[this.keyElem.valueToString(c)] = {
            key: c,
            value: d
          }, this;
        }, d.get = function (a) {
          var b = this.keyElem.valueToString(this.keyElem.verifyValue(a));
          return b in this.map ? this.map[b].value : void 0;
        }, d.has = function (a) {
          var b = this.keyElem.valueToString(this.keyElem.verifyValue(a));
          return b in this.map;
        }, c;
      }(e, e.Reflect), e.loadProto = function (a, b, c) {
        return (typeof b === 'string' || b && typeof b.file === 'string' && typeof b.root === 'string') && (c = b, b = void 0), e.loadJson(e.DotProto.Parser.parse(a), b, c);
      }, e.protoFromString = e.loadProto, e.loadProtoFile = function (a, b, c) {
        if (b && _typeof(b) === 'object' ? (c = b, b = null) : b && typeof b === 'function' || (b = null), b) return e.Util.fetch(typeof a === 'string' ? a : a.root + '/' + a.file, function (d) {
          if (d === null) return b(Error('Failed to fetch file')), void 0;

          try {
            b(null, e.loadProto(d, c, a));
          } catch (f) {
            b(f);
          }
        });
        var d = e.Util.fetch(_typeof(a) === 'object' ? a.root + '/' + a.file : a);
        return d === null ? null : e.loadProto(d, c, a);
      }, e.protoFromFile = e.loadProtoFile, e.newBuilder = function (a) {
        return a = a || {}, typeof a.convertFieldsToCamelCase === 'undefined' && (a.convertFieldsToCamelCase = e.convertFieldsToCamelCase), typeof a.populateAccessors === 'undefined' && (a.populateAccessors = e.populateAccessors), new e.Builder(a);
      }, e.loadJson = function (a, b, c) {
        return (typeof b === 'string' || b && typeof b.file === 'string' && typeof b.root === 'string') && (c = b, b = null), b && _typeof(b) === 'object' || (b = e.newBuilder()), typeof a === 'string' && (a = JSON.parse(a)), b.import(a, c), b.resolveAll(), b;
      }, e.loadJsonFile = function (a, b, c) {
        if (b && _typeof(b) === 'object' ? (c = b, b = null) : b && typeof b === 'function' || (b = null), b) return e.Util.fetch(typeof a === 'string' ? a : a.root + '/' + a.file, function (d) {
          if (d === null) return b(Error('Failed to fetch file')), void 0;

          try {
            b(null, e.loadJson(JSON.parse(d), c, a));
          } catch (f) {
            b(f);
          }
        });
        var d = e.Util.fetch(_typeof(a) === 'object' ? a.root + '/' + a.file : a);
        return d === null ? null : e.loadJson(JSON.parse(d), c, a);
      }, h = a, e.loadProto(h, void 0, '').build('Modules').probuf;
    }(d, c);

    return e;
  }

  var Codec$1 = protobuf(SSMsg$1);

  Codec$1.getModule = function (pbName) {
    var modules = new Codec$1[pbName]();

    modules.getArrayData = function () {
      var data = modules.toArrayBuffer();
      data = isArrayBuffer(data) ? [].slice.call(new Int8Array(data)) : data;
      return data;
    };

    return modules;
  };

  /**
   * 群组 @ 类型
  */
  var MentionedType;

  (function (MentionedType) {
    /**
     * 所有人
    */
    MentionedType[MentionedType["ALL"] = 1] = "ALL";
    /**
     * 部分人
    */

    MentionedType[MentionedType["SINGAL"] = 2] = "SINGAL";
  })(MentionedType || (MentionedType = {}));

  var MentionedType$1 = MentionedType;

  /**
   * 内置消息类型
   */
  var MessageType;

  (function (MessageType) {
    /**
     * 文字消息
    */
    MessageType["TextMessage"] = "RC:TxtMsg";
    /**
     * 语音消息
    */

    MessageType["VOICE"] = "RC:VcMsg";
    /**
     * 高质量消息
    */

    MessageType["HQ_VOICE"] = "RC:HQVCMsg";
    /**
     * 图片消息
    */

    MessageType["IMAGE"] = "RC:ImgMsg";
    /**
     * GIF 消息
    */

    MessageType["GIF"] = "RC:GIFMsg";
    /**
     * 图文消息
    */

    MessageType["RICH_CONTENT"] = "RC:ImgTextMsg";
    /**
     * 位置消息
    */

    MessageType["LOCATION"] = "RC:LBSMsg";
    /**
     * 文件消息
    */

    MessageType["FILE"] = "RC:FileMsg";
    /**
     * 小视频消息
    */

    MessageType["SIGHT"] = "RC:SightMsg";
    /**
     * 合并转发消息
    */

    MessageType["COMBINE"] = "RC:CombineMsg";
    /**
     * 聊天室 KV 通知消息
    */

    MessageType["CHRM_KV_NOTIFY"] = "RC:chrmKVNotiMsg";
    /**
     * 日志通知消息
    */

    MessageType["LOG_COMMAND"] = "RC:LogCmdMsg";
    /**
     * 消息扩展
    */

    MessageType["EXPANSION_NOTIFY"] = "RC:MsgExMsg";
    /**
     * 引用消息
    */

    MessageType["REFERENCE"] = "RC:ReferenceMsg";
    /**
     * 撤回消息
    */

    MessageType["RECALL"] = "RC:RcCmd";
    /**
     * 已读同步状态消息
    */

    MessageType["READ_RECEIPT"] = "RC:ReadNtf";
    /**
     * 群已读请求回执消息
    */

    MessageType["READ_RECEIPT_REQUEST"] = "RC:RRReqMsg";
    /**
     * 群已读响应回执消息
    */

    MessageType["READ_RECEIPT_RESPONSE"] = "RC:RRRspMsg";
    /**
     * TODO
    */

    MessageType["SYNC_READ_STATUS"] = "RC:SRSMsg";
  })(MessageType || (MessageType = {}));

  var MessageType$1 = MessageType;

  var NotificationStatus;

  (function (NotificationStatus) {
    /**
     * 免打扰已开启
    */
    NotificationStatus[NotificationStatus["OPEN"] = 1] = "OPEN";
    /**
     * 免打扰已关闭
    */

    NotificationStatus[NotificationStatus["CLOSE"] = 2] = "CLOSE";
  })(NotificationStatus || (NotificationStatus = {}));

  var NotificationStatus$1 = NotificationStatus;

  var _PublishTopicToConver, _ConversationTypeToQu, _ConversationTypeToCl;
  var PublishTopic = {
    // 以下为发送消息操作, 本端发送、其他端同步都为以下值
    PRIVATE: 'ppMsgP',
    GROUP: 'pgMsgP',
    CHATROOM: 'chatMsg',
    CUSTOMER_SERVICE: 'pcMsgP',
    RECALL: 'recallMsg',
    // RTC 消息
    RTC_MSG: 'prMsgS',
    // 以下为服务端通知操作
    NOTIFY_PULL_MSG: 's_ntf',
    RECEIVE_MSG: 's_msg',
    SYNC_STATUS: 's_stat',
    SERVER_NOTIFY: 's_cmd',
    SETTING_NOTIFY: 's_us' // 服务端配置变更通知

  }; // 状态消息

  var PublishStatusTopic = {
    PRIVATE: 'ppMsgS',
    GROUP: 'pgMsgS',
    CHATROOM: 'chatMsgS'
  };
  var QueryTopic = {
    GET_SYNC_TIME: 'qrySessionsAtt',
    PULL_MSG: 'pullMsg',
    GET_CONVERSATION_LIST: 'qrySessions',
    REMOVE_CONVERSATION_LIST: 'delSessions',
    DELETE_MESSAGES: 'delMsg',
    CLEAR_UNREAD_COUNT: 'updRRTime',
    PULL_USER_SETTING: 'pullUS',
    PULL_CHRM_MSG: 'chrmPull',
    JOIN_CHATROOM: 'joinChrm',
    JOIN_EXIST_CHATROOM: 'joinChrmR',
    QUIT_CHATROOM: 'exitChrm',
    GET_CHATROOM_INFO: 'queryChrmI',
    UPDATE_CHATROOM_KV: 'setKV',
    DELETE_CHATROOM_KV: 'delKV',
    PULL_CHATROOM_KV: 'pullKV',
    GET_OLD_CONVERSATION_LIST: 'qryRelationR',
    REMOVE_OLD_CONVERSATION: 'delRelation',
    GET_CONVERSATION_STATUS: 'pullSeAtts',
    SET_CONVERSATION_STATUS: 'setSeAtt',
    GET_UPLOAD_FILE_TOKEN: 'qnTkn',
    GET_UPLOAD_FILE_URL: 'qnUrl',
    CLEAR_MESSAGES: {
      PRIVATE: 'cleanPMsg',
      GROUP: 'cleanGMsg',
      CUSTOMER_SERVICE: 'cleanCMsg',
      SYSTEM: 'cleanSMsg'
    },
    // 以下为 RTC 操作
    JOIN_RTC_ROOM: 'rtcRJoin_data',
    QUIT_RTC_ROOM: 'rtcRExit',
    PING_RTC: 'rtcPing',
    SET_RTC_DATA: 'rtcSetData',
    USER_SET_RTC_DATA: 'userSetData',
    GET_RTC_DATA: 'rtcQryData',
    DEL_RTC_DATA: 'rtcDelData',
    SET_RTC_OUT_DATA: 'rtcSetOutData',
    GET_RTC_OUT_DATA: 'rtcQryUserOutData',
    GET_RTC_TOKEN: 'rtcToken',
    SET_RTC_STATE: 'rtcUserState',
    GET_RTC_ROOM_INFO: 'rtcRInfo',
    GET_RTC_USER_INFO_LIST: 'rtcUData',
    SET_RTC_USER_INFO: 'rtcUPut',
    DEL_RTC_USER_INFO: 'rtcUDel',
    GET_RTC_USER_LIST: 'rtcUList'
  };
  var QueryHistoryTopic = {
    PRIVATE: 'qryPMsg',
    GROUP: 'qryGMsg',
    CHATROOM: 'qryCHMsg',
    CUSTOMER_SERVICE: 'qryCMsg',
    SYSTEM: 'qrySMsg'
  };
  var PublishTopicToConversationType = (_PublishTopicToConver = {}, _defineProperty(_PublishTopicToConver, PublishTopic.PRIVATE, ConversationType$1.PRIVATE), _defineProperty(_PublishTopicToConver, PublishTopic.GROUP, ConversationType$1.GROUP), _defineProperty(_PublishTopicToConver, PublishTopic.CHATROOM, ConversationType$1.CHATROOM), _defineProperty(_PublishTopicToConver, PublishTopic.CUSTOMER_SERVICE, ConversationType$1.CUSTOMER_SERVICE), _PublishTopicToConver);
  var ConversationTypeToQueryHistoryTopic = (_ConversationTypeToQu = {}, _defineProperty(_ConversationTypeToQu, ConversationType$1.PRIVATE, QueryHistoryTopic.PRIVATE), _defineProperty(_ConversationTypeToQu, ConversationType$1.GROUP, QueryHistoryTopic.GROUP), _defineProperty(_ConversationTypeToQu, ConversationType$1.CHATROOM, QueryHistoryTopic.CHATROOM), _defineProperty(_ConversationTypeToQu, ConversationType$1.CUSTOMER_SERVICE, QueryHistoryTopic.CUSTOMER_SERVICE), _defineProperty(_ConversationTypeToQu, ConversationType$1.SYSTEM, QueryHistoryTopic.SYSTEM), _ConversationTypeToQu);
  var ConversationTypeToClearMessageTopic = (_ConversationTypeToCl = {}, _defineProperty(_ConversationTypeToCl, ConversationType$1.PRIVATE, QueryTopic.CLEAR_MESSAGES.PRIVATE), _defineProperty(_ConversationTypeToCl, ConversationType$1.GROUP, QueryTopic.CLEAR_MESSAGES.GROUP), _defineProperty(_ConversationTypeToCl, ConversationType$1.CUSTOMER_SERVICE, QueryTopic.CLEAR_MESSAGES.CUSTOMER_SERVICE), _defineProperty(_ConversationTypeToCl, ConversationType$1.SYSTEM, QueryTopic.CLEAR_MESSAGES.SYSTEM), _ConversationTypeToCl);
  var ConversationStatusConfig = {
    ENABLED: '1',
    DISABLED: '0'
  };
  var ConversationStatusType = {
    DO_NOT_DISTURB: 1,
    TOP: 2,
    TAGS: 3 // 标签列表

  };

  var MessageDirection;

  (function (MessageDirection) {
    /**
     * 己方发送消息
     */
    MessageDirection[MessageDirection["SEND"] = 1] = "SEND";
    /**
     * 己方接收消息
     */

    MessageDirection[MessageDirection["RECEIVE"] = 2] = "RECEIVE";
  })(MessageDirection || (MessageDirection = {}));

  var MessageDirection$1 = MessageDirection;

  /**
   * 序列化、反序列化数据通道
  */

  var DataCodec = /*#__PURE__*/function () {
    function DataCodec(connectType) {
      _classCallCheck(this, DataCodec);

      this._codec = connectType === 'websocket' ? Codec$1 : Codec;
      this._connectType = connectType;
    }
    /**
     * PB 数据 转为 rmtp 数据 反序列化 通用数据
     * 根据解析的 PBName 分配解码方法. 如果没有单独的解码方法定义. 直接返回 pb 解析后的结果
    */


    _createClass(DataCodec, [{
      key: "decodeByPBName",
      value: function decodeByPBName(data, pbName, option) {
        var _formatEventMap;

        var self = this;
        var formatEventMap = (_formatEventMap = {}, _defineProperty(_formatEventMap, PBName.DownStreamMessages, self._formatSyncMessages), _defineProperty(_formatEventMap, PBName.DownStreamMessage, self._formatReceivedMessage), _defineProperty(_formatEventMap, PBName.UpStreamMessage, self._formatSentMessage), _defineProperty(_formatEventMap, PBName.HistoryMsgOuput, self._formatHistoryMessages), _defineProperty(_formatEventMap, PBName.RelationsOutput, self._formatConversationList), _defineProperty(_formatEventMap, PBName.QueryChatRoomInfoOutput, self._formatChatRoomInfos), _defineProperty(_formatEventMap, PBName.RtcUserListOutput, self._formatRTCUserList), _defineProperty(_formatEventMap, PBName.RtcQryOutput, self._formatRTCData), _defineProperty(_formatEventMap, PBName.ChrmKVOutput, self._formatChatRoomKVList), _defineProperty(_formatEventMap, PBName.PullUserSettingOutput, self._formatUserSetting), _defineProperty(_formatEventMap, PBName.SessionStates, self._formatConversationStatus), _defineProperty(_formatEventMap, PBName.SetUserSettingOutput, self._formatSetUserSettingOutput), _defineProperty(_formatEventMap, PBName.UserSettingNotification, self._formatUserSettingNotification), _formatEventMap);
        var decodedData = data;
        var formatEvent = formatEventMap[pbName];

        try {
          var hasData = data.length > 0; // 判断是否有数据, 防止无数据 pb 解析报错

          decodedData = hasData && self._codec[pbName].decode(data); // pb 解析

          if (isObject$1(decodedData)) {
            decodedData = batchInt64ToTimestamp(decodedData); // 时间转化
          }

          if (isFunction(formatEvent)) {
            decodedData = formatEvent.call(this, decodedData, option); // 数据格式化
          }
        } catch (e) {
          logger.error('PB parse error\n', e);
        }

        return decodedData;
      }
    }, {
      key: "_readBytes",
      value: function _readBytes(content) {
        var offset = content.offset,
            buffer = content.buffer,
            limit = content.limit;

        if (offset) {
          try {
            var _content = isArrayBuffer(buffer) ? new Uint8Array(buffer) : buffer; // content = utils.ArrayBufferToUint8Array(buffer).subarray(offset, limit)


            return BinaryHelper.readUTF(_content.subarray(offset, limit));
          } catch (e) {
            logger.info('readBytes error\n', e);
          }
        }

        return content;
      }
      /**
       * ====== 以下为 rmtp 数据 反序列化为 可用数据 ======
       */

    }, {
      key: "_formatBytes",
      value: function _formatBytes(content) {
        // 1. socket 下, content.buffer 为二进制 ArrayBuffer, 需调用 ArrayBufferToUint8Array 转换
        // 2. comet 下, content 为 JSON 字符串. socket、comet 解析后都需要 JSON to Object
        var formatRes = this._readBytes(content);

        try {
          formatRes = JSON.parse(formatRes);
        } catch (e) {
          logger.info('formatBytes error\n', e);
        }

        return formatRes || content;
      }
      /**
       * 格式化多端同步消息
      */

    }, {
      key: "_formatSyncMessages",
      value: function _formatSyncMessages(data, option) {
        option = option || {};
        var self = this;
        var list = data.list,
            syncTime = data.syncTime,
            finished = data.finished; // Comet 与 聊天室没有 finished 字段定义，默认为 true

        if (isUndefined(finished) || finished === null) {
          data.finished = true;
        }

        data.syncTime = int64ToTimestamp(syncTime);
        data.list = map(list, function (msgData) {
          var message = self._formatReceivedMessage(msgData, option);

          return message;
        });
        return data;
      }
      /**
       * 格式化接收消息
      */

    }, {
      key: "_formatReceivedMessage",
      value: function _formatReceivedMessage(data, option) {
        // TODO: 需杜绝此类传参，参数在进入方法前进行类型值确认
        option = option || {};
        var self = this;
        var _option = option,
            currentUserId = _option.currentUserId,
            connectedTime = _option.connectedTime;
        var content = data.content,
            fromUserId = data.fromUserId,
            type = data.type,
            groupId = data.groupId,
            status = data.status,
            dataTime = data.dataTime,
            messageType = data.classname,
            messageUId = data.msgId,
            extraContent = data.extraContent,
            pushContent = data.pushContent,
            pushExt = data.pushExt,
            configFlag = data.configFlag;
        var direction = data.direction || MessageDirection$1.RECEIVE; // null || 0 都为收件箱

        var isSelfSend = direction === MessageDirection$1.SEND;

        var _getMessageOptionBySt = getMessageOptionByStatus(status),
            isPersited = _getMessageOptionBySt.isPersited,
            isCounted = _getMessageOptionBySt.isCounted,
            isMentioned = _getMessageOptionBySt.isMentioned,
            disableNotification = _getMessageOptionBySt.disableNotification,
            receivedStatus = _getMessageOptionBySt.receivedStatus,
            canIncludeExpansion = _getMessageOptionBySt.canIncludeExpansion;

        var targetId = type === ConversationType$1.GROUP || type === ConversationType$1.CHATROOM ? groupId : fromUserId;
        var senderUserId = isSelfSend ? currentUserId : fromUserId;
        var sentTime = int64ToTimestamp(dataTime);
        var isOffLineMessage = sentTime < connectedTime;
        var isChatRoomMsg = type === ConversationType$1.CHATROOM;

        var utfContent = self._formatBytes(content);

        var messageDirection = isSelfSend ? MessageDirection$1.SEND : MessageDirection$1.RECEIVE; // 聊天室拉消息时, 自己发送的消息, direction 也为 null

        if (isChatRoomMsg && fromUserId === currentUserId) {
          messageDirection = MessageDirection$1.SEND;
        }

        var expansion;

        if (extraContent) {
          expansion = {};
          expansion = formatExtraContent(extraContent);
        }

        return {
          conversationType: type,
          targetId: targetId,
          senderUserId: senderUserId,
          messageType: messageType,
          messageUId: messageUId,
          isPersited: isPersited,
          isCounted: isCounted,
          isMentioned: isMentioned,
          sentTime: sentTime,
          isOffLineMessage: isOffLineMessage,
          messageDirection: messageDirection,
          receivedTime: DelayTimer.getTime(),
          disableNotification: disableNotification,
          receivedStatus: receivedStatus,
          canIncludeExpansion: canIncludeExpansion,
          content: utfContent,
          expansion: expansion,
          pushContent: pushContent,
          pushExt: pushExt,
          configFlag: configFlag
        };
      }
      /**
       * 格式化发送消息
      */

    }, {
      key: "_formatSentMessage",
      value: function _formatSentMessage(data, option) {
        var self = this;
        var content = data.content,
            messageType = data.classname,
            sessionId = data.sessionId,
            messageUId = data.msgId,
            extraContent = data.extraContent;
        var signal = option.signal,
            currentUserId = option.currentUserId;
        var date = signal.date,
            topic = signal.topic,
            targetId = signal.targetId;

        var _getUpMessageOptionBy = getUpMessageOptionBySessionId(sessionId),
            isPersited = _getUpMessageOptionBy.isPersited,
            isCounted = _getUpMessageOptionBy.isCounted,
            disableNotification = _getUpMessageOptionBy.disableNotification,
            canIncludeExpansion = _getUpMessageOptionBy.canIncludeExpansion;

        var type = PublishTopicToConversationType[topic] || ConversationType$1.PRIVATE;
        var isStatusMessage = isInObject(PublishStatusTopic, topic);
        var expansion;

        if (extraContent) {
          expansion = {};
          expansion = formatExtraContent(extraContent);
        }

        return {
          conversationType: type,
          targetId: targetId,
          messageType: messageType,
          messageUId: messageUId,
          isPersited: isPersited,
          isCounted: isCounted,
          isStatusMessage: isStatusMessage,
          senderUserId: currentUserId,
          content: self._formatBytes(content),
          sentTime: date * 1000,
          receivedTime: DelayTimer.getTime(),
          messageDirection: MessageDirection$1.SEND,
          isOffLineMessage: false,
          disableNotification: disableNotification,
          canIncludeExpansion: canIncludeExpansion,
          expansion: expansion // 消息携带的 KV 字段

        };
      }
      /**
       * 格式化历史消息
      */

    }, {
      key: "_formatHistoryMessages",
      value: function _formatHistoryMessages(data, option) {
        var _this = this;

        var conversation = option.conversation || {};
        var msgList = data.list,
            hasMsg = data.hasMsg;
        var targetId = conversation.targetId;
        var syncTime = int64ToTimestamp(data.syncTime);
        var list = [];
        forEach(msgList, function (msgData) {
          var msg = _this._formatReceivedMessage(msgData, option);

          msg.targetId = targetId;
          list.push(msg);
        }, {
          isReverse: true
        });
        return {
          syncTime: syncTime,
          list: list,
          hasMore: !!hasMsg
        };
      }
      /**
       * 格式化会话列表
      */

    }, {
      key: "_formatConversationList",
      value: function _formatConversationList(serverData, option) {
        var self = this;
        var conversationList = serverData.info;

        var afterDecode = option.afterDecode || function () {};

        conversationList = map(conversationList, function (serverConversation) {
          var msg = serverConversation.msg,
              userId = serverConversation.userId,
              type = serverConversation.type,
              unreadCount = serverConversation.unreadCount;

          var latestMessage = self._formatReceivedMessage(msg, option);

          latestMessage.targetId = userId;
          var conversation = {
            targetId: userId,
            conversationType: type,
            unreadMessageCount: unreadCount,
            latestMessage: latestMessage
          };
          return afterDecode(conversation) || conversation;
        });
        return conversationList || [];
      }
      /**
       * 格式化用户设置
      */

    }, {
      key: "_formatSetUserSettingOutput",
      value: function _formatSetUserSettingOutput(serverData) {
        return serverData;
      }
      /**
       * 格式化聊天室信息
      */

    }, {
      key: "_formatChatRoomInfos",
      value: function _formatChatRoomInfos(data) {
        var userTotalNums = data.userTotalNums,
            userInfos = data.userInfos;
        var chrmInfos = map(userInfos, function (user) {
          var id = user.id,
              time = user.time;
          var timestamp = int64ToTimestamp(time);
          return {
            id: id,
            time: timestamp
          };
        });
        return {
          userCount: userTotalNums,
          userInfos: chrmInfos
        };
      }
      /**
       * 格式化 聊天室 KV 列表
      */

    }, {
      key: "_formatChatRoomKVList",
      value: function _formatChatRoomKVList(data) {
        var kvEntries = data.entries,
            isFullUpdate = data.bFullUpdate,
            syncTime = data.syncTime;
        kvEntries = kvEntries || [];
        kvEntries = map(kvEntries, function (kv) {
          var key = kv.key,
              value = kv.value,
              status = kv.status,
              timestamp = kv.timestamp,
              uid = kv.uid;

          var _getChatRoomKVByStatu = getChatRoomKVByStatus(status),
              isAutoDelete = _getChatRoomKVByStatu.isAutoDelete,
              isOverwrite = _getChatRoomKVByStatu.isOverwrite,
              type = _getChatRoomKVByStatu.type;

          return {
            key: key,
            value: value,
            isAutoDelete: isAutoDelete,
            isOverwrite: isOverwrite,
            type: type,
            userId: uid,
            timestamp: int64ToTimestamp(timestamp)
          };
        });
        return {
          kvEntries: kvEntries,
          isFullUpdate: isFullUpdate,
          syncTime: syncTime
        };
      }
      /**
       * 格式化 用户设置
      */

    }, {
      key: "_formatUserSetting",
      value: function _formatUserSetting(data) {
        var _this2 = this;

        var items = data.items,
            version = data.version;
        var settings = {};
        forEach(items || [], function (setting) {
          var key = setting.key,
              version = setting.version,
              value = setting.value;
          setting.version = int64ToTimestamp(version);
          setting.value = _this2._readBytes(value);

          if (key === 'Tag') {
            setting.tags.forEach(function (tag) {
              tag.createdTime = int64ToTimestamp(tag.createdTime);
              tag.tagName = tag.name;
            });
          }

          settings[key] = setting;
        });
        return {
          settings: settings,
          version: version
        };
      }
      /**
       * 格式化 会话状态 置顶、免打扰）
      */

    }, {
      key: "_formatConversationStatus",
      value: function _formatConversationStatus(data) {
        var stateList = data.state;
        var statusList = [];
        forEach(stateList, function (session) {
          var type = session.type,
              targetId = session.channelId,
              updatedTime = session.time,
              stateItem = session.stateItem;
          var notificationStatus = NotificationStatus$1.CLOSE;
          var isTop = false;
          var tags = [];
          forEach(stateItem, function (item) {
            var sessionStateType = item.sessionStateType,
                value = item.value,
                _tags = item.tags;

            switch (sessionStateType) {
              case ConversationStatusType.DO_NOT_DISTURB:
                notificationStatus = value === ConversationStatusConfig.ENABLED ? NotificationStatus$1.OPEN : NotificationStatus$1.CLOSE;
                break;

              case ConversationStatusType.TOP:
                isTop = value === ConversationStatusConfig.ENABLED;
                break;

              case ConversationStatusType.TAGS:
                tags = _tags;
                break;
            }
          });
          statusList.push({
            type: type,
            targetId: targetId,
            notificationStatus: notificationStatus,
            isTop: isTop,
            updatedTime: int64ToTimestamp(updatedTime),
            tags: tags
          });
        });
        return statusList;
      }
      /**
       * 格式化 RTC 用户列表
      */

    }, {
      key: "_formatRTCUserList",
      value: function _formatRTCUserList(rtcInfos) {
        var list = rtcInfos.list,
            token = rtcInfos.token,
            sessionId = rtcInfos.sessionId;
        var users = {};
        forEach(list, function (item) {
          var userId = item.userId,
              userData = item.userData;
          var tmpData = {};
          forEach(userData, function (data) {
            var key = data.key,
                value = data.value;
            tmpData[key] = value;
          });
          users[userId] = tmpData;
        });
        return {
          users: users,
          token: token,
          sessionId: sessionId
        };
      }
      /**
        * 格式化 RTC 数据
      */

    }, {
      key: "_formatRTCData",
      value: function _formatRTCData(data) {
        var list = data.outInfo;
        var props = {};
        forEach(list, function (item) {
          props[item.key] = item.value;
        });
        return props;
      }
      /**
        * 格式化 RTC 房间信息
      */

    }, {
      key: "_formatRTCRoomInfo",
      value: function _formatRTCRoomInfo(data) {
        var id = data.roomId,
            total = data.userCount,
            roomData = data.roomData;
        var room = {
          id: id,
          total: total
        };
        forEach(roomData, function (data) {
          room[data.key] = data.value;
        });
        return room;
      }
      /**
       * 格式化用户配置通知
       */

    }, {
      key: "_formatUserSettingNotification",
      value: function _formatUserSettingNotification(data) {
        return data;
      }
      /**
       * ===== 以下为通用数据 序列化为 PB 数据 =====
       * Engine Index 调用处理数据
      */

      /**
       * ? 待补全注释
      */

    }, {
      key: "encodeServerConfParams",
      value: function encodeServerConfParams() {
        var modules = this._codec.getModule(PBName.SessionsAttQryInput);

        modules.setNothing(1);
        return modules.getArrayData();
      }
      /**
       * 上行消息基础配置
      */

    }, {
      key: "_getUpMsgModule",
      value: function _getUpMsgModule(conversation, option) {
        var isComet = this._connectType === 'comet';
        var type = conversation.type;
        var messageType = option.messageType,
            isMentioned = option.isMentioned,
            mentionedType = option.mentionedType,
            mentionedUserIdList = option.mentionedUserIdList,
            content = option.content,
            pushContent = option.pushContent,
            directionalUserIdList = option.directionalUserIdList,
            isFilerWhiteBlacklist = option.isFilerWhiteBlacklist,
            isVoipPush = option.isVoipPush,
            canIncludeExpansion = option.canIncludeExpansion,
            expansion = option.expansion,
            pushConfig = option.pushConfig;
        var isGroupType = type === ConversationType$1.GROUP;

        var modules = this._codec.getModule(PBName.UpStreamMessage);

        var sessionId = getSessionId(option);

        var _ref = pushConfig || {},
            pushTitle = _ref.pushTitle,
            pushData = _ref.pushData,
            iOSConfig = _ref.iOSConfig,
            androidConfig = _ref.androidConfig,
            templateId = _ref.templateId,
            disablePushTitle = _ref.disablePushTitle,
            forceShowDetailContent = _ref.forceShowDetailContent;

        var flag = 0;
        modules.setSessionId(sessionId);

        if (isGroupType && isMentioned && content) {
          content.mentionedInfo = {
            userIdList: mentionedUserIdList,
            type: mentionedType || MentionedType$1.ALL
          };
        }

        pushContent && modules.setPushText(pushContent); // 设置 pushContent

        pushData && modules.setAppData(pushData); // 设置 pushData

        directionalUserIdList && modules.setUserId(directionalUserIdList); // 设置群定向消息人员
        // 设置 flag. 涉及业务: 1、iOS VoipPush  2、过滤黑/白名单

        flag |= isVoipPush ? 0x01 : 0;
        flag |= isFilerWhiteBlacklist ? 0x02 : 0;
        flag |= disablePushTitle ? 0x04 : 0;
        flag |= forceShowDetailContent ? 0x08 : 0;
        modules.setConfigFlag(flag);
        modules.setClassname(messageType); // 设置 objectName

        modules.setContent(JSON.stringify(content));

        if (canIncludeExpansion && expansion) {
          var extraContent = {};
          forEach(expansion, function (val, key) {
            extraContent[key] = {
              v: val
            };
          });
          modules.setExtraContent(JSON.stringify(extraContent)); // 设置消息扩展内容
        } // 设置推送扩展


        if (pushConfig) {
          var pushExtraModule = this._codec.getModule(PBName.PushExtra);

          pushTitle && pushExtraModule.setTitle(pushTitle);

          if (iOSConfig && androidConfig) {
            var pushConfigStr = pushConfigsToJSON(iOSConfig, androidConfig);
            pushExtraModule.setPushConfigs(pushConfigStr);
          }

          (androidConfig === null || androidConfig === void 0 ? void 0 : androidConfig.notificationId) && pushExtraModule.setPushId(androidConfig === null || androidConfig === void 0 ? void 0 : androidConfig.notificationId);
          pushExtraModule.setTemplateId(templateId || '');
          modules.setPushExt(isComet ? pushExtraModule.getArrayData() : pushExtraModule);
        }

        return modules;
      }
      /**
       * 序列化上行消息
      */

    }, {
      key: "encodeUpMsg",
      value: function encodeUpMsg(conversation, option) {
        var modules = this._getUpMsgModule(conversation, option);

        return modules.getArrayData();
      }
      /**
       * 序列化拉取多端消息
      */

    }, {
      key: "encodeSyncMsg",
      value: function encodeSyncMsg(syncMsgArgs) {
        var sendboxTime = syncMsgArgs.sendboxTime,
            inboxTime = syncMsgArgs.inboxTime;

        var modules = this._codec.getModule(PBName.SyncRequestMsg);

        modules.setIspolling(false);
        modules.setIsPullSend(true);
        modules.setSendBoxSyncTime(sendboxTime);
        modules.setSyncTime(inboxTime);
        return modules.getArrayData();
      }
      /**
       * 序列化拉取聊天室消息
      */

    }, {
      key: "encodeChrmSyncMsg",
      value: function encodeChrmSyncMsg(time, count) {
        time = time || 0;
        count = count || 0;

        var modules = this._codec.getModule(PBName.ChrmPullMsg);

        modules.setCount(count);
        modules.setSyncTime(time);
        return modules.getArrayData();
      }
      /**
       * 序列化历史消息
      */

    }, {
      key: "encodeGetHistoryMsg",
      value: function encodeGetHistoryMsg(targetId, option) {
        var count = option.count,
            order = option.order,
            timestamp = option.timestamp;

        var modules = this._codec.getModule(PBName.HistoryMsgInput);

        modules.setTargetId(targetId);
        modules.setTime(timestamp);
        modules.setCount(count);
        modules.setOrder(order);
        return modules.getArrayData();
      }
      /**
       * 序列化会话列表
      */

    }, {
      key: "encodeGetConversationList",
      value: function encodeGetConversationList(option) {
        option = option || {};
        var _option2 = option,
            count = _option2.count,
            startTime = _option2.startTime;

        var modules = this._codec.getModule(PBName.RelationQryInput); // 默认值已在 modules 暴露层赋值. 传入此处, 必有值


        modules.setType(1); // type 可传任意值

        modules.setCount(count);
        modules.setStartTime(startTime);
        return modules.getArrayData();
      }
      /**
       * 旧会话列表. 获取、删除都调用此方法
      */

    }, {
      key: "encodeOldConversationList",
      value: function encodeOldConversationList(option) {
        option = option || {};
        var _option3 = option,
            count = _option3.count,
            type = _option3.type,
            startTime = _option3.startTime,
            order = _option3.order;
        count = count || 0; // 删除会话列表 count 传 0 , setCount 形参 count 为必填参数

        startTime = startTime || 0;
        order = order || 0;

        var modules = this._codec.getModule(PBName.RelationQryInput);

        modules.setType(type);
        modules.setCount(count);
        modules.setStartTime(startTime);
        modules.setOrder(order);
        return modules.getArrayData();
      }
      /**
       * 旧会话列表删除
      */

    }, {
      key: "encodeRemoveConversationList",
      value: function encodeRemoveConversationList(conversationList) {
        var _this3 = this;

        var modules = this._codec.getModule(PBName.DeleteSessionsInput);

        var sessions = [];
        forEach(conversationList, function (conversation) {
          var type = conversation.type,
              targetId = conversation.targetId;

          var session = _this3._codec.getModule(PBName.SessionInfo);

          session.setType(type);
          session.setChannelId(targetId);
          sessions.push(session);
        });
        modules.setSessions(sessions);
        return modules.getArrayData();
      }
      /**
       * 批量删除消息通过消息 ID
      */

    }, {
      key: "encodeDeleteMessages",
      value: function encodeDeleteMessages(conversationType, targetId, list) {
        var modules = this._codec.getModule(PBName.DeleteMsgInput);

        var encodeMsgs = [];
        forEach(list, function (message) {
          encodeMsgs.push({
            msgId: message.messageUId,
            msgDataTime: message.sentTime,
            direct: message.messageDirection
          });
        });
        modules.setType(conversationType);
        modules.setConversationId(targetId);
        modules.setMsgs(encodeMsgs);
        return modules.getArrayData();
      }
      /**
       * 批量删除消息通过时间
      */

    }, {
      key: "encodeClearMessages",
      value: function encodeClearMessages(targetId, timestamp) {
        var modules = this._codec.getModule(PBName.CleanHisMsgInput);

        timestamp = timestamp || new Date().getTime(); // 默认当前时间

        modules.setDataTime(timestamp);
        modules.setTargetId(targetId);
        return modules.getArrayData();
      }
      /**
       * 未读数清除
      */

    }, {
      key: "encodeClearUnreadCount",
      value: function encodeClearUnreadCount(conversation, option) {
        var type = conversation.type,
            targetId = conversation.targetId;
        var timestamp = option.timestamp;

        var modules = this._codec.getModule(PBName.SessionMsgReadInput);

        timestamp = timestamp || +new Date();
        modules.setType(type);
        modules.setChannelId(targetId);
        modules.setMsgTime(timestamp);
        return modules.getArrayData();
      }
      /**
       * 加入退出聊天室
      */

    }, {
      key: "encodeJoinOrQuitChatRoom",
      value: function encodeJoinOrQuitChatRoom() {
        var modules = this._codec.getModule(PBName.ChrmInput);

        modules.setNothing(1);
        return modules.getArrayData();
      }
      /**
       * 获取聊天室信息
       * @param count 获取人数
       * @param order 排序方式
      */

    }, {
      key: "encodeGetChatRoomInfo",
      value: function encodeGetChatRoomInfo(count, order) {
        var modules = this._codec.getModule(PBName.QueryChatRoomInfoInput);

        modules.setCount(count);
        modules.setOrder(order);
        return modules.getArrayData();
      }
      /**
       * 上传文件认证信息获取
      */

    }, {
      key: "encodeGetFileToken",
      value: function encodeGetFileToken(fileType, fileName) {
        var modules = this._codec.getModule(PBName.GetQNupTokenInput);

        modules.setType(fileType);
        modules.setKey(fileName);
        return modules.getArrayData();
      }
      /**
        * 获取七牛上传url
      */

    }, {
      key: "encodeGetFileUrl",
      value: function encodeGetFileUrl(inputPBName, fileType, fileName, originName) {
        var modules = this._codec.getModule(inputPBName);

        modules.setType(fileType);
        modules.setKey(fileName);

        if (originName) {
          modules.setFileName(originName);
        }

        return modules.getArrayData();
      }
      /**
        * 聊天室 KV 存储
      */

    }, {
      key: "encodeModifyChatRoomKV",
      value: function encodeModifyChatRoomKV(chrmId, entry, currentUserId) {
        var isComet = this._connectType === 'comet';

        var modules = this._codec.getModule(PBName.SetChrmKV);

        var key = entry.key,
            value = entry.value,
            extra = entry.notificationExtra,
            isSendNotification = entry.isSendNotification,
            type = entry.type;
        var action = type || ChatroomEntryType$1.UPDATE;
        var status = getChatRoomKVOptStatus(entry, action);
        var serverEntry = {
          key: key,
          value: value || '',
          uid: currentUserId
        }; // 若 status 传空, server 会出问题

        if (!isUndefined(status)) {
          serverEntry.status = status;
        }

        modules.setEntry(serverEntry);

        if (isSendNotification) {
          // 如果需要发送通知, 设置通知消息
          var conversation = {
            type: ConversationType$1.CHATROOM,
            targetId: chrmId
          };
          var msgContent = {
            key: key,
            value: value,
            extra: extra,
            type: action
          }; // 通知消息内置, 由 Server 自动发送

          var msgModule = this._getUpMsgModule(conversation, {
            messageType: MessageType$1.CHRM_KV_NOTIFY,
            content: msgContent,
            isPersited: false,
            isCounted: false
          });

          isComet ? modules.setNotification(msgModule.getArrayData()) : modules.setNotification(msgModule);
          modules.setBNotify(true);
          modules.setType(ConversationType$1.CHATROOM);
        }

        return modules.getArrayData();
      }
      /**
        * KV 存储拉取
      */

    }, {
      key: "encodePullChatRoomKV",
      value: function encodePullChatRoomKV(time) {
        var modules = this._codec.getModule(PBName.QueryChrmKV);

        modules.setTimestamp(time);
        return modules.getArrayData();
      }
      /**
        * 用户实时配置更新
      */

    }, {
      key: "encodePullUserSetting",
      value: function encodePullUserSetting(version) {
        var modules = this._codec.getModule(PBName.PullUserSettingInput);

        modules.setVersion(version);
        return modules.getArrayData();
      }
      /**
        * 获取会话状态 (置顶、免打扰)
      */

    }, {
      key: "encodeGetConversationStatus",
      value: function encodeGetConversationStatus(time) {
        var modules = this._codec.getModule(PBName.SessionReq);

        modules.setTime(time);
        return modules.getArrayData();
      }
      /**
        * 设置会话状态 (置顶、免打扰)
      */

    }, {
      key: "encodeSetConversationStatus",
      value: function encodeSetConversationStatus(statusList) {
        var _this4 = this;

        var isComet = this._connectType === 'comet';

        var modules = this._codec.getModule(PBName.SessionStateModifyReq);

        var currentTime = DelayTimer.getTime();
        var stateModuleList = [];
        forEach(statusList, function (status) {
          var stateModules = _this4._codec.getModule(PBName.SessionState);

          var type = status.conversationType,
              targetId = status.targetId,
              notificationStatus = status.notificationStatus,
              isTop = status.isTop;
          var stateItemModuleList = [];
          stateModules.setType(type);
          stateModules.setChannelId(targetId);
          stateModules.setTime(currentTime);
          var isNotDisturb = notificationStatus === NotificationStatus$1.OPEN;
          var TypeToVal = {};

          if (!isUndefined(notificationStatus)) {
            TypeToVal[ConversationStatusType.DO_NOT_DISTURB] = isNotDisturb;
          }

          if (!isUndefined(isTop)) {
            TypeToVal[ConversationStatusType.TOP] = isTop;
          }

          forEach(TypeToVal, function (val, type) {
            if (!isUndefined(val)) {
              var stateItemModules = _this4._codec.getModule(PBName.SessionStateItem);

              val = val ? ConversationStatusConfig.ENABLED : ConversationStatusConfig.DISABLED;
              stateItemModules.setSessionStateType(Number(type)); // TODO 暂时写死

              stateItemModules.setValue(val);
              var stateItemModulesData = isComet ? stateItemModules.getArrayData() : stateItemModules;
              stateItemModuleList.push(stateItemModulesData);
            }
          });
          stateModules.setStateItem(stateItemModuleList);
          var stateModulesData = isComet ? stateModules.getArrayData() : stateModules;
          stateModuleList.push(stateModulesData);
        });
        modules.setVersion(currentTime);
        modules.setState(stateModuleList);
        return modules.getArrayData();
      }
      /**
       * 序列化创建tag消息
       */

    }, {
      key: "encodeCreateTag",
      value: function encodeCreateTag(tags) {
        var _this5 = this;

        var isComet = this._connectType === 'comet';

        var modules = this._codec.getModule(PBName.SessionTagAddInput);

        var itemListModules = [];
        tags.forEach(function (tag) {
          var itemModule = _this5._codec.getModule(PBName.SessionTagItem);

          itemModule.setTagId(tag.tagId);
          itemModule.setName(tag.tagName);
          itemListModules.push(isComet ? itemModule.getArrayData() : itemModule);
        });
        modules.setTags(itemListModules);
        modules.setVersion(Date.now());
        return modules.getArrayData();
      }
      /**
       * 序列化删除tag消息
       */

    }, {
      key: "encodeRemoveTag",
      value: function encodeRemoveTag(tagIds) {
        var _this6 = this;

        var isComet = this._connectType === 'comet';

        var modules = this._codec.getModule(PBName.SessionTagDelInput);

        var itemListModules = [];
        tagIds.forEach(function (tagId) {
          var itemModule = _this6._codec.getModule(PBName.SessionTagItem);

          itemModule.setTagId(tagId);
          itemListModules.push(isComet ? itemModule.getArrayData() : itemModule);
        });
        modules.setTags(itemListModules);
        modules.setVersion(Date.now());
        return modules.getArrayData();
      }
      /**
       * 解除会话标签关系
       */

    }, {
      key: "encodeDisConversationTag",
      value: function encodeDisConversationTag(tagIds) {
        var modules = this._codec.getModule(PBName.SessionDisTagReq);

        modules.setTagId(tagIds);
        return modules.getArrayData();
      }
      /**
       * 序列化更新会话标签
       */

    }, {
      key: "encodeUpdateConversationTag",
      value: function encodeUpdateConversationTag(tags, conversations) {
        var _this7 = this;

        var isComet = this._connectType === 'comet';

        var modules = this._codec.getModule(PBName.SessionStateModifyReq);

        var sessionStateModule = [];
        conversations.forEach(function (_conversation) {
          var SessionState = _this7._codec.getModule(PBName.SessionState);

          var SessionStateItem = _this7._codec.getModule(PBName.SessionStateItem);

          var SessionTagItemModules = [];
          tags.forEach(function (tag) {
            var SessionTagItem = _this7._codec.getModule(PBName.SessionTagItem);

            SessionTagItem.setTagId(tag.tagId);

            if (!isUndefined(tag.isTop)) {
              SessionTagItem.setIsTop(tag.isTop);
            }

            SessionTagItemModules.push(isComet ? SessionTagItem.getArrayData() : SessionTagItem);
          });
          SessionStateItem.setSessionStateType(ConversationStatusType.TAGS);
          SessionStateItem.setValue(JSON.stringify(SessionTagItemModules));
          SessionStateItem.setTags(SessionTagItemModules);
          SessionState.setType(_conversation.type);
          SessionState.setChannelId(_conversation.targetId);
          SessionState.setTime(Date.now());
          SessionState.setStateItem([isComet ? SessionStateItem.getArrayData() : SessionStateItem]);
          sessionStateModule.push(isComet ? SessionState.getArrayData() : SessionState);
        });
        modules.setState(sessionStateModule);
        modules.setVersion(Date.now());
        return modules.getArrayData();
      }
      /**
       * ============ 以下为 RTC 相关 ============
       */

      /**
       * 加入 RTC 房间
       */

    }, {
      key: "encodeJoinRTCRoom",
      value: function encodeJoinRTCRoom(mode, broadcastType) {
        var modules = this._codec.getModule(PBName.RtcInput);

        mode = mode || 0;
        modules.setRoomType(mode);
        isUndefined(broadcastType) || modules.setBroadcastType(broadcastType);
        return modules.getArrayData();
      }
      /**
       * 退出 RTC 房间
      */

    }, {
      key: "encodeQuitRTCRoom",
      value: function encodeQuitRTCRoom() {
        return this._codec.getModule(PBName.SetUserStatusInput).getArrayData();
      }
      /**
       * 房间数据
      */

    }, {
      key: "encodeSetRTCData",
      value: function encodeSetRTCData(key, value, isInner, apiType, message) {
        var modules = this._codec.getModule(PBName.RtcSetDataInput);

        modules.setInterior(isInner);
        modules.setTarget(apiType);
        modules.setKey(key);
        modules.setValue(value);

        if (message) {
          message.name && modules.setObjectName(message.name);
          var content = message.content;

          if (content) {
            if (isObject$1(content)) {
              content = JSON.stringify(content);
            }

            modules.setContent(content);
          }
        }

        return modules.getArrayData();
      }
      /**
       * 全量 URI
      */

    }, {
      key: "encodeUserSetRTCData",
      value: function encodeUserSetRTCData(message, valueInfo, objectName) {
        var modules = this._codec.getModule(PBName.RtcUserSetDataInput); // 全量 URI 新增
        // 全量发布中
        // valueInfo: key 为 uris，值为 全量的订阅信息
        // content: key 为增量数据消息 RCRTC:ModifyResource，value 为增量订阅信息


        modules.setObjectName(objectName); // content

        var val = this._codec.getModule(PBName.RtcValueInfo);

        val.setKey(message.name);
        val.setValue(message.content);
        modules.setContent(val); // valueInfo

        val = this._codec.getModule(PBName.RtcValueInfo);
        val.setKey('uris');
        val.setValue(valueInfo);
        modules.setValueInfo(val);
        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "encodeGetRTCData",
      value: function encodeGetRTCData(keys, isInner, apiType) {
        var modules = this._codec.getModule(PBName.RtcDataInput);

        modules.setInterior(isInner);
        modules.setTarget(apiType);
        modules.setKey(keys);
        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "encodeRemoveRTCData",
      value: function encodeRemoveRTCData(keys, isInner, apiType, message) {
        var modules = this._codec.getModule(PBName.RtcDataInput);

        modules.setInterior(isInner);
        modules.setTarget(apiType);
        modules.setKey(keys);
        message = message || {};
        var _message = message,
            name = _message.name,
            content = _message.content;
        !isUndefined(name) && modules.setObjectName(name);

        if (!isUndefined(content)) {
          if (isObject$1(content)) {
            content = JSON.stringify(content);
          }

          modules.setContent(content);
        }

        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "encodeSetRTCOutData",
      value: function encodeSetRTCOutData(data, type, message) {
        var modules = this._codec.getModule(PBName.RtcSetOutDataInput);

        modules.setTarget(type);

        if (!isArray$1(data)) {
          data = [data];
        }

        forEach(data, function (item, index) {
          item.key = item.key ? item.key.toString() : item.key;
          item.value = item.value ? item.value.toString() : item.value;
          data[index] = item;
        });
        modules.setValueInfo(data);
        message = message || {};
        var _message2 = message,
            name = _message2.name,
            content = _message2.content;
        !isUndefined(name) && modules.setObjectName(name);

        if (!isUndefined(content)) {
          if (isObject$1(content)) {
            content = JSON.stringify(content);
          }

          modules.setContent(content);
        }

        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "ecnodeGetRTCOutData",
      value: function ecnodeGetRTCOutData(userIds) {
        var modules = this._codec.getModule(PBName.RtcQryUserOutDataInput);

        modules.setUserId(userIds);
        return modules.getArrayData();
      }
    }, {
      key: "encodeSetRTCState",
      value: function encodeSetRTCState(report) {
        var modules = this._codec.getModule(PBName.MCFollowInput);

        modules.setId(report);
        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "encodeGetRTCRoomInfo",
      value: function encodeGetRTCRoomInfo() {
        var modules = this._codec.getModule(PBName.RtcQueryListInput);

        modules.setOrder(2);
        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "encodeSetRTCUserInfo",
      value: function encodeSetRTCUserInfo(key, value) {
        var modules = this._codec.getModule(PBName.RtcValueInfo);

        modules.setKey(key);
        modules.setValue(value);
        return modules.getArrayData();
      }
      /**
       * 待完善注释
      */

    }, {
      key: "encodeRemoveRTCUserInfo",
      value: function encodeRemoveRTCUserInfo(keys) {
        var modules = this._codec.getModule(PBName.RtcKeyDeleteInput);

        modules.setKey(keys);
        return modules.getArrayData();
      }
    }]);

    return DataCodec;
  }();

  /**
   * 数据通道接口，为 long-polling 与 websocket 提供公共抽象
   */

  var ADataChannel = function ADataChannel(type, _watcher) {
    _classCallCheck(this, ADataChannel);

    this._watcher = _watcher;
    this.codec = new DataCodec(type);
  };

  var _getIdentifier = function getIdentifier(messageId, identifier) {
    if (messageId && identifier) {
      return identifier + '_' + messageId;
    } else if (messageId) {
      return messageId;
    } else {
      return Date.now(); // 若无 messageId、identifer, 直接返回时间戳, 避免返回空造成唯一标识重复
    }
  };
  var BaseReader = /*#__PURE__*/function () {
    function BaseReader(header) {
      _classCallCheck(this, BaseReader);

      this.header = header;
      this._name = null;
      this.lengthSize = 0;
      this.messageId = 0;
      this.timestamp = 0;
      this.syncMsg = false;
      this.identifier = ''; // string + messageId 作为唯一标识, 目前用处: 方便 Pub、Query 回执定位对应 Promise, 且增加前缀避免 Pub、Query 回执错乱
    }

    _createClass(BaseReader, [{
      key: "getIdentifier",
      value: function getIdentifier() {
        var messageId = this.messageId,
            identifier = this.identifier;
        return _getIdentifier(messageId, identifier);
      }
    }, {
      key: "read",
      value: function read(stream, length) {
        this.readMessage(stream, length); // return { stream, length }
      }
    }, {
      key: "readMessage",
      value: function readMessage(stream, length) {
        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return BaseReader;
  }();
  /**
   * @description
   * 写数据处理基类
   */

  var BaseWriter = /*#__PURE__*/function () {
    function BaseWriter(headerType) {
      _classCallCheck(this, BaseWriter);

      this.lengthSize = 0;
      this.messageId = 0;
      this.topic = '';
      this.targetId = '';
      this.identifier = '';
      this._header = new Header(headerType, false, QOS.AT_MOST_ONCE, false);
    }

    _createClass(BaseWriter, [{
      key: "getIdentifier",
      value: function getIdentifier() {
        var messageId = this.messageId,
            identifier = this.identifier;
        return _getIdentifier(messageId, identifier);
      }
    }, {
      key: "write",
      value: function write(stream) {
        var headerCode = this.getHeaderFlag();
        stream.write(headerCode); // 写入 Header

        this.writeMessage(stream);
      }
    }, {
      key: "setHeaderQos",
      value: function setHeaderQos(qos) {
        this._header.qos = qos;
      }
    }, {
      key: "getHeaderFlag",
      value: function getHeaderFlag() {
        return this._header.encode();
      }
    }, {
      key: "getLengthSize",
      value: function getLengthSize() {
        return this.lengthSize;
      }
    }, {
      key: "getBufferData",
      value: function getBufferData() {
        var stream = new RongStreamWriter();
        this.write(stream);
        var val = stream.getBytesArray();
        var binary = new Int8Array(val);
        return binary;
      }
    }, {
      key: "getCometData",
      value: function getCometData() {
        var data = this.data || {};
        return JSON.stringify(data);
      }
    }]);

    return BaseWriter;
  }();
  /**
   * @description
   * 连接成功后服务端的回执
   */

  var ConnAckReader = /*#__PURE__*/function (_BaseReader) {
    _inherits(ConnAckReader, _BaseReader);

    var _super = _createSuper(ConnAckReader);

    function ConnAckReader() {
      var _this;

      _classCallCheck(this, ConnAckReader);

      _this = _super.apply(this, arguments);
      _this._name = MessageName.CONN_ACK;
      _this.status = null; // 链接状态

      _this.userId = null; // 用户 id
      // sessionId: string;

      _this.timestamp = 0;
      return _this;
    }

    _createClass(ConnAckReader, [{
      key: "readMessage",
      value: function readMessage(stream, length) {
        stream.readByte(); // 去除 Header

        this.status = +stream.readByte();

        if (length > ConnAckReader.MESSAGE_LENGTH) {
          this.userId = stream.readUTF();
          stream.readUTF(); // 此处为取 sessionId, ws 未用到此值, 但也需执行, 否则读取后面数值时会不准

          this.timestamp = stream.readLong();
        }

        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return ConnAckReader;
  }(BaseReader);
  ConnAckReader.MESSAGE_LENGTH = 2;
  /**
   * @description
   * 服务端断开链接. 比如: 被踢
   */

  var DisconnectReader = /*#__PURE__*/function (_BaseReader2) {
    _inherits(DisconnectReader, _BaseReader2);

    var _super2 = _createSuper(DisconnectReader);

    function DisconnectReader() {
      var _this2;

      _classCallCheck(this, DisconnectReader);

      _this2 = _super2.apply(this, arguments);
      _this2._name = MessageName.DISCONNECT;
      _this2.status = 0;
      return _this2;
    }

    _createClass(DisconnectReader, [{
      key: "readMessage",
      value: function readMessage(stream, length) {
        stream.readByte(); // (1)、此处未转换为链接状态码  (2)、2.0 代码限制了 status 为 0 - 5, 不在范围内则报错. 此处去掉此判断

        this.status = +stream.readByte();
        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return DisconnectReader;
  }(BaseReader);
  DisconnectReader.MESSAGE_LENGTH = 2;
  /**
   * @description
   * ping 请求
   */

  var PingReqWriter = /*#__PURE__*/function (_BaseWriter) {
    _inherits(PingReqWriter, _BaseWriter);

    var _super3 = _createSuper(PingReqWriter);

    function PingReqWriter() {
      var _this3;

      _classCallCheck(this, PingReqWriter);

      _this3 = _super3.call(this, OperationType.PING_REQ);
      _this3._name = MessageName.PING_REQ;
      return _this3;
    }

    _createClass(PingReqWriter, [{
      key: "writeMessage",
      value: function writeMessage(stream) {}
    }]);

    return PingReqWriter;
  }(BaseWriter);
  /**
   * @description
   * ping 响应
   */

  var PingRespReader = /*#__PURE__*/function (_BaseReader3) {
    _inherits(PingRespReader, _BaseReader3);

    var _super4 = _createSuper(PingRespReader);

    function PingRespReader(header) {
      var _this4;

      _classCallCheck(this, PingRespReader);

      _this4 = _super4.call(this, header);
      _this4._name = MessageName.PING_RESP;
      return _this4;
    }

    return PingRespReader;
  }(BaseReader);
  var RetryableReader = /*#__PURE__*/function (_BaseReader4) {
    _inherits(RetryableReader, _BaseReader4);

    var _super5 = _createSuper(RetryableReader);

    function RetryableReader() {
      var _this5;

      _classCallCheck(this, RetryableReader);

      _this5 = _super5.apply(this, arguments);
      _this5.messageId = 0;
      return _this5;
    }

    _createClass(RetryableReader, [{
      key: "readMessage",
      value: function readMessage(stream, length) {
        var msgId = stream.readByte() * 256 + stream.readByte();
        this.messageId = parseInt(msgId.toString(), 10);
        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return RetryableReader;
  }(BaseReader);
  var RetryableWriter = /*#__PURE__*/function (_BaseWriter2) {
    _inherits(RetryableWriter, _BaseWriter2);

    var _super6 = _createSuper(RetryableWriter);

    function RetryableWriter() {
      var _this6;

      _classCallCheck(this, RetryableWriter);

      _this6 = _super6.apply(this, arguments);
      _this6.messageId = 0;
      return _this6;
    }

    _createClass(RetryableWriter, [{
      key: "writeMessage",
      value: function writeMessage(stream) {
        var id = this.messageId;
        var lsb = id & 255;
        var msb = (id & 65280) >> 8; // 65280 -> 1111111100000000

        stream.write(msb);
        stream.write(lsb);
      }
    }]);

    return RetryableWriter;
  }(BaseWriter);
  var PublishReader = /*#__PURE__*/function (_RetryableReader) {
    _inherits(PublishReader, _RetryableReader);

    var _super7 = _createSuper(PublishReader);

    function PublishReader() {
      var _this7;

      _classCallCheck(this, PublishReader);

      _this7 = _super7.apply(this, arguments);
      _this7._name = MessageName.PUBLISH;
      _this7.topic = '';
      _this7.targetId = '';
      _this7.syncMsg = false;
      _this7.identifier = IDENTIFIER.PUB;
      return _this7;
    }

    _createClass(PublishReader, [{
      key: "readMessage",
      value: function readMessage(stream, length) {
        // let pos = 6;
        this.date = stream.readInt();
        this.topic = stream.readUTF(); // pos += BinaryHelper.writeUTF(this.topic).length;

        this.targetId = stream.readUTF(); // pos += BinaryHelper.writeUTF(this.targetId).length;
        // RetryableReader.prototype.readMessage.apply(this, arguments)

        _get(_getPrototypeOf(PublishReader.prototype), "readMessage", this).call(this, stream, length); // this.data = new Array(msgLength - pos);


        this.data = stream.readAll();
        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return PublishReader;
  }(RetryableReader);
  /**
   * @description
   * 发消息使用
   */

  var PublishWriter = /*#__PURE__*/function (_RetryableWriter) {
    _inherits(PublishWriter, _RetryableWriter);

    var _super8 = _createSuper(PublishWriter);

    function PublishWriter(topic, data, targetId) {
      var _this8;

      _classCallCheck(this, PublishWriter);

      _this8 = _super8.call(this, OperationType.PUBLISH);
      _this8._name = MessageName.PUBLISH;
      _this8.syncMsg = false;
      _this8.identifier = IDENTIFIER.PUB;
      _this8.topic = topic;
      _this8.data = isString(data) ? BinaryHelper.writeUTF(data) : data;
      _this8.targetId = targetId;
      return _this8;
    }

    _createClass(PublishWriter, [{
      key: "writeMessage",
      value: function writeMessage(stream) {
        stream.writeUTF(this.topic);
        stream.writeUTF(this.targetId);

        _get(_getPrototypeOf(PublishWriter.prototype), "writeMessage", this).call(this, stream);

        stream.write(this.data);
      }
    }]);

    return PublishWriter;
  }(RetryableWriter);
  /**
   * @description
   * 发消息, Server 给的 Ack 回执
   */

  var PubAckReader = /*#__PURE__*/function (_RetryableReader2) {
    _inherits(PubAckReader, _RetryableReader2);

    var _super9 = _createSuper(PubAckReader);

    function PubAckReader() {
      var _this9;

      _classCallCheck(this, PubAckReader);

      _this9 = _super9.apply(this, arguments);
      _this9._name = MessageName.PUB_ACK;
      _this9.status = 0;
      _this9.date = 0;
      _this9.millisecond = 0;
      _this9.messageUId = '';
      _this9.timestamp = 0;
      _this9.identifier = IDENTIFIER.PUB;
      _this9.topic = '';
      _this9.targetId = '';
      return _this9;
    }

    _createClass(PubAckReader, [{
      key: "readMessage",
      value: function readMessage(stream, length) {
        _get(_getPrototypeOf(PubAckReader.prototype), "readMessage", this).call(this, stream, length);

        this.date = stream.readInt();
        this.status = stream.readByte() * 256 + stream.readByte();
        this.millisecond = stream.readByte() * 256 + stream.readByte();
        this.timestamp = this.date * 1000 + this.millisecond;
        this.messageUId = stream.readUTF();
        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return PubAckReader;
  }(RetryableReader);
  /**
   * @description
   * Server 下发 Pub, Web 给 Server 发送回执
   */

  var PubAckWriter = /*#__PURE__*/function (_RetryableWriter2) {
    _inherits(PubAckWriter, _RetryableWriter2);

    var _super10 = _createSuper(PubAckWriter);

    function PubAckWriter(messageId) {
      var _this10;

      _classCallCheck(this, PubAckWriter);

      _this10 = _super10.call(this, OperationType.PUB_ACK);
      _this10._name = MessageName.PUB_ACK;
      _this10.status = 0;
      _this10.date = 0;
      _this10.millisecond = 0;
      _this10.messageUId = '';
      _this10.timestamp = 0;
      _this10.messageId = messageId;
      return _this10;
    }

    _createClass(PubAckWriter, [{
      key: "writeMessage",
      value: function writeMessage(stream) {
        _get(_getPrototypeOf(PubAckWriter.prototype), "writeMessage", this).call(this, stream);
      }
    }]);

    return PubAckWriter;
  }(RetryableWriter);
  /**
   * @description
   * Web 主动查询
   */

  var QueryWriter = /*#__PURE__*/function (_RetryableWriter3) {
    _inherits(QueryWriter, _RetryableWriter3);

    var _super11 = _createSuper(QueryWriter);

    function QueryWriter(topic, data, targetId) {
      var _this11;

      _classCallCheck(this, QueryWriter);

      _this11 = _super11.call(this, OperationType.QUERY);
      _this11.name = MessageName.QUERY;
      _this11.identifier = IDENTIFIER.QUERY;
      _this11.topic = topic;
      _this11.data = isString(data) ? BinaryHelper.writeUTF(data) : data;
      _this11.targetId = targetId;
      return _this11;
    }

    _createClass(QueryWriter, [{
      key: "writeMessage",
      value: function writeMessage(stream) {
        stream.writeUTF(this.topic);
        stream.writeUTF(this.targetId); // RetryableWriter.prototype.writeMessage.call(this, stream)

        _get(_getPrototypeOf(QueryWriter.prototype), "writeMessage", this).call(this, stream);

        stream.write(this.data);
      }
    }]);

    return QueryWriter;
  }(RetryableWriter);
  /**
   * @description
   * Server 发送 Query, Web 给 Server 的回执
   */

  var QueryConWriter = /*#__PURE__*/function (_RetryableWriter4) {
    _inherits(QueryConWriter, _RetryableWriter4);

    var _super12 = _createSuper(QueryConWriter);

    function QueryConWriter(messageId) {
      var _this12;

      _classCallCheck(this, QueryConWriter);

      _this12 = _super12.call(this, OperationType.QUERY_CONFIRM);
      _this12._name = MessageName.QUERY_CON;
      _this12.messageId = messageId;
      return _this12;
    }

    return QueryConWriter;
  }(RetryableWriter);
  /**
   * @description
   * Server 对 Web 查询操作的回执
   */

  var QueryAckReader = /*#__PURE__*/function (_RetryableReader3) {
    _inherits(QueryAckReader, _RetryableReader3);

    var _super13 = _createSuper(QueryAckReader);

    function QueryAckReader() {
      var _this13;

      _classCallCheck(this, QueryAckReader);

      _this13 = _super13.apply(this, arguments);
      _this13._name = MessageName.QUERY_ACK;
      _this13.status = 0;
      _this13.identifier = IDENTIFIER.QUERY;
      _this13.topic = '';
      _this13.targetId = '';
      return _this13;
    }

    _createClass(QueryAckReader, [{
      key: "readMessage",
      value: function readMessage(stream, length) {
        // RetryableReader.prototype.readMessage.call(this, stream)
        _get(_getPrototypeOf(QueryAckReader.prototype), "readMessage", this).call(this, stream, length);

        this.date = stream.readInt();
        this.status = stream.readByte() * 256 + stream.readByte();
        this.data = stream.readAll(); // if (msgLength > 0) {
        //   this.data = new Array(msgLength - 8);
        //   this.data = stream.readAll();
        // }

        return {
          stream: stream,
          length: length
        };
      }
    }]);

    return QueryAckReader;
  }(RetryableReader);

  var getReaderByHeader = function getReaderByHeader(header) {
    var type = header.type;
    var msg;

    switch (type) {
      case OperationType.CONN_ACK:
        msg = new ConnAckReader(header);
        break;

      case OperationType.PUBLISH:
        msg = new PublishReader(header);
        msg.syncMsg = header.syncMsg;
        break;

      case OperationType.PUB_ACK:
        msg = new PubAckReader(header);
        break;

      case OperationType.QUERY_ACK:
        msg = new QueryAckReader(header);
        break;

      case OperationType.SUB_ACK:
      case OperationType.UNSUB_ACK:
      case OperationType.PING_RESP:
        msg = new PingRespReader(header);
        break;

      case OperationType.DISCONNECT:
        msg = new DisconnectReader(header);
        break;

      default:
        msg = new BaseReader(header);
        logger.error('No support for deserializing ' + type + ' messages');
    }

    return msg;
  };
  /**
   * 解析 websocket 收到的数据 ArrayBuffer 数据
   * @param {ArrayBuffer} data server 通过 webscoekt 传送的所有数据
   */


  var readWSBuffer = function readWSBuffer(data) {
    var arr = new Uint8Array(data);
    var stream = new RongStreamReader(arr);
    var flags = stream.readByte();
    var header = new Header(flags);
    var msg = getReaderByHeader(header);
    msg.read(stream, arr.length - 1);
    return msg;
  };
  var readCometData = function readCometData(data) {
    var flags = data.headerCode;
    var header = new Header(flags);
    var msg = getReaderByHeader(header); // utils.forEach(data, (item: any, key: string) => {
    //   if (key in msg) {
    //     msg[key] = item;
    //   }
    // });

    for (var key in data) {
      // if (key in msg) {
      msg[key] = data[key]; // }
    }

    return msg;
  };

  /**
   * CMP/Comet 服务连接应答码
   */
  var ConnectResultCode = {
    /**
     * 连接成功
     */
    ACCEPTED: 0,

    /**
     * 协议版本不匹配
     * @description 暂未使用
     */
    UNACCEPTABLE_PROTOCOL_VERSION: 1,

    /**
     * 客户端（移动端 TCP 连接建立时）`info` 字段格式错误
     * @description 格式：`{平台类型}-{设备信息}-{sdk版本}`。
     * 其中设备信息为：{手机类型}{手机型号}{网络类型，4G/WIFI}{运营商标识, 移动/电信/联通}
     */
    IDENTIFIER_REJECTED: 2,

    /**
     * 不支持的平台类型，一般小程序或 PC 未开通
     */
    SERVER_UNAVAILABLE: 3,

    /**
     * Token无法解析，或Token已过期
     */
    TOKEN_INCORRECT: 4,

    /**
     * 防黑产规则相关应答
     */
    NOT_AUTHORIZED: 5,

    /**
     * 服务重定向，一般服务扩缩容时，落点已经改变，此时 userId 链接到旧的节点时，会触发该错误。
     * 客户端收到该应答后须重新访问导航，重新获取 CMP 地址
     */
    REDIRECT: 6,

    /**
     * 暂未使用
     */
    PACKAGE_ERROR: 7,

    /**
     * 该 AppKey 已经封禁或删除
     */
    APP_BLOCK_OR_DELETE: 8,

    /**
     * 该用户 ID 已经被封禁
     */
    BLOCK: 9,

    /**
     * Token 已过期，暂未使用
     */
    TOKEN_EXPIRE: 10,

    /**
     * Token 中携带 deviceId 时，检测 Token 中 deviceId 与链接设备 deviceId 不一致
     */
    DEVICE_ERROR: 11,

    /**
     * Web 端设置安全域名后，连接端域名不在安全域名范围内
     */
    HOSTNAME_ERROR: 12,

    /**
     * 开启`禁止把已在线客户端踢下线`开关后，该错误码标识已有同类型端在线，禁止链接
     */
    HASOHTERSAMECLIENTONLINE: 13
  };

  /**
   * 连接状态
   */
  var ConnectionStatus;

  (function (ConnectionStatus) {
    /**
     * 连接成功。
     */
    ConnectionStatus[ConnectionStatus["CONNECTED"] = 0] = "CONNECTED";
    /**
     * 连接中。
     */

    ConnectionStatus[ConnectionStatus["CONNECTING"] = 1] = "CONNECTING";
    /**
     * 正常断开连接。
     */

    ConnectionStatus[ConnectionStatus["DISCONNECTED"] = 2] = "DISCONNECTED";
    /**
     * 网络不可用。
     */

    ConnectionStatus[ConnectionStatus["NETWORK_UNAVAILABLE"] = 3] = "NETWORK_UNAVAILABLE";
    /**
     * 连接关闭。
     */

    ConnectionStatus[ConnectionStatus["CONNECTION_CLOSED"] = 4] = "CONNECTION_CLOSED";
    /**
     * 用户账户在其他设备登录，本机会被踢掉线。
     */

    ConnectionStatus[ConnectionStatus["KICKED_OFFLINE_BY_OTHER_CLIENT"] = 6] = "KICKED_OFFLINE_BY_OTHER_CLIENT";
    /**
     * websocket 连接失败
     */

    ConnectionStatus[ConnectionStatus["WEBSOCKET_UNAVAILABLE"] = 7] = "WEBSOCKET_UNAVAILABLE";
    /**
     * websocket 报错
     */

    ConnectionStatus[ConnectionStatus["WEBSOCKET_ERROR"] = 8] = "WEBSOCKET_ERROR";
    /**
     * 用户被封禁
     */

    ConnectionStatus[ConnectionStatus["BLOCKED"] = 9] = "BLOCKED";
    /**
     * 域名错误
     */

    ConnectionStatus[ConnectionStatus["DOMAIN_INCORRECT"] = 12] = "DOMAIN_INCORRECT";
    /**
     * 服务器主动断开
     */

    ConnectionStatus[ConnectionStatus["DISCONNECT_BY_SERVER"] = 13] = "DISCONNECT_BY_SERVER";
    /**
     * 重定向
     */

    ConnectionStatus[ConnectionStatus["REDIRECT"] = 14] = "REDIRECT";
    /**
     * appkey 不正确
     */

    ConnectionStatus[ConnectionStatus["APPKEY_IS_FAKE"] = 20] = "APPKEY_IS_FAKE";
    /**
     * 互踢次数过多（`count > 5`），此时可能出现：在其它他设备登陆有 reconnect 逻辑
     */

    ConnectionStatus[ConnectionStatus["ULTRALIMIT"] = 1101] = "ULTRALIMIT";
    /**
     * 开始请求导航
     */

    ConnectionStatus[ConnectionStatus["REQUEST_NAVI"] = 201] = "REQUEST_NAVI";
    /**
     * 请求导航结束
     */

    ConnectionStatus[ConnectionStatus["RESPONSE_NAVI"] = 202] = "RESPONSE_NAVI";
    /**
     *  请求导航失败
     */

    ConnectionStatus[ConnectionStatus["RESPONSE_NAVI_ERROR"] = 203] = "RESPONSE_NAVI_ERROR";
    /**
     *  请求导航超时
     */

    ConnectionStatus[ConnectionStatus["RESPONSE_NAVI_TIMEOUT"] = 204] = "RESPONSE_NAVI_TIMEOUT";
  })(ConnectionStatus || (ConnectionStatus = {}));

  var ConnectionStatus$1 = ConnectionStatus;

  /* eslint-disable camelcase */

  /**
   * 信令名
   */
  var Topic;

  (function (Topic) {
    /** 发送消息进入离线消息存储，接收者不在线时，可转推送 */
    Topic[Topic["ppMsgP"] = 1] = "ppMsgP";
    /** 发送消息进入离线消息存储，接收者不在线时，不转推送 */

    Topic[Topic["ppMsgN"] = 2] = "ppMsgN";
    /** 发送消息不进入离线存储，用户在线时直发到接收者，不在线时消息丢弃，不转推送 */

    Topic[Topic["ppMsgS"] = 3] = "ppMsgS";
    Topic[Topic["pgMsgP"] = 4] = "pgMsgP";
    Topic[Topic["chatMsg"] = 5] = "chatMsg";
    Topic[Topic["pcMsgP"] = 6] = "pcMsgP";
    Topic[Topic["qryPMsg"] = 7] = "qryPMsg";
    Topic[Topic["qryGMsg"] = 8] = "qryGMsg";
    Topic[Topic["qryCHMsg"] = 9] = "qryCHMsg";
    Topic[Topic["qryCMsg"] = 10] = "qryCMsg";
    Topic[Topic["qrySMsg"] = 11] = "qrySMsg";
    Topic[Topic["recallMsg"] = 12] = "recallMsg";
    Topic[Topic["prMsgS"] = 13] = "prMsgS";
    /** 消息通知拉取 */

    Topic[Topic["s_ntf"] = 14] = "s_ntf";
    /** 服务直发消息 */

    Topic[Topic["s_msg"] = 15] = "s_msg";
    /**
     * 状态同步
     * @todo 需确定同步哪些状态
     */

    Topic[Topic["s_stat"] = 16] = "s_stat";
    /** 服务端通知：聊天室 kv 、会话状态 */

    Topic[Topic["s_cmd"] = 17] = "s_cmd";
    /** 实时配置变更通知 */

    Topic[Topic["s_us"] = 18] = "s_us";
    /** 拉取实时配置 */

    Topic[Topic["pullUS"] = 19] = "pullUS";
    Topic[Topic["pgMsgS"] = 20] = "pgMsgS";
    Topic[Topic["chatMsgS"] = 21] = "chatMsgS";
    Topic[Topic["qrySessionsAtt"] = 22] = "qrySessionsAtt";
    Topic[Topic["pullMsg"] = 23] = "pullMsg";
    Topic[Topic["qrySessions"] = 24] = "qrySessions";
    Topic[Topic["delSessions"] = 25] = "delSessions";
    Topic[Topic["delMsg"] = 26] = "delMsg";
    Topic[Topic["updRRTime"] = 27] = "updRRTime";
    /** 拉取聊天室消息 */

    Topic[Topic["chrmPull"] = 28] = "chrmPull";
    Topic[Topic["joinChrm"] = 29] = "joinChrm";
    Topic[Topic["joinChrmR"] = 30] = "joinChrmR";
    Topic[Topic["exitChrm"] = 31] = "exitChrm";
    Topic[Topic["queryChrmI"] = 32] = "queryChrmI";
    Topic[Topic["setKV"] = 33] = "setKV";
    Topic[Topic["delKV"] = 34] = "delKV";
    /** 拉取聊天室 KV 存储 */

    Topic[Topic["pullKV"] = 35] = "pullKV";
    Topic[Topic["qryRelation"] = 36] = "qryRelation";
    Topic[Topic["delRelation"] = 37] = "delRelation";
    Topic[Topic["pullSeAtts"] = 38] = "pullSeAtts";
    Topic[Topic["setSeAtt"] = 39] = "setSeAtt";
    Topic[Topic["qnTkn"] = 40] = "qnTkn";
    Topic[Topic["qnUrl"] = 41] = "qnUrl";
    Topic[Topic["aliUrl"] = 42] = "aliUrl";
    Topic[Topic["s3Url"] = 43] = "s3Url";
    Topic[Topic["cleanPMsg"] = 44] = "cleanPMsg";
    Topic[Topic["cleanGMsg"] = 45] = "cleanGMsg";
    Topic[Topic["cleanCMsg"] = 46] = "cleanCMsg";
    Topic[Topic["cleanSMsg"] = 47] = "cleanSMsg";
    Topic[Topic["rtcRJoin_data"] = 48] = "rtcRJoin_data";
    Topic[Topic["rtcRExit"] = 49] = "rtcRExit";
    Topic[Topic["rtcPing"] = 50] = "rtcPing";
    Topic[Topic["rtcSetData"] = 51] = "rtcSetData";
    /** 全量 URI 资源变更 */

    Topic[Topic["userSetData"] = 52] = "userSetData";
    Topic[Topic["rtcQryData"] = 53] = "rtcQryData";
    Topic[Topic["rtcDelData"] = 54] = "rtcDelData";
    Topic[Topic["rtcSetOutData"] = 55] = "rtcSetOutData";
    Topic[Topic["rtcQryUserOutData"] = 56] = "rtcQryUserOutData";
    Topic[Topic["rtcToken"] = 57] = "rtcToken";
    Topic[Topic["rtcUserState"] = 58] = "rtcUserState";
    Topic[Topic["rtcRInfo"] = 59] = "rtcRInfo";
    Topic[Topic["rtcUData"] = 60] = "rtcUData";
    Topic[Topic["rtcUPut"] = 61] = "rtcUPut";
    Topic[Topic["rtcUDel"] = 62] = "rtcUDel";
    Topic[Topic["rtcUList"] = 63] = "rtcUList";
    Topic[Topic["addSeTag"] = 64] = "addSeTag";
    Topic[Topic["delSeTag"] = 65] = "delSeTag";
    Topic[Topic["addTag"] = 66] = "addTag";
    Topic[Topic["delTag"] = 67] = "delTag";
    Topic[Topic["disTag"] = 68] = "disTag"; // 解除会话标签关系
  })(Topic || (Topic = {}));

  var Topic$1 = Topic;

  /**
   * 通过 /ping 接口确定目标导航是否可用，并根据响应速度排序
   * @todo 需确认该嗅探的必要性，并确定是否需要删除
   * @param hosts
   * @param protocol
   * @param runtime
   */

  var getValidHosts = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(hosts, protocol, runtime) {
      var pingRes;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return Promise.all(hosts.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(host) {
                  var now, url, res;
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          now = Date.now();
                          url = "".concat(protocol, "://").concat(host, "/ping?r=").concat(randomNum(1000, 9999));
                          _context.next = 4;
                          return runtime.httpReq({
                            url: url,
                            timeout: PING_REQ_TIMEOUT
                          });

                        case 4:
                          res = _context.sent;
                          return _context.abrupt("return", {
                            status: res.status,
                            host: host,
                            cost: Date.now() - now
                          });

                        case 6:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x4) {
                  return _ref2.apply(this, arguments);
                };
              }()));

            case 2:
              pingRes = _context2.sent;
              // 清理无效地址
              pingRes = pingRes.filter(function (item) {
                return item.status === 200;
              }); // 按响应时间排序

              if (pingRes.length > 1) {
                pingRes = pingRes.sort(function (a, b) {
                  return a.cost - b.cost;
                });
              }

              return _context2.abrupt("return", pingRes.map(function (item) {
                return item.host;
              }));

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function getValidHosts(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  var formatWSUrl = function formatWSUrl(protocol, host, appkey, token, runtime, apiVersion, pid) {
    return "".concat(protocol, "://").concat(host, "/websocket?appId=").concat(appkey, "&token=").concat(encodeURIComponent(token), "&sdkVer=").concat(apiVersion, "&pid=").concat(pid, "&apiVer=").concat(runtime.isFromUniapp ? 'uniapp' : 'normal').concat(runtime.connectPlatform ? '&platform=' + runtime.connectPlatform : '');
  };
  var formatResolveKey = function formatResolveKey(messageId, identifier) {
    return [messageId, identifier].join('-');
  };
  var isStatusMessage = function isStatusMessage(topic) {
    return [Topic$1.ppMsgS, Topic$1.pgMsgS, Topic$1.chatMsgS].map(function (item) {
      return Topic$1[item];
    }).indexOf(topic) >= 0;
  };

  /**
   * 服务器推送的 DisconnectAck 信令状态码
   */
  var DisconnectReason;

  (function (DisconnectReason) {
    /**
     * 重定向（兼容老版本）
     */
    DisconnectReason[DisconnectReason["REDIRECT"] = 0] = "REDIRECT";
    /**
     * 其他端登录
     */

    DisconnectReason[DisconnectReason["OTHER_DEVICE_LOGIN"] = 1] = "OTHER_DEVICE_LOGIN";
    /**
     * 用户被封禁（兼容老版本）
     */

    DisconnectReason[DisconnectReason["BLOCK"] = 2] = "BLOCK";
    /**
     * 服务器端关闭连接，收到时直接 SDK 内部重连
     */

    DisconnectReason[DisconnectReason["REMOTE_CLOSE"] = 3] = "REMOTE_CLOSE";
    /**
     * 注销登录，web 不涉及无需处理
     */

    DisconnectReason[DisconnectReason["LOGOUT"] = 4] = "LOGOUT";
    /**
     * 用户被封禁
     */

    DisconnectReason[DisconnectReason["BLOCK_NEW"] = 5] = "BLOCK_NEW";
    /**
     * 重定向，SDK 需重新取导航进行重连尝试
     */

    DisconnectReason[DisconnectReason["REDIRECT_NEW"] = 6] = "REDIRECT_NEW";
  })(DisconnectReason || (DisconnectReason = {}));

  var sendWSData = function sendWSData(writer, socket) {
    if (!(writer instanceof PingReqWriter)) {
      logger.debug('Websocket ==>', writer);
    }

    var binary = writer.getBufferData();
    socket.send(binary.buffer);
  };
  /**
   * @todo 迁移中的 DataCodec 模块导致数据通道不够独立，与 xhr-polling 通信可能会有耦合，后续需解耦
   * @description
   * 1. 基于 WebSocket 协议建立数据通道，实现数据收发
   * 2. 基于 Protobuf 进行数据编解码
   */


  var WebSocketChannel = /*#__PURE__*/function (_ADataChannel) {
    _inherits(WebSocketChannel, _ADataChannel);

    var _super = _createSuper(WebSocketChannel);

    // 为避免 Circular dependency，此处 runtime 通过参数传入而非全局获取
    function WebSocketChannel(_runtime, watcher) {
      var _this;

      _classCallCheck(this, WebSocketChannel);

      _this = _super.call(this, 'websocket', watcher);
      _this._runtime = _runtime;
      _this._socket = null;
      /**
       * 本端发送消息时等待接收 PubAck 的 Promise.resolve 函数
       */

      _this._messageIds = {};
      /**
       * 接收多端同步消息时，等待 PubAck 的 Promise.resolve 函数
       */

      _this._syncMessageIds = {};
      /**
       * 当前累计心跳超时次数
       */

      _this._failedCount = 0;
      /**
       * 允许连续 PING 超时次数，次数内不主动关闭连接
       */

      _this.ALLOW_FAILED_TIMES = 4;
      /**
       * 有效值 0 - 65535，超出 65535 位数超长溢出
       */

      _this._idCount = 0;

      _this._generateMessageId = function () {
        if (_this._idCount >= 65535) {
          _this._idCount = 0;
        }

        return ++_this._idCount;
      };

      return _this;
    }
    /**
     * 建立 websocket 连接
     * @param appkey
     * @param token
     * @param hosts
     * @param protocol
     * @param apiVersion - apiVersion 需符合 `/\d+(\.\d+){2}/` 规则
     */


    _createClass(WebSocketChannel, [{
      key: "connect",
      value: function () {
        var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(appkey, token, hosts, protocol, apiVersion) {
          var _this2 = this;

          var validHosts, wsProtocol, _loop, i, len, _ret;

          return regeneratorRuntime.wrap(function _callee$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // 祛除预发布包中的预发布标签，取真实版本号
                  apiVersion = matchVersion(apiVersion); // 通知连接中

                  this._watcher.status(ConnectionStatus$1.CONNECTING); // 检索有效地址


                  _context2.next = 4;
                  return getValidHosts(hosts, protocol, this._runtime);

                case 4:
                  validHosts = _context2.sent;

                  if (!(validHosts.length === 0)) {
                    _context2.next = 8;
                    break;
                  }

                  logger.error('No valid websocket server hosts!');
                  return _context2.abrupt("return", ErrorCode$1.RC_SOCKET_NOT_CREATED);

                case 8:
                  // 确定连接协议：http -> ws, https -> wss
                  wsProtocol = protocol.replace('http', 'ws'); // 逐个尝试建立 websocket 连接

                  _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop(i, len) {
                    var url, socket, disconnected, code;
                    return regeneratorRuntime.wrap(function _loop$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            url = formatWSUrl(wsProtocol, validHosts[i], appkey, token, _this2._runtime, apiVersion); // 创建 socket，若超时一定时间未收到 ConnAck 确认，则视为连接超时

                            socket = _this2._runtime.createWebSocket(url); // 服务连接非主动断开，尝试重连

                            disconnected = function disconnected(code) {
                              if (_this2._socket === socket) {
                                _this2._socket = null;

                                _this2._watcher.status(code);
                              }
                            }; // 等待连接结果


                            _context.next = 5;
                            return new Promise(function (resolve) {
                              socket.onMessage(function (data) {
                                if (Object.prototype.toString.call(data) !== '[object ArrayBuffer]') {
                                  logger.error('Socket received invalid data:', data);
                                  return;
                                }

                                var signal = readWSBuffer(data); // Ping 响应

                                if (signal instanceof PingRespReader && _this2._pingResolve) {
                                  _this2._pingResolve(ErrorCode$1.SUCCESS);

                                  _this2._pingResolve = undefined;
                                  return;
                                }

                                logger.debug('Websocket <==', signal); // 连接回执

                                if (signal instanceof ConnAckReader) {
                                  if (signal.status !== ConnectResultCode.ACCEPTED) {
                                    logger.error('Websocket connAck status:', signal.status);
                                    resolve(signal.status);
                                    return;
                                  }

                                  _this2.connectedTime = signal.timestamp;
                                  _this2.userId = signal.userId || '';
                                  resolve(ErrorCode$1.SUCCESS);
                                  return;
                                } // 服务器主动断开


                                if (signal instanceof DisconnectReader) {
                                  var status = signal.status;

                                  switch (status) {
                                    case DisconnectReason.BLOCK:
                                      _this2._watcher.status(ConnectionStatus$1.BLOCKED);

                                      break;

                                    case DisconnectReason.OTHER_DEVICE_LOGIN:
                                      _this2._watcher.status(ConnectionStatus$1.KICKED_OFFLINE_BY_OTHER_CLIENT);

                                      break;

                                    case DisconnectReason.REDIRECT_NEW:
                                      _this2._watcher.status(ConnectionStatus$1.REDIRECT);

                                      break;

                                    default:
                                      _this2._watcher.status(ConnectionStatus$1.DISCONNECT_BY_SERVER);

                                      break;
                                  }

                                  return;
                                } // 非连接信令处理


                                _this2._onReceiveSignal(signal);
                              });
                              socket.onClose(function (code, reason) {
                                logger.warn('websocket closed! code:', code, 'reason:', reason);
                                disconnected(ConnectionStatus$1.CONNECTION_CLOSED);
                                resolve(code);
                              });
                              socket.onError(function (error) {
                                logger.error('websocket error!', error);
                                disconnected(ConnectionStatus$1.WEBSOCKET_ERROR);
                                resolve(ErrorCode$1.NETWORK_ERROR);
                              });
                              socket.onOpen(function () {
                                return logger.debug('websocket open =>', url);
                              }); // ConnAck 超时

                              timerSetTimeout(function () {
                                resolve(ErrorCode$1.TIMEOUT);
                              }, WEB_SOCKET_TIMEOUT);
                            });

                          case 5:
                            code = _context.sent;

                            if (!(code === ErrorCode$1.SUCCESS)) {
                              _context.next = 11;
                              break;
                            }

                            _this2._socket = socket; // 启动定时心跳

                            _this2._checkAlive(); // 通知上层连接成功


                            _this2._watcher.status(ConnectionStatus$1.CONNECTED);

                            return _context.abrupt("return", {
                              v: code
                            });

                          case 11:
                            socket.close();

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _loop);
                  });
                  i = 0, len = validHosts.length;

                case 11:
                  if (!(i < len)) {
                    _context2.next = 19;
                    break;
                  }

                  return _context2.delegateYield(_loop(i, len), "t0", 13);

                case 13:
                  _ret = _context2.t0;

                  if (!(_typeof(_ret) === "object")) {
                    _context2.next = 16;
                    break;
                  }

                  return _context2.abrupt("return", _ret.v);

                case 16:
                  i += 1;
                  _context2.next = 11;
                  break;

                case 19:
                  return _context2.abrupt("return", ErrorCode$1.RC_NET_UNAVAILABLE);

                case 20:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee, this);
        }));

        function connect(_x, _x2, _x3, _x4, _x5) {
          return _connect.apply(this, arguments);
        }

        return connect;
      }()
    }, {
      key: "_checkAlive",
      value: function () {
        var _checkAlive2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var _this3 = this;

          var code, _this$_socket;

          return regeneratorRuntime.wrap(function _callee2$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (this._socket) {
                    _context3.next = 2;
                    break;
                  }

                  return _context3.abrupt("return");

                case 2:
                  this.sendOnly(new PingReqWriter()); // 等待响应

                  _context3.next = 5;
                  return new Promise(function (resolve) {
                    _this3._pingResolve = resolve;
                    setTimeout(function () {
                      _this3._pingResolve = undefined;
                      resolve(ErrorCode$1.TIMEOUT);
                    }, IM_SIGNAL_TIMEOUT);
                  });

                case 5:
                  code = _context3.sent;

                  if (!(code !== ErrorCode$1.SUCCESS && ++this._failedCount >= this.ALLOW_FAILED_TIMES)) {
                    _context3.next = 9;
                    break;
                  }

                  (_this$_socket = this._socket) === null || _this$_socket === void 0 ? void 0 : _this$_socket.close();
                  return _context3.abrupt("return");

                case 9:
                  this._failedCount = 0; // 重新定时任务

                  setTimeout(function () {
                    return _this3._checkAlive();
                  }, IM_PING_INTERVAL_TIME);

                case 11:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee2, this);
        }));

        function _checkAlive() {
          return _checkAlive2.apply(this, arguments);
        }

        return _checkAlive;
      }()
    }, {
      key: "_onReceiveSignal",
      value: function () {
        var _onReceiveSignal2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(signal) {
          var _this4 = this;

          var messageId, identifier, isQosNeedAck, key, resolve, syncMsg, topic, ack;
          return regeneratorRuntime.wrap(function _callee3$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  messageId = signal.messageId, identifier = signal.identifier; // 检查是否为 Ack, 如果是, 则处理回执

                  isQosNeedAck = signal.header && signal.header.qos !== QOS.AT_MOST_ONCE;

                  if (isQosNeedAck) {
                    // Pub 回执
                    if (signal instanceof PublishReader && !signal.syncMsg) {
                      this.sendOnly(new PubAckWriter(messageId));
                    } // qry 回执


                    if (signal instanceof QueryAckReader) {
                      this.sendOnly(new QueryConWriter(messageId));
                    }
                  }

                  key = formatResolveKey(messageId, identifier); // 处理 pubAck、queryAck 回执

                  if (messageId > 0) {
                    resolve = this._messageIds[key];
                    resolve && resolve(signal); // 多端同步消息的 pubAck

                    this._syncMessageIds[key] && this._syncMessageIds[key](signal);
                  } // PublishReader 处理


                  if (!(signal instanceof PublishReader)) {
                    _context4.next = 15;
                    break;
                  }

                  syncMsg = signal.syncMsg, topic = signal.topic; // 非同步消息或者是状态消息（ppMsgS，pgMsgS，chatMsgS），则直接抛出到上层

                  if (!(!syncMsg || isStatusMessage(topic))) {
                    _context4.next = 10;
                    break;
                  }

                  this._watcher.signal(signal);

                  return _context4.abrupt("return");

                case 10:
                  _context4.next = 12;
                  return new Promise(function (resolve) {
                    _this4._syncMessageIds[key] = resolve;
                  });

                case 12:
                  ack = _context4.sent;
                  delete this._syncMessageIds[key];

                  this._watcher.signal(signal, ack);

                case 15:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee3, this);
        }));

        function _onReceiveSignal(_x6) {
          return _onReceiveSignal2.apply(this, arguments);
        }

        return _onReceiveSignal;
      }()
    }, {
      key: "sendOnly",
      value: function sendOnly(writer) {
        if (this._socket) {
          sendWSData(writer, this._socket);
        }
      }
    }, {
      key: "send",
      value: function () {
        var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(writer, respPBName, option) {
          var _this5 = this;

          var timeout,
              messageId,
              identifier,
              respSignal,
              data,
              _args5 = arguments;
          return regeneratorRuntime.wrap(function _callee4$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  timeout = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : IM_SIGNAL_TIMEOUT;

                  if (!this._socket) {
                    _context5.next = 15;
                    break;
                  }

                  messageId = this._generateMessageId();
                  writer.messageId = messageId;
                  identifier = writer.identifier;
                  sendWSData(writer, this._socket); // 等待响应结果

                  _context5.next = 8;
                  return new Promise(function (resolve) {
                    var key = formatResolveKey(messageId, identifier);
                    _this5._messageIds[key] = resolve;
                    setTimeout(function () {
                      delete _this5._messageIds[key];
                      resolve(); // 无值认为 timeout 超时
                    }, timeout);
                  });

                case 8:
                  respSignal = _context5.sent;

                  if (respSignal) {
                    _context5.next = 11;
                    break;
                  }

                  return _context5.abrupt("return", {
                    code: ErrorCode$1.TIMEOUT
                  });

                case 11:
                  if (!(respSignal.status !== 0)) {
                    _context5.next = 13;
                    break;
                  }

                  return _context5.abrupt("return", {
                    code: respSignal.status
                  });

                case 13:
                  data = respPBName ? this.codec.decodeByPBName(respSignal.data, respPBName, option) : respSignal;
                  return _context5.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: data
                  });

                case 15:
                  return _context5.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 16:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee4, this);
        }));

        function send(_x7, _x8, _x9) {
          return _send.apply(this, arguments);
        }

        return send;
      }()
    }, {
      key: "close",
      value: function close() {
        if (this._socket) {
          this._socket.close();

          this._socket = null;

          this._watcher.status(ConnectionStatus$1.DISCONNECTED);
        }
      }
    }]);

    return WebSocketChannel;
  }(ADataChannel);

  exports.HttpMethod = void 0;

  (function (HttpMethod) {
    HttpMethod["GET"] = "GET";
    HttpMethod["POST"] = "POST";
  })(exports.HttpMethod || (exports.HttpMethod = {}));

  var isValidJSON = function isValidJSON(jsonStr) {
    if (isObject$1(jsonStr)) {
      return true;
    }

    var isValid = false;

    try {
      var obj = JSON.parse(jsonStr);
      var str = JSON.stringify(obj);
      isValid = str === jsonStr;
    } catch (e) {
      isValid = false;
    }

    return isValid;
  };

  var CometChannel = /*#__PURE__*/function (_ADataChannel) {
    _inherits(CometChannel, _ADataChannel);

    var _super = _createSuper(CometChannel);

    function CometChannel(_runtime, watcher) {
      var _this;

      _classCallCheck(this, CometChannel);

      _this = _super.call(this, 'comet', watcher);
      _this._runtime = _runtime;
      _this._messageIds = {};
      _this._syncMessageIds = {};
      _this._idCount = 0;

      _this._generateMessageId = function () {
        return ++_this._idCount;
      };

      _this._pid = encodeURIComponent(new Date().getTime() + Math.random() + '');
      return _this;
    }
    /**
     * 长轮询结果处理
     * @param data
     */


    _createClass(CometChannel, [{
      key: "handleCometRes",
      value: function handleCometRes(res) {
        var _this2 = this;

        if (res.status !== 200 && res.status !== 202) {
          return false;
        }

        var data = isString(res.data) ? JSON.parse(res.data) : res.data;

        if (!data) {
          logger.error('received data is not a validJson', data);
          return false;
        }

        if (!isArray$1(data)) {
          return true;
        }

        forEach(data, /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(item) {
            var sessionid, signal, messageId, _header, status, identifier, isQosNeedAck, key, resolve, writer, _writer, connStatus, syncMsg, topic, ack;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    sessionid = item.sessionid;

                    if (sessionid) {
                      _this2._sessionid = sessionid;
                    }

                    signal = readCometData(item);
                    messageId = signal.messageId, _header = signal._header, status = signal.status, identifier = signal.identifier;
                    isQosNeedAck = _header && _header.qos !== QOS.AT_MOST_ONCE;
                    key = formatResolveKey(messageId, identifier); // 处理 pubAck、queryAck 回执

                    if (messageId && signal.getIdentifier) {
                      resolve = _this2._messageIds[key];
                      resolve && resolve(signal); // 多端同步消息的 pubAck

                      _this2._syncMessageIds[key] && _this2._syncMessageIds[key](signal);
                    } // 是否需要发回执


                    if (isQosNeedAck) {
                      if (signal instanceof PublishReader && !signal.syncMsg) {
                        writer = new PubAckWriter(messageId);

                        _this2.sendOnly(writer);
                      }

                      if (signal instanceof QueryAckReader) {
                        _writer = new QueryConWriter(messageId);

                        _this2.sendOnly(_writer);
                      }
                    } // 连接状态断开


                    if (signal instanceof DisconnectReader) {
                      connStatus = status === 1 ? ConnectionStatus$1.KICKED_OFFLINE_BY_OTHER_CLIENT : status === 2 ? ConnectionStatus$1.BLOCKED : status;

                      _this2._watcher.status(connStatus);
                    } // 处理 publish


                    if (!(signal instanceof PublishReader)) {
                      _context.next = 19;
                      break;
                    }

                    syncMsg = signal.syncMsg, topic = signal.topic; // 非同步消息或者是状态消息（ppMsgS，pgMsgS，chatMsgS），则直接抛出到上层

                    if (!(!syncMsg || isStatusMessage(topic))) {
                      _context.next = 14;
                      break;
                    }

                    _this2._watcher.signal(signal);

                    return _context.abrupt("return", false);

                  case 14:
                    _context.next = 16;
                    return new Promise(function (resolve) {
                      _this2._syncMessageIds[key] = resolve;
                    });

                  case 16:
                    ack = _context.sent;
                    delete _this2._syncMessageIds[key];

                    _this2._watcher.signal(signal, ack);

                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());
        return true;
      }
      /**
       * 长轮询心跳
       */

    }, {
      key: "_startPullSignal",
      value: function () {
        var _startPullSignal2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(protocol) {
          var timestamp, url, res, isSuccess;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  timestamp = new Date().getTime();
                  url = "".concat(protocol, "://").concat(this._domain, "/pullmsg.js?sessionid=").concat(this._sessionid, "&timestrap=").concat(timestamp, "&pid=").concat(this._pid);
                  _context2.next = 4;
                  return this._runtime.httpReq({
                    url: url,
                    body: {
                      pid: this._pid
                    },
                    timeout: IM_COMET_PULLMSG_TIMEOUT
                  });

                case 4:
                  res = _context2.sent;
                  isSuccess = this.handleCometRes(res);

                  if (!this._isDisconnected) {
                    if (isSuccess) {
                      this._startPullSignal(protocol);
                    } else {
                      this._watcher.status(ConnectionStatus$1.NETWORK_UNAVAILABLE);

                      this.close();
                    }
                  }

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function _startPullSignal(_x2) {
          return _startPullSignal2.apply(this, arguments);
        }

        return _startPullSignal;
      }()
    }, {
      key: "connect",
      value: function () {
        var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(appkey, token, hosts, protocol, apiVersion) {
          var validHosts, handleConnectRes, i, len, url, res, response;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  // 祛除预发布包中的预发布标签，取真实版本号
                  apiVersion = matchVersion(apiVersion);
                  this._protocol = protocol;
                  this._isDisconnected = false;

                  this._watcher.status(ConnectionStatus$1.CONNECTING);

                  _context3.next = 6;
                  return getValidHosts(hosts, protocol, this._runtime);

                case 6:
                  validHosts = _context3.sent;

                  if (!(validHosts.length === 0)) {
                    _context3.next = 10;
                    break;
                  }

                  logger.error('No valid comet server hosts!');
                  return _context3.abrupt("return", ErrorCode$1.RC_SOCKET_NOT_CREATED);

                case 10:
                  /**
                   * 连接结果处理
                   */
                  handleConnectRes = function handleConnectRes(res) {
                    if (res.status !== 200 && res.status !== 202) {
                      return false;
                    }

                    if (res.data) {
                      if (!isValidJSON(res.data)) {
                        logger.error('received data is not a validJson', res.data);
                        return false;
                      }

                      return isObject$1(res.data) ? res.data : JSON.parse(res.data);
                    }

                    return false;
                  };

                  i = 0, len = validHosts.length;

                case 12:
                  if (!(i < len)) {
                    _context3.next = 29;
                    break;
                  }

                  url = formatWSUrl(protocol, validHosts[i], appkey, token, this._runtime, apiVersion, this._pid);
                  _context3.next = 16;
                  return this._runtime.httpReq({
                    url: url,
                    body: {
                      pid: this._pid
                    },
                    timeout: WEB_SOCKET_TIMEOUT
                  });

                case 16:
                  res = _context3.sent;
                  response = handleConnectRes(res);
                  this._domain = validHosts[i];

                  if (!(response && response.status === 0)) {
                    _context3.next = 26;
                    break;
                  }

                  this._watcher.status(ConnectionStatus$1.CONNECTED);

                  this._sessionid = response.sessionid;

                  this._startPullSignal(protocol);

                  this.userId = response.userId;
                  this.connectedTime = response.timestamp;
                  return _context3.abrupt("return", response.status);

                case 26:
                  i += 1;
                  _context3.next = 12;
                  break;

                case 29:
                  return _context3.abrupt("return", ErrorCode$1.RC_NET_UNAVAILABLE);

                case 30:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function connect(_x3, _x4, _x5, _x6, _x7) {
          return _connect.apply(this, arguments);
        }

        return connect;
      }()
    }, {
      key: "sendCometData",
      value: function () {
        var _sendCometData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(writer) {
          var _domain,
              _sessionid,
              _pid,
              messageId,
              topic,
              targetId,
              headerCode,
              url,
              res;

          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _domain = this._domain, _sessionid = this._sessionid, _pid = this._pid;
                  messageId = writer.messageId, topic = writer.topic, targetId = writer.targetId, writer.identifier;
                  headerCode = writer.getHeaderFlag();

                  if (topic) {
                    url = "".concat(this._protocol, "://").concat(_domain, "/websocket?messageid=").concat(messageId, "&header=").concat(headerCode, "&sessionid=").concat(_sessionid, "&topic=").concat(topic, "&targetid=").concat(targetId, "&pid=").concat(_pid);
                  } else {
                    url = "".concat(this._protocol, "://").concat(_domain, "/websocket?messageid=").concat(messageId, "&header=").concat(headerCode, "&sessionid=").concat(_sessionid, "&pid=").concat(_pid);
                  }

                  _context4.next = 7;
                  return this._runtime.httpReq({
                    url: url,
                    method: exports.HttpMethod.POST,
                    body: writer.getCometData()
                  });

                case 7:
                  res = _context4.sent;
                  this.handleCometRes(res);

                case 9:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function sendCometData(_x8) {
          return _sendCometData.apply(this, arguments);
        }

        return sendCometData;
      }()
    }, {
      key: "sendOnly",
      value: function sendOnly(writer) {
        this.sendCometData(writer);
      }
    }, {
      key: "send",
      value: function () {
        var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(writer, respPBName, option) {
          var _this3 = this;

          var timeout,
              messageId,
              identifier,
              respSignal,
              data,
              _args5 = arguments;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  timeout = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : IM_SIGNAL_TIMEOUT;
                  messageId = this._generateMessageId();
                  writer.messageId = messageId;
                  this.sendCometData(writer);
                  identifier = writer.identifier;
                  _context5.next = 7;
                  return new Promise(function (resolve) {
                    var key = formatResolveKey(messageId, identifier);
                    _this3._messageIds[key] = resolve;
                    setTimeout(function () {
                      delete _this3._messageIds[key];
                      resolve(); // 无值认为 timeout 超时
                    }, timeout);
                  });

                case 7:
                  respSignal = _context5.sent;

                  if (respSignal) {
                    _context5.next = 10;
                    break;
                  }

                  return _context5.abrupt("return", {
                    code: ErrorCode$1.TIMEOUT
                  });

                case 10:
                  if (!(respSignal.status !== 0)) {
                    _context5.next = 12;
                    break;
                  }

                  return _context5.abrupt("return", {
                    code: respSignal.status
                  });

                case 12:
                  data = respPBName ? this.codec.decodeByPBName(respSignal.data, respPBName, option) : respSignal;
                  return _context5.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: data
                  });

                case 14:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function send(_x9, _x10, _x11) {
          return _send.apply(this, arguments);
        }

        return send;
      }()
    }, {
      key: "close",
      value: function close() {
        this._isDisconnected = true;

        this._watcher.status(ConnectionStatus$1.DISCONNECTED);
      }
    }]);

    return CometChannel;
  }(ADataChannel);

  /**
   * 引擎定义
   */
  var AEngine =
  /**
   * 引擎初始化
   * @param _appkey
   */
  function AEngine(runtime, _watcher, _options) {
    _classCallCheck(this, AEngine);

    this.runtime = runtime;
    this._watcher = _watcher;
    this._options = _options;
    /**
     * 当前用户 Id
     */

    this.currentUserId = '';
    this._appkey = this._options.appkey;
    this._apiVer = this._options.apiVersion;
    this.navi = this._createNavi();
  };

  var getKey = function getKey(appkey, token) {
    return ['navi', appkey, token].join('_');
  };

  var getNaviInfoFromCache = function getNaviInfoFromCache(appkey, token, storage) {
    var key = getKey(appkey, token);
    var jsonStr = storage.getItem(key);

    if (!jsonStr) {
      return null;
    }

    var data;

    try {
      data = JSON.parse(jsonStr);
    } catch (err) {
      // 缓存数据被篡改，清空缓存
      storage.removeItem(key);
      return null;
    } // 缓存超时


    if (Date.now() - data.timestamp >= NAVI_CACHE_DURATION) {
      storage.removeItem(key);
      return null;
    }

    return data.naviInfo;
  };

  var _setNaviInfo2Cache = function setNaviInfo2Cache(appkey, token, naviInfo, storage) {
    var key = getKey(appkey, token);
    var data = {
      naviInfo: naviInfo,
      timestamp: Date.now()
    };
    storage.setItem(key, JSON.stringify(data));
  };

  var clearCache = function clearCache(appkey, token, storage) {
    storage.removeItem(getKey(appkey, token));
  };

  var ANavi = /*#__PURE__*/function () {
    function ANavi(_runtime, _options) {
      _classCallCheck(this, ANavi);

      this._runtime = _runtime;
      this._options = _options;
      this._appkey = this._options.appkey;
      this._apiVersion = matchVersion(this._options.apiVersion);
    }
    /**
     * 获取导航数据
     * @param token
     * @param dynamicUris token 携带的动态导航地址
     * @param force 是否强制重新获取并清空缓存数据
     */


    _createClass(ANavi, [{
      key: "getInfo",
      value: function () {
        var _getInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token, dynamicUris, force) {
          var naviInfo, uris;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // 判断是否需要重新获取导航数据，是则清空缓存数据
                  if (force) {
                    this._clear(token);
                  } // 判断是否有有效缓存数据


                  naviInfo = getNaviInfoFromCache(this._appkey, token, this._runtime.localStorage);

                  if (!naviInfo) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt("return", naviInfo);

                case 4:
                  uris = this._options.navigators.slice();
                  dynamicUris.length && dynamicUris.forEach(function (uri) {
                    uris.indexOf(uri) < 0 && uris.unshift(uri);
                  }); // 串行请求，直到获取到导航数据或所有请求结束
                  // TODO: 考虑是否可改为并行请求，串行请求时间过长

                  _context.next = 8;
                  return this._reqNavi(uris, this._appkey, token);

                case 8:
                  naviInfo = _context.sent;

                  if (!naviInfo) {
                    _context.next = 12;
                    break;
                  }

                  this.setNaviInfo2Cache(token, naviInfo);
                  return _context.abrupt("return", naviInfo);

                case 12:
                  return _context.abrupt("return", naviInfo);

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function getInfo(_x, _x2, _x3) {
          return _getInfo.apply(this, arguments);
        }

        return getInfo;
      }()
    }, {
      key: "setNaviInfo2Cache",
      value: function setNaviInfo2Cache(token, naviInfo) {
        _setNaviInfo2Cache(this._appkey, token, naviInfo, this._runtime.localStorage);
      }
    }, {
      key: "getInfoFromCache",
      value: function getInfoFromCache(token) {
        return getNaviInfoFromCache(this._appkey, token, this._runtime.localStorage);
      }
      /**
       * 清空导航数据：内存数据、缓存数据
       */

    }, {
      key: "_clear",
      value: function _clear(token) {
        clearCache(this._appkey, token, this._runtime.localStorage);
      }
    }]);

    return ANavi;
  }();

  var nativeAssign = Object.assign;
  var defineProperty$6 = Object.defineProperty;

  // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  var objectAssign = !nativeAssign || fails(function () {
    // should have correct order of operations (Edge bug)
    if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$6({}, 'a', {
      enumerable: true,
      get: function () {
        defineProperty$6(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {};
    var B = {};
    /* global Symbol -- required for testing */
    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) { B[chr] = chr; });
    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    var propertyIsEnumerable = objectPropertyIsEnumerable.f;
    while (argumentsLength > index) {
      var S = indexedObject(arguments[index++]);
      var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys[j++];
        if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
      }
    } return T;
  } : nativeAssign;

  // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  _export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
    assign: objectAssign
  });

  var OUTBOX_KEY = 'outbox';
  var INBOX_KEY = 'inbox';

  var generateKey = function generateKey(prefix, appkey, userId) {
    return [prefix, appkey, userId].join('_');
  };
  /**
   * 用于维护用户的收件箱、发件箱时间
   */


  var Letterbox = /*#__PURE__*/function () {
    function Letterbox(_runtime, _appkey) {
      _classCallCheck(this, Letterbox);

      this._runtime = _runtime;
      this._appkey = _appkey; // 需要在内存维护一份时间戳数据，以避免同浏览器多标签页下多端拉取消息时共享时间戳

      this._inboxTime = 0;
      this._outboxTime = 0;
    }
    /**
     * 更新收件箱时间
     * @param timestamp
     * @param userId
     */


    _createClass(Letterbox, [{
      key: "setInboxTime",
      value: function setInboxTime(timestamp, userId) {
        if (this._inboxTime > timestamp) {
          return;
        }

        this._inboxTime = timestamp;
        var key = generateKey(INBOX_KEY, this._appkey, userId);

        this._runtime.localStorage.setItem(key, timestamp.toString());
      }
      /**
       * 获取收件箱时间
       * @param userId
       */

    }, {
      key: "getInboxTime",
      value: function getInboxTime(userId) {
        if (this._inboxTime === 0) {
          var key = generateKey(INBOX_KEY, this._appkey, userId);
          this._inboxTime = parseInt(this._runtime.localStorage.getItem(key)) || 0;
        }

        return this._inboxTime;
      }
      /**
       * 更新发件箱时间
       * @param timestamp
       * @param userId
       */

    }, {
      key: "setOutboxTime",
      value: function setOutboxTime(timestamp, userId) {
        if (this._outboxTime > timestamp) {
          return;
        }

        this._outboxTime = timestamp;
        var key = generateKey(OUTBOX_KEY, this._appkey, userId);

        this._runtime.localStorage.setItem(key, timestamp.toString());
      }
      /**
       * 获取发件箱时间
       * @param userId
       */

    }, {
      key: "getOutboxTime",
      value: function getOutboxTime(userId) {
        if (this._outboxTime === 0) {
          var key = generateKey(OUTBOX_KEY, this._appkey, userId);
          this._outboxTime = parseInt(this._runtime.localStorage.getItem(key)) || 0;
        }

        return this._outboxTime;
      }
    }]);

    return Letterbox;
  }();

  var PullTimeCache = {
    _caches: {},
    set: function set(chrmId, time) {
      this._caches[chrmId] = time;
    },
    get: function get(chrmId) {
      return this._caches[chrmId] || 0;
    },
    clear: function clear(chrmId) {
      this._caches[chrmId] = 0;
    }
  };

  var KVStore = /*#__PURE__*/function () {
    function KVStore(chatroomId, currentUserId) {
      _classCallCheck(this, KVStore);

      this._kvCaches = {};
      this._chatroomId = chatroomId;
      this._currentUserId = currentUserId;
    }

    _createClass(KVStore, [{
      key: "_add",
      value: function _add(kv) {
        var key = kv.key;
        kv.isDeleted = false;
        this._kvCaches[key] = kv;
      }
    }, {
      key: "_remove",
      value: function _remove(kv) {
        var key = kv.key;
        var cacheKV = this._kvCaches[key];
        cacheKV.isDeleted = true;
        this._kvCaches[key] = cacheKV;
      }
    }, {
      key: "_setEntry",
      value: function _setEntry(data, isFullUpdate) {
        var key = data.key,
            type = data.type,
            isOverwrite = data.isOverwrite,
            userId = data.userId;

        var latestUserId = this._getSetUserId(key);

        var isDeleteOpt = type === ChatroomEntryType$1.DELETE;
        var isSameAtLastSetUser = latestUserId === userId;
        var isKeyNotExist = !this._isExisted(key);
        var event = isDeleteOpt ? this._remove : this._add;

        if (isFullUpdate) {
          event.call(this, data);
        } else if (isOverwrite || isSameAtLastSetUser || isKeyNotExist) {
          event.call(this, data);
        } else ;
      }
    }, {
      key: "getValue",
      value: function getValue(key) {
        var kv = this._kvCaches[key] || {};
        var isDeleted = kv.isDeleted;
        return isDeleted ? null : kv.value;
      }
    }, {
      key: "getAllValue",
      value: function getAllValue() {
        var entries = {};

        for (var key in this._kvCaches) {
          if (!this._kvCaches[key].isDeleted) {
            entries[key] = this._kvCaches[key].value;
          }
        }

        return entries;
      }
    }, {
      key: "_getSetUserId",
      value: function _getSetUserId(key) {
        var cache = this._kvCaches[key] || {};
        return cache.userId;
      }
    }, {
      key: "_isExisted",
      value: function _isExisted(key) {
        var cache = this._kvCaches[key] || {};
        var value = cache.value,
            isDeleted = cache.isDeleted;
        return value && !isDeleted;
      }
    }, {
      key: "setEntries",
      value: function setEntries(data) {
        var _this = this;

        var kvEntries = data.kvEntries,
            isFullUpdate = data.isFullUpdate;
        kvEntries = kvEntries || [];
        isFullUpdate = isFullUpdate || false;
        isFullUpdate && this.clear();
        kvEntries.forEach(function (kv) {
          _this._setEntry(kv, isFullUpdate);
        });
      }
    }, {
      key: "clear",
      value: function clear() {
        this._kvCaches = {};
      }
    }]);

    return KVStore;
  }();

  var ChrmEntryHandler = /*#__PURE__*/function () {
    function ChrmEntryHandler(engine) {
      _classCallCheck(this, ChrmEntryHandler);

      this._pullQueue = [];
      this._isPulling = false;
      this._storeCaches = {}; // 所有聊天室的 Store 缓存

      this._engine = engine;
    }

    _createClass(ChrmEntryHandler, [{
      key: "_startPull",
      value: function () {
        var _startPull2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _this$_pullQueue$spli, chrmId, timestamp, pulledUpTime, _yield$this$_engine$p, code, data;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(this._isPulling || this._pullQueue.length === 0)) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  this._isPulling = true;
                  _this$_pullQueue$spli = this._pullQueue.splice(0, 1)[0], chrmId = _this$_pullQueue$spli.chrmId, timestamp = _this$_pullQueue$spli.timestamp;
                  pulledUpTime = PullTimeCache.get(chrmId);

                  if (!(pulledUpTime > timestamp)) {
                    _context.next = 9;
                    break;
                  }

                  // 已经拉取过，不再拉取
                  this._isPulling = false;

                  this._startPull();

                  return _context.abrupt("return");

                case 9:
                  _context.next = 11;
                  return this._engine.pullChatroomEntry(chrmId, pulledUpTime);

                case 11:
                  _yield$this$_engine$p = _context.sent;
                  code = _yield$this$_engine$p.code;
                  data = _yield$this$_engine$p.data;

                  if (code === ErrorCode$1.SUCCESS) {
                    this._isPulling = false;
                    PullTimeCache.set(chrmId, data.syncTime || 0);

                    this._startPull();
                  } else {
                    this._startPull();
                  }

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _startPull() {
          return _startPull2.apply(this, arguments);
        }

        return _startPull;
      }()
      /**
       * 退出聊天室前清空 kv 缓存 和 拉取时间缓存，再次加入聊天室后重新拉取 kv 并更新本地
      */

    }, {
      key: "reset",
      value: function reset(chrmId) {
        // throw new Error('Method not implemented.')
        PullTimeCache.clear(chrmId);
        var kvStore = this._storeCaches[chrmId];
        kvStore && kvStore.clear();
      }
      /**
       * 向服务端拉取 kv
       * @description
       * 拉取时机: 1、加入聊天室成功后 2、收到 Server 拉取通知后
      */

    }, {
      key: "pullEntry",
      value: function pullEntry(chrmId, timestamp) {
        this._pullQueue.push({
          chrmId: chrmId,
          timestamp: timestamp
        });

        this._startPull();
      }
      /**
       * 向本地缓存己方设置或拉取到的 kv
      */

    }, {
      key: "setLocal",
      value: function setLocal(chrmId, data, userId) {
        // throw new Error('Method not implemented.')
        var kvStore = this._storeCaches[chrmId];

        if (!notEmptyObject(kvStore)) {
          kvStore = new KVStore(chrmId, userId);
        }

        kvStore.setEntries(data);
        this._storeCaches[chrmId] = kvStore;
      }
      /**
       * 获取聊天室 key 对应的 value
       * @param chrmId
       * @param key
      */

    }, {
      key: "getValue",
      value: function getValue(chrmId, key) {
        // throw new Error('Method not implemented.')
        var kvStore = this._storeCaches[chrmId];
        return kvStore ? kvStore.getValue(key) : null;
      }
      /**
       * 获取聊天室所有 key value
       * @param chrmId
      */

    }, {
      key: "getAll",
      value: function getAll(chrmId) {
        // throw new Error('Method not implemented.')
        var kvStore = this._storeCaches[chrmId];
        var entries = {};

        if (kvStore) {
          entries = kvStore.getAllValue();
        }

        return entries;
      }
    }]);

    return ChrmEntryHandler;
  }();
  var JoinedChrmManager = /*#__PURE__*/function () {
    function JoinedChrmManager(_runtime, _appkey, _userId, _canJoinMulipleChrm) {
      _classCallCheck(this, JoinedChrmManager);

      this._runtime = _runtime;
      this._appkey = _appkey;
      this._userId = _userId;
      this._canJoinMulipleChrm = _canJoinMulipleChrm;
      this._sessionKey = '';
      this._joinedChrmsInfo = {};
      this._sessionKey = "sync-chrm-".concat(this._appkey, "-").concat(this._userId);
    }

    _createClass(JoinedChrmManager, [{
      key: "set",
      value: function set(chrmId) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
        !this._canJoinMulipleChrm && (this._joinedChrmsInfo = {});
        this._joinedChrmsInfo[chrmId] = count;

        this._runtime.sessionStorage.setItem(this._sessionKey, JSON.stringify(this._joinedChrmsInfo));
      }
    }, {
      key: "get",
      value: function get() {
        var infos;

        try {
          var data = this._runtime.sessionStorage.getItem(this._sessionKey);

          infos = JSON.parse(data || '');
        } catch (err) {
          logger.error('parse rejoined chrm infos error', err);
          infos = {};
        }

        return infos;
      }
    }, {
      key: "remove",
      value: function remove(chrmId) {
        delete this._joinedChrmsInfo[chrmId];

        if (notEmptyObject(this._joinedChrmsInfo)) {
          this._runtime.sessionStorage.setItem(this._sessionKey, JSON.stringify(this._joinedChrmsInfo));
        } else {
          this.clear();
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        this._joinedChrmsInfo = {};

        this._runtime.sessionStorage.removeItem(this._sessionKey);
      }
    }]);

    return JoinedChrmManager;
  }();

  var EventName = {
    STATUS_CHANGED: 'converStatusChanged'
  };

  var ConversationStatus = /*#__PURE__*/function () {
    function ConversationStatus(engine, appkey, currentUserId) {
      _classCallCheck(this, ConversationStatus);

      this._eventEmitter = new EventEmitter();
      this._pullQueue = [];
      this._isPulling = false;
      this._storage = createRootStorage(engine.runtime);
      this._appkey = appkey;
      this._currentUserId = currentUserId;
      this._engine = engine;
      this._storagePullTimeKey = "con-s-".concat(appkey, "-").concat(currentUserId);
    }
    /**
     * 向本地设置拉取的时间, 并通知上层会话状态的变更
    */


    _createClass(ConversationStatus, [{
      key: "_set",
      value: function _set(list) {
        var _this = this;

        // todo('ConversationStatus set')
        if (isUndefined(list)) {
          return;
        }

        var localTime = this._storage.get(this._storagePullTimeKey) || 0;
        var listCount = list.length;
        list.forEach(function (statusItem, index) {
          var updatedTime = statusItem.updatedTime || 0;
          localTime = updatedTime > localTime ? updatedTime : localTime;
          statusItem.conversationType = statusItem.type;

          _this._eventEmitter.emit(EventName.STATUS_CHANGED, {
            statusItem: statusItem,
            isLastPull: index === listCount - 1
          });
        });

        this._storage.set(this._storagePullTimeKey, localTime);
      }
      /**
       * 拉取队列
      */

    }, {
      key: "_startPull",
      value: function () {
        var _startPull2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var time, _yield$this$_engine$p, code, data;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(this._isPulling || this._pullQueue.length === 0)) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  this._isPulling = true;
                  time = this._pullQueue.splice(0, 1)[0];
                  _context.next = 6;
                  return this._engine.pullConversationStatus(time);

                case 6:
                  _yield$this$_engine$p = _context.sent;
                  code = _yield$this$_engine$p.code;
                  data = _yield$this$_engine$p.data;

                  if (code === ErrorCode$1.SUCCESS) {
                    this._isPulling = false;

                    this._set(data);

                    this._startPull();
                  } else {
                    this._startPull();
                  }

                case 10:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _startPull() {
          return _startPull2.apply(this, arguments);
        }

        return _startPull;
      }()
      /**
       * 从服务端拉取变更
      */

    }, {
      key: "pull",
      value: function pull(newPullTime) {
        var time = this._storage.get(this._storagePullTimeKey) || 0;

        if (newPullTime > time || newPullTime === 0) {
          // 拉取,并通知上层拉取到的数据
          this._pullQueue.push(time);

          this._startPull();
        }
      }
      /**
       * 注册会话状态变更事件
      */

    }, {
      key: "watch",
      value: function watch(event) {
        this._eventEmitter.on(EventName.STATUS_CHANGED, function (data) {
          event(data);
        });
      }
      /**
       * 断开连接的后，取消注册的会话状态变更时间，防止再次连接重复注册
      */

    }, {
      key: "unwatch",
      value: function unwatch() {
        this._eventEmitter.off(EventName.STATUS_CHANGED, function (data) {});
      }
    }]);

    return ConversationStatus;
  }();

  var StorageKey2ConversationKey = {
    c: {
      keyName: 'unreadMessageCount',
      defaultVal: 0
    },
    hm: {
      keyName: 'hasMentioned',
      defaultVal: false
    },
    m: {
      keyName: 'mentionedInfo',
      defaultVal: null
    },
    t: {
      keyName: 'lastUnreadTime',
      defaultVal: 0
    },
    nc: {
      keyName: 'notificationStatus',
      defaultVal: 2
    },
    to: {
      keyName: 'isTop',
      defaultVal: false
    },
    tg: {
      keyName: 'tags',
      defaultVal: {}
    }
  };
  var ConversationKey2StorageKey = {};

  for (var key$3 in StorageKey2ConversationKey) {
    var keyName = StorageKey2ConversationKey[key$3].keyName;
    ConversationKey2StorageKey[keyName] = key$3;
  }
  /**
   * 存储再本地的 conversation 信息
   * 目前字段：
   *  未读数
   *  是否有 @  消息
   *  @ 内容
   *  免打扰状态
   *  置顶状态
   *  标签状态
   * 对应开发者字段
   *  unreadMessageCount
   *  hasMentioned
   *  mentionedInfo
   *  notificationStatus
   *  isTop
   *  tags
  */


  var ConversationStore = /*#__PURE__*/function () {
    function ConversationStore(runtime, _appkey, _currentUserId) {
      _classCallCheck(this, ConversationStore);

      this._appkey = _appkey;
      this._currentUserId = _currentUserId;
      var suffix = "con-".concat(_appkey, "-").concat(_currentUserId);
      this.storage = new AppStorage(runtime, suffix);
    }

    _createClass(ConversationStore, [{
      key: "_getStoreKey",
      value: function _getStoreKey(type, targetId) {
        return "".concat(type, "_").concat(targetId);
      }
    }, {
      key: "_getConOptionByKey",
      value: function _getConOptionByKey(key) {
        key = key || '';
        var arr = key.split('_');

        if (arr.length >= 2) {
          return {
            conversationType: arr[0],
            targetId: key.match(/_.*/g)[0].substring(1)
          };
        } else {
          return {
            conversationType: ConversationType$1.PRIVATE,
            targetId: ''
          };
        }
      }
      /**
       * 更新 hasMentioned mentionedInfo 信息
      */

    }, {
      key: "updateMentionedData",
      value: function updateMentionedData(message) {
        var _this = this,
            _mentionedInfo;

        var conversationType = message.conversationType,
            targetId = message.targetId,
            messageType = message.messageType,
            isMentioned = message.isMentioned,
            content = message.content,
            senderUserId = message.senderUserId;

        var key = this._getStoreKey(conversationType, targetId);

        var local = this.storage.get(key) || {};
        var storageMetionedInfoKey = ConversationKey2StorageKey.mentionedInfo;
        var storageHasMentionedKey = ConversationKey2StorageKey.hasMentioned;
        var updatedUserIdList = []; // let mentionedInfo = {}

        var localMentionedInfo = local[storageMetionedInfoKey] || {};
        var localUserIdList = localMentionedInfo.userIdList || [];
        var mentionedInfo = content.mentionedInfo; // 如果是 @ 消息, 且 @ 列表里有自己, 更新本地的 MentionInfo.userIdList

        if (isMentioned && conversationType === ConversationType$1.GROUP) {
          var receiveUserIdList = mentionedInfo.userIdList || [];
          receiveUserIdList.forEach(function (userId) {
            if (userId === _this._currentUserId && localUserIdList.indexOf(senderUserId) < 0) {
              localUserIdList.push(senderUserId);
            }
          });

          if (mentionedInfo.type === MentionedType$1.ALL && localUserIdList.indexOf(senderUserId) < 0) {
            localUserIdList.push(senderUserId);
          }

          updatedUserIdList = localUserIdList;
        } // 如果是撤回 @ 消息, 更新本地 userIdList， userIdList 为空时更新 hasMentioned 为 false


        if (messageType === MessageType$1.RECALL && conversationType === ConversationType$1.GROUP) {
          var list = localUserIdList;
          localUserIdList.forEach(function (userId, index) {
            if (userId === senderUserId) {
              list.splice(index, 1);
            }
          });
          updatedUserIdList = list;
        }

        mentionedInfo = {
          userIdList: updatedUserIdList,
          type: (_mentionedInfo = mentionedInfo) === null || _mentionedInfo === void 0 ? void 0 : _mentionedInfo.type
        };

        if (updatedUserIdList.length !== 0) {
          local[storageMetionedInfoKey] = mentionedInfo;
          local[storageHasMentionedKey] = true;
        } else {
          delete local[storageMetionedInfoKey];
          delete local[storageHasMentionedKey];
        }

        if (notEmptyObject(local)) {
          this.storage.set(key, local);
        } else {
          this.storage.remove(key);
        }
      }
      /**
       * 设置会话信息
      */

    }, {
      key: "set",
      value: function set(type, targetId, conversation) {
        var key = this._getStoreKey(type, targetId);

        var local = this.storage.get(key) || {};

        for (var _key in conversation) {
          var storageKey = ConversationKey2StorageKey[_key];
          var val = conversation[_key];

          if (isUndefined(storageKey) || isUndefined(val) || _key === 'hasMentioned' || _key === 'MentionedInfo') {
            continue;
          }

          var defaultVal = StorageKey2ConversationKey[storageKey].defaultVal;

          if (val === defaultVal || _key === 'tags' && !notEmptyObject(val)) {
            // 默认值不存储，避免占用存储空间。获取时未获取到的返回默认值
            delete local[storageKey];
          } else if (_key === 'tags') {
            // 清空isTop:false的字段，减少占用空间
            var _val = val;

            for (var _key2 in _val) {
              if (!_val[_key2].isTop) {
                delete _val[_key2].isTop;
              }
            }

            local[storageKey] = val;
          } else {
            local[storageKey] = val;
          }

          if (!local.c) {
            // 清空未读数则清空最后操作未读时间，避免占用空间
            delete local.t;
          }
        }

        if (notEmptyObject(local)) {
          this.storage.set(key, local);
        } else {
          this.storage.remove(key);
        }
      }
      /**
       * 获取单个会话本地存储信息
      */

    }, {
      key: "get",
      value: function get(type, targetId) {
        var key = this._getStoreKey(type, targetId);

        var local = this.storage.get(key) || {};
        var conversation = {};

        for (var _key3 in StorageKey2ConversationKey) {
          var _StorageKey2Conversat = StorageKey2ConversationKey[_key3],
              _keyName = _StorageKey2Conversat.keyName,
              defaultVal = _StorageKey2Conversat.defaultVal;
          conversation[_keyName] = local[_key3] || cloneByJSON(defaultVal);
        }

        return conversation;
      }
      /**
       * 获取所有会话信息
      */

    }, {
      key: "getValue",
      value: function getValue(func) {

        var values = this.storage.getValues() || {};
        var storageConversationList = [];

        for (var _key4 in values) {
          var _this$_getConOptionBy = this._getConOptionByKey(_key4),
              conversationType = _this$_getConOptionBy.conversationType,
              targetId = _this$_getConOptionBy.targetId;

          var conversation = {
            conversationType: conversationType,
            targetId: targetId
          };
          var store = values[_key4];

          for (var storeKey in store) {
            var _StorageKey2Conversat2 = StorageKey2ConversationKey[storeKey],
                _keyName2 = _StorageKey2Conversat2.keyName,
                defaultVal = _StorageKey2Conversat2.defaultVal;
            conversation[_keyName2] = store[storeKey] || cloneByJSON(defaultVal);
          }

          conversation = func ? func(conversation) : conversation;
          storageConversationList.push(conversation);
        }

        return storageConversationList;
      }
      /**
       * 以标签为维度获取所有会话信息
      */

    }, {
      key: "getValueForTag",
      value: function getValueForTag() {
        var values = this.storage.getValues() || {};
        var tagObj = {};

        for (var _key5 in values) {
          var _this$_getConOptionBy2 = this._getConOptionByKey(_key5),
              conversationType = _this$_getConOptionBy2.conversationType,
              targetId = _this$_getConOptionBy2.targetId;

          var conversation = {};
          var store = values[_key5];

          for (var storeKey in store) {
            var _StorageKey2Conversat3 = StorageKey2ConversationKey[storeKey],
                _keyName3 = _StorageKey2Conversat3.keyName,
                defaultVal = _StorageKey2Conversat3.defaultVal;
            conversation[_keyName3] = store[storeKey] || cloneByJSON(defaultVal);
          } // 以标签为维度重新组织


          for (var tagId in conversation.tags) {
            if (isUndefined(tagObj[tagId])) {
              tagObj[tagId] = [];
            }

            var _con = Object.assign({}, conversation, {
              conversationType: conversationType,
              targetId: targetId
            });

            delete _con.tags;
            tagObj[tagId].push(_con);
          }
        }

        return tagObj;
      }
    }]);

    return ConversationStore;
  }();

  var saveConversationType = [ConversationType$1.PRIVATE, ConversationType$1.GROUP, ConversationType$1.SYSTEM];
  var EventName$1 = {
    CHANGED: 'conversationChanged'
  };

  var ConversationManager = /*#__PURE__*/function () {
    function ConversationManager(engine, appkey, userId, updatedConversationFunc) {
      var _this = this;

      _classCallCheck(this, ConversationManager);

      this._updatedConversations = {};
      this._eventEmitter = new EventEmitter();
      this._draftMap = {};
      this._appkey = appkey;
      this._loginUserId = userId;
      this._store = new ConversationStore(engine.runtime, appkey, userId);
      this._statusManager = new ConversationStatus(engine, appkey, userId);

      this._statusManager.watch(function (data) {
        var statusItem = data.statusItem,
            isLastPull = data.isLastPull;

        _this.addStatus(statusItem, isLastPull);
      });

      this._eventEmitter.on(EventName$1.CHANGED, function (data) {
        updatedConversationFunc(data);
      });
    }
    /**
     * 根据消息计算本地 localConversation 是否需要更新 和 更新的未读数
    */


    _createClass(ConversationManager, [{
      key: "_calcUnreadCount",
      value: function _calcUnreadCount(message, localConversation) {
        var content = message.content,
            messageType = message.messageType,
            sentTime = message.sentTime,
            isCounted = message.isCounted,
            messageDirection = message.messageDirection,
            senderUserId = message.senderUserId;
        var isSelfSend = messageDirection === MessageDirection$1.SEND && senderUserId === this._loginUserId;
        var isRecall = messageType === MessageType$1.RECALL;
        var hasContent = isObject$1(content);
        var hasChanged = false;
        var lastUnreadTime = localConversation.lastUnreadTime || 0;
        var unreadMessageCount = localConversation.unreadMessageCount || 0;
        var hasBeenAdded = lastUnreadTime > sentTime; // 自己发送的消息、已经计算过的消息 不更新本地存储

        if (hasBeenAdded || isSelfSend) {
          return {
            hasChanged: hasChanged,
            localConversation: localConversation
          };
        } // 计数的消息，未读数 + 1


        if (isCounted) {
          localConversation.unreadMessageCount = unreadMessageCount + 1;
          localConversation.lastUnreadTime = sentTime;
          hasChanged = true;
        } // 测回的消息 且 符合撤回消息内容格式（ 撤回消息 content: {conversationType, targetId, messageUId, sentTime} ）


        if (isRecall && hasContent) {
          var isNotRead = lastUnreadTime >= content.sentTime;

          if (isNotRead && unreadMessageCount) {
            localConversation.unreadMessageCount = unreadMessageCount - 1;
            hasChanged = true;
          }
        }

        return {
          hasChanged: hasChanged,
          localConversation: localConversation
        };
      }
      /**
       * 根据消息计算本地 localConversation 是否需要更新 和 更新的 mentionedInfo
      */

    }, {
      key: "_calcMentionedInfo",
      value: function _calcMentionedInfo(message, localConversation) {
        var content = message.content,
            messageDirection = message.messageDirection,
            isMentioned = message.isMentioned;
        messageDirection === MessageDirection$1.SEND;
        var hasContent = isObject$1(content);
        var hasChanged = false;

        if (isMentioned && hasContent && content.mentionedInfo) {
          localConversation.hasMentioned = true; // localConversation.mentionedInfo = (content.mentionedInfo as unknown as IMentionInfo)

          hasChanged = true;
        }

        return {
          hasChanged: hasChanged,
          localConversation: localConversation
        };
      }
      /**
       * 更新内存中 updatedConversation 字段
      */

    }, {
      key: "_setUpdatedConversation",
      value: function _setUpdatedConversation(updatedConOptions) {
        if (isObject$1(updatedConOptions)) {
          var conversationType = updatedConOptions.conversationType,
              targetId = updatedConOptions.targetId;
          var key = "".concat(conversationType, "_").concat(targetId);
          var cacheConversation = this._store.get(conversationType, targetId) || {};
          this._updatedConversations[key] = Object.assign(cacheConversation, updatedConOptions);
        }
      }
    }, {
      key: "addStatus",
      value: function addStatus(statusItem, isLastPull) {
        var conversationType = statusItem.conversationType,
            targetId = statusItem.targetId,
            updatedTime = statusItem.updatedTime,
            notificationStatus = statusItem.notificationStatus,
            isTop = statusItem.isTop,
            tags = statusItem.tags;
        var tagValue = {};
        var updatedItems = {};

        if (!isUndefined(notificationStatus)) {
          updatedItems.notificationStatus = {
            time: updatedTime,
            val: notificationStatus
          };
        }

        if (!isUndefined(isTop)) {
          updatedItems.isTop = {
            time: updatedTime,
            val: isTop
          };
        }

        if (!isUndefined(tags)) {
          updatedItems.tags = {
            time: updatedTime,
            val: tags
          };
          tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
            tagValue[tag.tagId] = {
              isTop: tag.isTop
            };
          });
        }

        this._store.set(conversationType, targetId, {
          notificationStatus: notificationStatus,
          isTop: isTop,
          tags: tagValue
        });

        this._setUpdatedConversation({
          conversationType: conversationType,
          targetId: targetId,
          updatedItems: updatedItems
        });

        if (isLastPull) {
          this._notifyConversationChanged();
        }
      }
      /**
       * 通知会话更新
       * @description
       * 通知的条件: 会话状态变化、会话未读数变化（未读数增加、未读数清空）、会话 @ 信息（hasMentioned、mentionedInfo）、？会话最后一条消息
      */

    }, {
      key: "_notifyConversationChanged",
      value: function _notifyConversationChanged() {
        var list = [];

        for (var key in this._updatedConversations) {
          list.push(this._updatedConversations[key]);
        }

        this._eventEmitter.emit(EventName$1.CHANGED, list);

        this._updatedConversations = {};
      }
      /**
       * 根据消息向 localstorage 设置会话未读数、会话 @ 信息（ hasMentioned、MentionedInfo ）、会话状态（ 置顶、免打扰 ）
       * @description
       * 调用时机：1、收到消息后 2、发消息成功后 3、发送撤回消息成功后
      */

    }, {
      key: "setConversationCacheByMessage",
      value: function setConversationCacheByMessage(message, isPullMessageFinished) {
        var _this2 = this;

        // 若不是存储会话的类型(比如: 聊天室类型), 则不作处理
        var conversationType = message.conversationType,
            isPersited = message.isPersited,
            targetId = message.targetId;
        var isSaveConversationType = saveConversationType.indexOf(conversationType) >= 0;

        if (!isSaveConversationType) {
          return;
        }

        var hasChanged = false;

        var storageConversation = this._store.get(conversationType, targetId); // 计算本地存储


        var CalcEvents = [this._calcUnreadCount, this._calcMentionedInfo];
        CalcEvents.forEach(function (func) {
          var _func$call = func.call(_this2, message, storageConversation),
              hasCaclChanged = _func$call.hasChanged,
              localConversation = _func$call.localConversation;

          hasChanged = hasChanged || hasCaclChanged;
          storageConversation = cloneByJSON(localConversation);
        });

        if (hasChanged) {
          this._store.set(conversationType, targetId, storageConversation);
        }

        this._store.updateMentionedData(message); // 写入会话缓存中


        if (isPersited) {
          var conversation = this._store.get(conversationType, targetId);

          conversation.updatedItems = {
            latestMessage: {
              time: message.sentTime,
              val: message
            }
          };
          conversation.latestMessage = message;
          var updateConOptions = Object.assign(conversation, {
            conversationType: conversationType,
            targetId: targetId
          });

          this._setUpdatedConversation(updateConOptions);
        } // 是否需要通知， 通知 API Context 本地会话变更


        if (isPullMessageFinished) {
          this._notifyConversationChanged();
        }
      }
      /**
       * 获取会话本地存储信息
      */

    }, {
      key: "get",
      value: function get(conversationType, targetId) {
        return this._store.get(conversationType, targetId);
      }
      /**
       * 获取本地会话所有未读数
      */

    }, {
      key: "getAllUnreadCount",
      value: function getAllUnreadCount(channelId, conversationTypes, includeMuted) {
        // TODO: 获取所有未读数需支持多组织、会话类型、免打扰过滤
        var conversationList = this._store.getValue();

        var totalCount = 0;
        conversationList.forEach(function (_ref) {
          var unreadMessageCount = _ref.unreadMessageCount;
          unreadMessageCount = unreadMessageCount || 0;
          totalCount += Number(unreadMessageCount);
        });
        return totalCount;
      }
      /**
       * 获取本地会话指定标签下的所有未读数
      */

    }, {
      key: "getUnreadCountByTag",
      value: function getUnreadCountByTag(tagId, containMuted) {
        var tagAll = this._store.getValueForTag();

        var conversationList = tagAll[tagId] || [];
        var totalCount = 0;
        conversationList.forEach(function (_ref2) {
          var unreadMessageCount = _ref2.unreadMessageCount,
              notificationStatus = _ref2.notificationStatus;

          // 包含免打扰
          if (containMuted || notificationStatus !== 1) {
            unreadMessageCount = unreadMessageCount || 0;
            totalCount += Number(unreadMessageCount);
          }
        });
        return totalCount;
      }
      /**
       * 获取本地指定会话未读数
      */

    }, {
      key: "getUnreadCount",
      value: function getUnreadCount(conversationType, targetId) {
        var conversation = this._store.get(conversationType, targetId);

        return conversation.unreadMessageCount || 0;
      }
      /**
       * 清除本地指定会话未读数
      */

    }, {
      key: "clearUnreadCount",
      value: function clearUnreadCount(conversationType, targetId) {
        var conversation = this._store.get(conversationType, targetId);

        var unreadMessageCount = conversation.unreadMessageCount,
            hasMentioned = conversation.hasMentioned;

        if (unreadMessageCount || hasMentioned) {
          conversation.unreadMessageCount = 0;
          conversation.hasMentioned = false; // conversation.mentionedInfo = null
        }

        this._store.set(conversationType, targetId, conversation);

        var updateConOptions = Object.assign(conversation, {
          conversationType: conversationType,
          targetId: targetId
        });

        this._setUpdatedConversation(updateConOptions);

        this._notifyConversationChanged();
      }
    }, {
      key: "startPullConversationStatus",
      value: function startPullConversationStatus(time) {
        this._statusManager.pull(time);
      }
      /**
       * 设置会话消息草稿
      */

    }, {
      key: "setDraft",
      value: function setDraft(conversationType, targetId, draft) {
        var key = "".concat(conversationType, "_").concat(targetId);
        this._draftMap[key] = draft;
      }
      /**
       * 获取会话消息草稿
      */

    }, {
      key: "getDraft",
      value: function getDraft(conversationType, targetId) {
        var key = "".concat(conversationType, "_").concat(targetId);
        return this._draftMap[key];
      }
      /**
       * 删除会话消息草稿
      */

    }, {
      key: "clearDraft",
      value: function clearDraft(conversationType, targetId) {
        var key = "".concat(conversationType, "_").concat(targetId);
        delete this._draftMap[key];
      }
      /**
       * 向本地会话状态中添加标签, 更新标签状态
       * @param conversationType 会话类型
       * @param targetId 会话id
       * @param tags 标签状态
       */

    }, {
      key: "addTagStatus",
      value: function addTagStatus(conversationType, targetId, tags) {
        var conversation = this._store.get(conversationType, targetId);

        var _tags = conversation.tags;
        _tags = Object.assign(_tags, tags);

        this._store.set(conversationType, targetId, {
          tags: _tags
        });
      }
      /**
       * 删除会话上的指定标签
       */

    }, {
      key: "deleteTagStatus",
      value: function deleteTagStatus(conversationType, targetId, tagIds) {
        var _this$_store$get = this._store.get(conversationType, targetId),
            tags = _this$_store$get.tags;

        tagIds.forEach(function (id) {
          delete tags[id];
        });

        this._store.set(conversationType, targetId, {
          tags: tags
        });
      }
      /**
       * 以标签为维度获取会话状态列表
       */

    }, {
      key: "getConversationListForTag",
      value: function getConversationListForTag() {
        return this._store.getValueForTag();
      }
    }]);

    return ConversationManager;
  }();

  var UploadMethod;

  (function (UploadMethod) {
    /**
     * 七牛上传
     */
    UploadMethod[UploadMethod["QINIU"] = 1] = "QINIU";
    /**
     * 阿里云上传
     */

    UploadMethod[UploadMethod["ALI"] = 2] = "ALI";
    /**
     * 亚马逊上传
     */

    UploadMethod[UploadMethod["AWS"] = 3] = "AWS";
  })(UploadMethod || (UploadMethod = {}));

  var UploadMethod$1 = UploadMethod;

  /**
   * 本地标签信息管理
   */

  var TagManager = /*#__PURE__*/function () {
    function TagManager(engine, appKey, currentUserId, tagWatcherFunc) {
      _classCallCheck(this, TagManager);

      this._pullQueue = [];
      this._isPulling = false;
      this._storageKey = "tag-".concat(appKey, "-").concat(currentUserId);
      this._storagePullTimeKey = "tag-s-".concat(appKey, "-").concat(currentUserId);
      this._storage = createRootStorage(engine.runtime);
      this._engine = engine;
      this._tagWatcherFunc = tagWatcherFunc;
    }
    /**
     * 根据用户配置设置更新本地标签 并 通知业务层(pb中的status无效，都是全量返回)
     * @param tagsSetting 用户配置设置
     */


    _createClass(TagManager, [{
      key: "_updateTag",
      value: function _updateTag(tagsSetting) {
        var tags = tagsSetting.tags;
        var localTags = {};
        tags.forEach(function (tag) {
          localTags[tag.tagId] = {
            tagName: tag.tagName,
            createdTime: tag.createdTime
          };
        });

        this._storage.set(this._storageKey, localTags);

        this._tagWatcherFunc();
      }
      /**
       * 添加标签，如果本地存在则更新
       * @param tags 标签列表
       */

    }, {
      key: "addTag",
      value: function addTag(tags) {
        var localTags = this._storage.get(this._storageKey) || {};
        tags.forEach(function (tag) {
          var _localTags$tag$tagId;

          var createdTime = ((_localTags$tag$tagId = localTags[tag.tagId]) === null || _localTags$tag$tagId === void 0 ? void 0 : _localTags$tag$tagId.createdTime) || tag.createdTime || 0;
          localTags[tag.tagId] = {
            tagName: tag.tagName,
            createdTime: createdTime
          };
        });

        this._storage.set(this._storageKey, localTags);
      }
      /**
       * 删除本地标签
       * @param tagId 标签id
       */

    }, {
      key: "deleteTag",
      value: function deleteTag(tagIds) {
        var localTags = this._storage.get(this._storageKey) || {};
        tagIds.forEach(function (tagId) {
          delete localTags[tagId];
        });

        this._storage.set(this._storageKey, localTags);
      }
      /**
       * 获取本地存储标签信息
       */

    }, {
      key: "getTagsInfo",
      value: function getTagsInfo() {
        return this._storage.get(this._storageKey) || {};
      }
      /**
       * 获取本地标签列表
       */

    }, {
      key: "getTags",
      value: function getTags() {
        var localTags = this._storage.get(this._storageKey) || {};
        var list = [];

        for (var tagId in localTags) {
          list.push({
            tagId: tagId,
            tagName: localTags[tagId].tagName,
            createdTime: localTags[tagId].createdTime,
            conversationCount: 0 // 真实数据在jsEngine里赋值

          });
        }

        function compare(a, b) {
          return (a.createdTime || 0) - (b.createdTime || 0);
        }

        return list.sort(compare);
      }
      /**
       * 获取指定标签
       */

    }, {
      key: "getTagById",
      value: function getTagById(tagId) {
        var localTags = this._storage.get(this._storageKey) || {};
        return localTags[tagId] ? {
          tagId: tagId,
          tagName: localTags[tagId].tagName,
          createdTime: localTags[tagId].createdTime,
          conversationCount: 0
        } : null;
      }
    }, {
      key: "_startPull",
      value: function () {
        var _startPull2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var time, _yield$this$_engine$p, code, data, settings, version, tagsSetting;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(this._isPulling || this._pullQueue.length === 0)) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  this._isPulling = true;
                  time = this._pullQueue.splice(0, 1)[0];
                  _context.next = 6;
                  return this._engine.pullUserSettings(time);

                case 6:
                  _yield$this$_engine$p = _context.sent;
                  code = _yield$this$_engine$p.code;
                  data = _yield$this$_engine$p.data;

                  if (code === ErrorCode$1.SUCCESS && !isUndefined(data)) {
                    settings = data.settings, version = data.version;
                    tagsSetting = settings.Tag || {
                      tags: []
                    };

                    this._updateTag(tagsSetting);

                    this._storage.set(this._storagePullTimeKey, version);

                    this._isPulling = false;

                    this._startPull();
                  } else {
                    this._isPulling = false;

                    this._startPull();
                  }

                case 10:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _startPull() {
          return _startPull2.apply(this, arguments);
        }

        return _startPull;
      }()
      /**
       * 拉取服务器标签列表
       * @param time
       */

    }, {
      key: "pullTags",
      value: function pullTags(newPullTime) {
        var time = this._storage.get(this._storagePullTimeKey) || 0;

        if (newPullTime > time || newPullTime === 0) {
          this._pullQueue.push(time);

          this._startPull();
        }
      }
    }]);

    return TagManager;
  }();

  var JsNavi = /*#__PURE__*/function (_ANavi) {
    _inherits(JsNavi, _ANavi);

    var _super = _createSuper(JsNavi);

    function JsNavi(_runtime, _options) {
      var _this;

      _classCallCheck(this, JsNavi);

      _this = _super.call(this, _runtime, _options);
      _this._connectType = _options.connectionType;
      return _this;
    }

    _createClass(JsNavi, [{
      key: "_formatJSONPUrl",
      value: function _formatJSONPUrl(url, token, appkey, jsonpFunc) {
        var path = this._runtime.isSupportSocket() && this._connectType === 'websocket' ? 'navi' : 'cometnavi';
        var tmpUrl = "".concat(url, "/").concat(path, ".js?appId=").concat(appkey, "&token=").concat(encodeURIComponent(token), "&callBack=").concat(jsonpFunc, "&v=").concat(this._apiVersion, "&r=").concat(Date.now());
        return tmpUrl;
      }
    }, {
      key: "getInfo",
      value: function () {
        var _getInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token, dynamicUris, force) {
          var _this$_options$miniCM, connectUrl, naviInfo;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (this._runtime.useNavi) {
                    _context.next = 5;
                    break;
                  }

                  if (this._runtime.isSupportSocket()) {
                    connectUrl = MINI_SOCKET_CONNECT_URIS.join(',');
                  } else {
                    connectUrl = MINI_COMET_CONNECT_URIS.join(',');
                  }

                  naviInfo = {
                    code: 200,
                    protocol: 'https',
                    server: '',
                    voipCallInfo: '',
                    kvStorage: 0,
                    openHttpDNS: false,
                    historyMsg: false,
                    chatroomMsg: false,
                    uploadServer: 'https://upload.qiniup.com',
                    bosAddr: 'https://gz.bcebos.com',
                    location: '',
                    monitor: 0,
                    joinMChrm: false,
                    openMp: 0,
                    openUS: 0,
                    grpMsgLimit: 0,
                    isFormatted: 0,
                    gifSize: 2048,
                    logSwitch: 0,
                    logPolicy: '',
                    compDays: 0,
                    msgAck: '',
                    activeServer: '',
                    qnAddr: '',
                    extkitSwitch: 0,
                    alone: false,
                    voipServer: '',
                    offlinelogserver: '',
                    backupServer: (_this$_options$miniCM = this._options.miniCMPProxy) !== null && _this$_options$miniCM !== void 0 && _this$_options$miniCM.length ? this._options.miniCMPProxy.join(',') : connectUrl
                  };
                  this.setNaviInfo2Cache(token, naviInfo);
                  return _context.abrupt("return", naviInfo);

                case 5:
                  return _context.abrupt("return", _get(_getPrototypeOf(JsNavi.prototype), "getInfo", this).call(this, token, dynamicUris, force));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function getInfo(_x, _x2, _x3) {
          return _getInfo.apply(this, arguments);
        }

        return getInfo;
      }()
    }, {
      key: "_reqNavi",
      value: function () {
        var _reqNavi2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(uris, appkey, token) {
          var jsonpFunc, i, len, url, res, jsonStr, naviInfo, protocol;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  jsonpFunc = 'getServerEndpoint';
                  i = 0, len = uris.length;

                case 2:
                  if (!(i < len)) {
                    _context2.next = 24;
                    break;
                  }

                  url = this._formatJSONPUrl(uris[i], token, appkey, jsonpFunc);
                  logger.debug("req navi => ".concat(url));
                  _context2.next = 7;
                  return this._runtime.httpReq({
                    url: url,
                    timeout: NAVI_REQ_TIMEOUT
                  });

                case 7:
                  res = _context2.sent;

                  if (!(res.status !== 200)) {
                    _context2.next = 10;
                    break;
                  }

                  return _context2.abrupt("continue", 21);

                case 10:
                  _context2.prev = 10;
                  // 返回结果中，私有云无 ; 号，公有云有分号
                  // 解析 res 数据，解析成功则返回 naviInfo 数据
                  jsonStr = res.data.replace("".concat(jsonpFunc, "("), '').replace(/\);?$/, '');
                  naviInfo = JSON.parse(jsonStr); // 补充导航数据请求使用的协议

                  protocol = /^https/.test(url) ? 'https' : 'http';
                  naviInfo.protocol = protocol;
                  return _context2.abrupt("return", naviInfo);

                case 18:
                  _context2.prev = 18;
                  _context2.t0 = _context2["catch"](10);
                  logger.error('parse navi err =>', _context2.t0);

                case 21:
                  i += 1;
                  _context2.next = 2;
                  break;

                case 24:
                  return _context2.abrupt("return", null);

                case 25:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this, [[10, 18]]);
        }));

        function _reqNavi(_x4, _x5, _x6) {
          return _reqNavi2.apply(this, arguments);
        }

        return _reqNavi;
      }()
    }]);

    return JsNavi;
  }(ANavi);

  var getPubTopic = function getPubTopic(type) {
    var _ConversationType$PRI;

    return (_ConversationType$PRI = {}, _defineProperty(_ConversationType$PRI, ConversationType$1.PRIVATE, Topic$1.ppMsgP), _defineProperty(_ConversationType$PRI, ConversationType$1.GROUP, Topic$1.pgMsgP), _defineProperty(_ConversationType$PRI, ConversationType$1.CHATROOM, Topic$1.chatMsg), _defineProperty(_ConversationType$PRI, ConversationType$1.CUSTOMER_SERVICE, Topic$1.pcMsgP), _defineProperty(_ConversationType$PRI, ConversationType$1.RTC_ROOM, Topic$1.prMsgS), _ConversationType$PRI)[type];
  };

  var getStatPubTopic = function getStatPubTopic(type) {
    var _ConversationType$PRI2;

    return (_ConversationType$PRI2 = {}, _defineProperty(_ConversationType$PRI2, ConversationType$1.PRIVATE, Topic$1.ppMsgS), _defineProperty(_ConversationType$PRI2, ConversationType$1.GROUP, Topic$1.pgMsgS), _ConversationType$PRI2)[type];
  };

  var transSentAttrs2IReceivedMessage = function transSentAttrs2IReceivedMessage(conversationType, targetId, options, messageUId, sentTime, senderUserId) {
    return {
      conversationType: conversationType,
      targetId: targetId,
      senderUserId: senderUserId,
      messageDirection: MessageDirection$1.SEND,
      isCounted: !!options.isCounted,
      isMentioned: !!options.isMentioned,
      content: options.content,
      messageType: options.messageType,
      isOffLineMessage: false,
      isPersited: !!options.isPersited,
      messageUId: messageUId,
      sentTime: sentTime,
      receivedTime: 0,
      disableNotification: !!options.disableNotification,
      isStatusMessage: !!options.isStatusMessage,
      canIncludeExpansion: !!options.canIncludeExpansion,
      expansion: options.canIncludeExpansion ? options.expansion : null,
      receivedStatus: ReceivedStatus$1.UNREAD // 发送消息成功返回的 接收状态默认为 未读

    };
  };
  /**
   * @description
   * 处理群已读同步消息逻辑：即时用户传 directionalUserIdList 也强制修改为当前登录用户。群内其他人接收无意义
  */


  var handleInnerMsgOptions = function handleInnerMsgOptions(options, currentUserId) {
    var messageType = options.messageType;

    if (messageType === 'RC:SRSMsg') {
      Object.assign(options, {
        directionalUserIdList: [currentUserId]
      });
    }

    return options;
  };

  var JSEngine = /*#__PURE__*/function (_AEngine) {
    _inherits(JSEngine, _AEngine);

    var _super = _createSuper(JSEngine);

    function JSEngine(runtime, watcher, initOptions) {
      var _this;

      _classCallCheck(this, JSEngine);

      _this = _super.call(this, runtime, watcher, initOptions);
      _this._customMessageType = {};
      _this._connectedTime = 0;
      /**
       * 拉取离线消息标记
       */

      _this._pullingMsg = false;
      /**
       * 收到的所有消息拉取通知事件戳队列
       */

      _this._pullQueue = [];
      /**
       * 聊天室消息拉取通知队列
       */

      _this._chrmsQueue = {}; // 初始化信箱

      _this._letterbox = new Letterbox(runtime, initOptions.appkey); // 初始化 Chrm KV 处理

      _this._chrmEntryHandler = new ChrmEntryHandler(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(JSEngine, [{
      key: "_createNavi",
      value: function _createNavi() {
        return new JsNavi(this.runtime, this._options);
      }
    }, {
      key: "getConnectedTime",
      value: function getConnectedTime() {
        return this._connectedTime;
      }
    }, {
      key: "connect",
      value: function () {
        var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token, naviInfo) {
          var _this2 = this;

          var hosts, backupServer, channel, code;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  hosts = [];
                  this._naviInfo = naviInfo;

                  if (naviInfo.server) {
                    hosts.push(naviInfo.server);
                  } else {
                    // 私有云无法保证客户环境 Navi 配置有效性
                    logger.warn('navi.server is invalid');
                  }

                  backupServer = naviInfo.backupServer; // 备用服务有效性验证与排重

                  backupServer && backupServer.split(',').forEach(function (host) {
                    if (hosts.indexOf(host) < 0) {
                      hosts.push(host);
                    }
                  });

                  if (!(hosts.length === 0)) {
                    _context.next = 8;
                    break;
                  }

                  logger.error('navi invaild.', hosts);
                  return _context.abrupt("return", ErrorCode$1.UNKNOWN);

                case 8:
                  // 创建数据通道
                  channel = this.runtime.createDataChannel({
                    status: function status(_status) {
                      _this2._connectionStatusHandler(_status, token, hosts, naviInfo.protocol);
                    },
                    signal: this._signalHandler.bind(this)
                  }, this._options.connectionType); // 建立连接

                  _context.next = 11;
                  return channel.connect(this._appkey, token, hosts, naviInfo.protocol, this._apiVer);

                case 11:
                  code = _context.sent;

                  if (code === ErrorCode$1.SUCCESS) {
                    this._channel = channel;
                    this.currentUserId = channel.userId;
                    this._connectedTime = channel.connectedTime;
                    this._conversationManager = new ConversationManager(this, this._appkey, this.currentUserId, this._watcher.conversation);

                    this._conversationManager.startPullConversationStatus(0);

                    this._tagManager = new TagManager(this, this._appkey, this.currentUserId, this._watcher.tag);

                    this._tagManager.pullTags(0); // 初始化加入 chrm 的信息


                    this._joinedChrmManager = new JoinedChrmManager(this.runtime, this._appkey, this.currentUserId, naviInfo.joinMChrm); // 拉取离线消息

                    this._syncMsg();
                  } else {
                    channel.close();
                  }

                  return _context.abrupt("return", code);

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function connect(_x, _x2) {
          return _connect.apply(this, arguments);
        }

        return connect;
      }()
    }, {
      key: "_connectionStatusHandler",
      value: function _connectionStatusHandler(status, token, hosts, protocol) {
        logger.warn('connection status changed:', status);

        if (status === ConnectionStatus$1.CONNECTING || status === ConnectionStatus$1.CONNECTED) {
          this._watcher.status(status);

          return;
        }

        if (!this._channel || status === ConnectionStatus$1.DISCONNECTED) {
          // 用户主动断开连接，直接抛出连接状态
          this._watcher.status(status);

          return;
        }

        if (status === ConnectionStatus$1.BLOCKED || status === ConnectionStatus$1.KICKED_OFFLINE_BY_OTHER_CLIENT || status === ConnectionStatus$1.DISCONNECT_BY_SERVER) {
          // 用户被封禁，或多端被踢下线，或其他服务器原因通知断开
          this.disconnect();

          this._watcher.status(status);

          return;
        }

        if (status === ConnectionStatus$1.REDIRECT) {
          // TODO: 需重定向
          return;
        } // 异常断开，尝试重连


        this._try2Reconnect(token, hosts, protocol);
      }
    }, {
      key: "_try2Reconnect",
      value: function () {
        var _try2Reconnect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(token, hosts, protocol) {
          var _this3 = this;

          var code;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (this._channel) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return");

                case 2:
                  _context2.next = 4;
                  return this._channel.connect(this._appkey, token, hosts, protocol, this._apiVer);

                case 4:
                  code = _context2.sent;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context2.next = 8;
                    break;
                  }

                  this._rejoinChrm();

                  return _context2.abrupt("return");

                case 8:
                  this._watcher.status(ConnectionStatus$1.WEBSOCKET_UNAVAILABLE); // 等待 5s 后重新尝试


                  setTimeout(function () {
                    _this3._try2Reconnect(token, hosts, protocol);
                  }, 5000);

                case 10:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function _try2Reconnect(_x3, _x4, _x5) {
          return _try2Reconnect2.apply(this, arguments);
        }

        return _try2Reconnect;
      }()
    }, {
      key: "_signalHandler",
      value: function _signalHandler(signal, ack) {
        var syncMsg = signal.syncMsg,
            topic = signal.topic;

        if (syncMsg) {
          // 此消息为本人其他端发出的消息，此处为多端消息同步
          this._receiveSyncMsg(signal, ack);

          return;
        }

        var tmpTopic = Topic$1[topic];

        if (!tmpTopic) {
          logger.error('unknown topic:', topic);
          return;
        }

        switch (tmpTopic) {
          case Topic$1.s_ntf:
            this._pullMsg(signal); // 通知拉取


            break;

          case Topic$1.s_msg:
            this._receiveMsg(signal); // 接收直发消息


            break;

          case Topic$1.s_cmd:
            this._receiveStateNotify(signal);

            break;

          case Topic$1.s_us:
            this._receiveSettingNotify(signal);

            break;
        }
      }
      /**
       * 接收聊天室 kv 通知与会话状态变更通知
       * @param signal
       */

    }, {
      key: "_receiveStateNotify",
      value: function _receiveStateNotify(signal) {
        var _this$_channel;

        var _this$_channel$codec$ = (_this$_channel = this._channel) === null || _this$_channel === void 0 ? void 0 : _this$_channel.codec.decodeByPBName(signal.data, PBName.NotifyMsg),
            time = _this$_channel$codec$.time,
            type = _this$_channel$codec$.type,
            chrmId = _this$_channel$codec$.chrmId;

        switch (type) {
          case 2:
            this._chrmEntryHandler.pullEntry(chrmId, time);

            break;

          case 3:
            this._conversationManager.startPullConversationStatus(time);

            break;
        }
      }
      /**
       * 接收实时配置变更通知
       * @param signal
       */

    }, {
      key: "_receiveSettingNotify",
      value: function _receiveSettingNotify(signal) {
        var _this$_channel2;

        // comet模式未加这个通知
        if (this._options.connectionType === 'comet') return;

        var _this$_channel$codec$2 = (_this$_channel2 = this._channel) === null || _this$_channel2 === void 0 ? void 0 : _this$_channel2.codec.decodeByPBName(signal.data, PBName.UserSettingNotification),
            version = _this$_channel$codec$2.version;

        this._tagManager.pullTags(version);
      }
      /**
       * 通知 API Content 扩展变更
      */

    }, {
      key: "_receiveMessageExpansion",
      value: function _receiveMessageExpansion(message) {
        var content = message.content;
        var put = content.put,
            del = content.del,
            mid = content.mid;

        if (put) {
          this._watcher.expansion({
            updatedExpansion: {
              messageUId: mid,
              expansion: put
            }
          });
        }

        if (del) {
          this._watcher.expansion({
            deletedExpansion: {
              messageUId: mid,
              deletedKeys: del
            }
          });
        }
      }
      /**
       * 接收多端同步消息
       * @param signal
       * @param ack 同步消息的 ack 信令数据，comet 连接无此数据
       */

    }, {
      key: "_receiveSyncMsg",
      value: function _receiveSyncMsg(signal, ack) {
        var _this$_channel3;

        var msg = (_this$_channel3 = this._channel) === null || _this$_channel3 === void 0 ? void 0 : _this$_channel3.codec.decodeByPBName(signal.data, PBName.UpStreamMessage, {
          currentUserId: this.currentUserId,
          signal: signal
        });
        msg = this._handleMsgProperties(msg); // 更新消息并通知业务层

        msg.sentTime = ack.timestamp;
        msg.messageUId = ack.messageUId; // 当前正在拉取消息过程中，不需要同步直发消息到业务层，向拉取队列中重新添加一个时间戳等待当前拉取动作完成后递归拉取

        if (this._pullingMsg) {
          this._pullQueue.push(ack.timestamp);

          return;
        } // 更新发件箱时间


        this._letterbox.setOutboxTime(ack.timestamp, this.currentUserId);

        if (msg.messageType === MessageType$1.EXPANSION_NOTIFY) {
          this._receiveMessageExpansion(msg);

          return;
        }

        this._watcher.message(msg);

        this._conversationManager.setConversationCacheByMessage(msg, true);
      }
      /**
       * 拉取消息
       * @description 聊天室消息与普通消息都是通知拉取
       * @param signal
       */

    }, {
      key: "_pullMsg",
      value: function _pullMsg(signal) {
        if (!this._channel) {
          return;
        }

        var _this$_channel$codec$3 = this._channel.codec.decodeByPBName(signal.data, PBName.NotifyMsg),
            type = _this$_channel$codec$3.type,
            chrmId = _this$_channel$codec$3.chrmId,
            time = _this$_channel$codec$3.time;

        if (type === 2) {
          var info = this._chrmsQueue[chrmId]; // 拉取通知可能是由于多端中其他端接收通知拉取

          if (!info) {
            return;
          }

          info.queue.push(time);

          this._pullChrmMsg(chrmId);
        } else {
          // 记录消息拉取通知的时间戳
          this._pullQueue.push(time);

          this._syncMsg();
        }
      }
      /**
       * 拉取消息：离线 Or 通知拉取
       */

    }, {
      key: "_syncMsg",
      value: function () {
        var _syncMsg2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var _this4 = this,
              _this$_pullQueue;

          var outboxTime, inboxTime, reqBody, writer, _yield$this$_channel$, code, data, list, finished, syncTime, newOutboxTime, tmpPullQueue;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!this._pullingMsg) {
                    _context3.next = 2;
                    break;
                  }

                  return _context3.abrupt("return");

                case 2:
                  if (this._channel) {
                    _context3.next = 5;
                    break;
                  }

                  // 连接中断，无需拉取离线消息
                  this._pullingMsg = false;
                  return _context3.abrupt("return");

                case 5:
                  this._pullingMsg = true; // 获取消息时间戳

                  outboxTime = this._letterbox.getOutboxTime(this.currentUserId);
                  inboxTime = this._letterbox.getInboxTime(this.currentUserId);
                  logger.debug('outboxTime', outboxTime);
                  logger.debug('inboxTime', inboxTime);
                  reqBody = this._channel.codec.encodeSyncMsg({
                    sendboxTime: outboxTime,
                    inboxTime: inboxTime
                  });
                  writer = new QueryWriter(Topic$1[Topic$1.pullMsg], reqBody, this.currentUserId);
                  _context3.next = 14;
                  return this._channel.send(writer, PBName.DownStreamMessages, {
                    connectedTime: this._channel.connectedTime,
                    currentUserId: this.currentUserId
                  });

                case 14:
                  _yield$this$_channel$ = _context3.sent;
                  code = _yield$this$_channel$.code;
                  data = _yield$this$_channel$.data;

                  if (!(code !== ErrorCode$1.SUCCESS || !data)) {
                    _context3.next = 21;
                    break;
                  }

                  logger.warn('Pull msg failed, code:', code, ', data: ', data);
                  this._pullingMsg = false;
                  return _context3.abrupt("return");

                case 21:
                  list = data.list, finished = data.finished, syncTime = data.syncTime;
                  newOutboxTime = 0; // let newInboxTime = 0
                  // 派发消息

                  list.forEach(function (item) {
                    if (item.messageDirection === MessageDirection$1.SEND) {
                      newOutboxTime = Math.max(item.sentTime, newOutboxTime);
                    } // else {
                    //   newInboxTime = Math.max(item.sentTime, newInboxTime)
                    // }


                    if (item.messageType === MessageType$1.EXPANSION_NOTIFY) {
                      _this4._receiveMessageExpansion(item);

                      return;
                    }

                    _this4._watcher.message(item);

                    _this4._conversationManager.setConversationCacheByMessage(item, true);
                  }); // 更新收件箱时间
                  // this.letterbox.setInboxTime(newInboxTime, this.currentUserId)

                  this._letterbox.setInboxTime(syncTime, this.currentUserId); // 更新发件箱时间


                  this._letterbox.setOutboxTime(newOutboxTime, this.currentUserId);

                  this._pullingMsg = false; // 清除较 syncTime 更早的拉取通知时间戳

                  tmpPullQueue = this._pullQueue.filter(function (timestamp) {
                    return timestamp > syncTime;
                  });
                  this._pullQueue.length = 0;

                  (_this$_pullQueue = this._pullQueue).push.apply(_this$_pullQueue, _toConsumableArray(tmpPullQueue));

                  if (!finished || tmpPullQueue.length > 0) {
                    // 继续拉取
                    this._syncMsg();
                  }

                case 31:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function _syncMsg() {
          return _syncMsg2.apply(this, arguments);
        }

        return _syncMsg;
      }()
      /**
       * 接收直发消息
       * @description 直发消息只有单聊、群聊存在，其他会话类型均为通知拉取
       * @param signal
       */

    }, {
      key: "_receiveMsg",
      value: function _receiveMsg(signal) {
        if (!this._channel) {
          return;
        } // 当在拉取单群聊离线过程中，直发消息可直接抛弃


        if (this._pullingMsg) {
          return;
        }

        var msg = this._channel.codec.decodeByPBName(signal.data, PBName.DownStreamMessage, {
          currentUserId: this.currentUserId,
          connectedTime: this._channel.connectedTime
        });

        msg = this._handleMsgProperties(msg); // 状态消息不更新收件箱时间

        if (!msg.isStatusMessage) {
          // 更新收件箱时间
          this._letterbox.setInboxTime(msg.sentTime, this.currentUserId);
        }

        if (msg.messageType === MessageType$1.EXPANSION_NOTIFY) {
          this._receiveMessageExpansion(msg);

          return;
        }

        this._watcher.message(msg);

        this._conversationManager.setConversationCacheByMessage(msg, true);
      }
      /**
       * 向 API Context 抛出消息时，处理消息的部分属性值
       * @description
       * 当前仅根据内置消息或自定义类型的消息处理消息的存储、计数属性
      */

    }, {
      key: "_handleMsgProperties",
      value: function _handleMsgProperties(msgOptions) {
        var isSendMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var messageType = msgOptions.messageType,
            isCounted = msgOptions.isCounted,
            isPersited = msgOptions.isPersited,
            isStatusMessage = msgOptions.isStatusMessage;
        var options;
        var inRCMessageType = (messageType in SEND_MESSAGE_TYPE_OPTION);
        var inCustomMessageType = (messageType in this._customMessageType);

        if (inRCMessageType) {
          // 内置消息
          options = SEND_MESSAGE_TYPE_OPTION[messageType];
        } else if (inCustomMessageType) {
          // 自定义消息
          options = this._customMessageType[messageType];
        } else {
          // 其他消息, 发消息已传参为准, 无参数默认 false. 收消息已服务端微赚
          options = {
            isCounted: isNull(isCounted) ? false : isCounted,
            isPersited: isNull(isPersited) ? false : isPersited
          };
        }

        Object.assign(msgOptions, {
          isCounted: options.isCounted,
          isPersited: options.isPersited,
          isStatusMessage: !(msgOptions.isCounted && msgOptions.isPersited)
        });
        isSendMsg && (msgOptions.isStatusMessage = isStatusMessage);
        return msgOptions;
      }
    }, {
      key: "getHistoryMessage",
      value: function () {
        var _getHistoryMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(conversationType, targetId, timestamp, count, order) {
          var currentUserId, channel, hisTopic, data, resp, code, downstreamData;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  currentUserId = this.currentUserId, channel = this._channel;
                  hisTopic = ConversationTypeToQueryHistoryTopic[conversationType] || QueryHistoryTopic.PRIVATE;

                  if (!channel) {
                    _context4.next = 12;
                    break;
                  }

                  data = channel.codec.encodeGetHistoryMsg(targetId, {
                    timestamp: timestamp,
                    count: count,
                    order: order
                  });
                  _context4.next = 6;
                  return channel.send(new QueryWriter(hisTopic, data, currentUserId), PBName.HistoryMsgOuput, {
                    currentUserId: currentUserId,
                    connectedTime: channel.connectedTime,
                    conversation: {
                      targetId: targetId
                    }
                  });

                case 6:
                  resp = _context4.sent;
                  code = resp.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context4.next = 10;
                    break;
                  }

                  return _context4.abrupt("return", {
                    code: code
                  });

                case 10:
                  // 解析数据转换为业务层数据结构
                  downstreamData = resp.data;
                  return _context4.abrupt("return", {
                    code: code,
                    data: {
                      list: downstreamData.list,
                      hasMore: downstreamData.hasMore
                    }
                  });

                case 12:
                  return _context4.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 13:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function getHistoryMessage(_x6, _x7, _x8, _x9, _x10) {
          return _getHistoryMessage.apply(this, arguments);
        }

        return getHistoryMessage;
      }()
    }, {
      key: "deleteRemoteMessage",
      value: function () {
        var _deleteRemoteMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(conversationType, targetId, list) {
          var currentUserId, channel, data, writer, resp, code;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  currentUserId = this.currentUserId, channel = this._channel;

                  if (!channel) {
                    _context5.next = 11;
                    break;
                  }

                  data = channel.codec.encodeDeleteMessages(conversationType, targetId, list);
                  writer = new QueryWriter(QueryTopic.DELETE_MESSAGES, data, currentUserId);
                  _context5.next = 6;
                  return channel.send(writer);

                case 6:
                  resp = _context5.sent;
                  code = resp.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context5.next = 10;
                    break;
                  }

                  return _context5.abrupt("return", code);

                case 10:
                  return _context5.abrupt("return", code);

                case 11:
                  return _context5.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 12:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function deleteRemoteMessage(_x11, _x12, _x13) {
          return _deleteRemoteMessage.apply(this, arguments);
        }

        return deleteRemoteMessage;
      }()
    }, {
      key: "deleteRemoteMessageByTimestamp",
      value: function () {
        var _deleteRemoteMessageByTimestamp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(conversationType, targetId, timestamp) {
          var currentUserId, channel, data, topic, writer, resp, code;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  currentUserId = this.currentUserId, channel = this._channel;

                  if (!channel) {
                    _context6.next = 12;
                    break;
                  }

                  data = channel.codec.encodeClearMessages(targetId, timestamp);
                  topic = ConversationTypeToClearMessageTopic[conversationType];
                  writer = new QueryWriter(topic, data, currentUserId);
                  _context6.next = 7;
                  return channel.send(writer);

                case 7:
                  resp = _context6.sent;
                  code = resp.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context6.next = 11;
                    break;
                  }

                  return _context6.abrupt("return", code);

                case 11:
                  return _context6.abrupt("return", code);

                case 12:
                  return _context6.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 13:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function deleteRemoteMessageByTimestamp(_x14, _x15, _x16) {
          return _deleteRemoteMessageByTimestamp.apply(this, arguments);
        }

        return deleteRemoteMessageByTimestamp;
      }()
    }, {
      key: "getConversationList",
      value: function () {
        var _getConversationList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
          var _this5 = this;

          var count,
              conversationType,
              startTime,
              order,
              currentUserId,
              channel,
              buff,
              writer,
              resp,
              code,
              data,
              _args7 = arguments;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  count = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : 300;
                  conversationType = _args7.length > 1 ? _args7[1] : undefined;
                  startTime = _args7.length > 2 ? _args7[2] : undefined;
                  order = _args7.length > 3 ? _args7[3] : undefined;
                  currentUserId = this.currentUserId, channel = this._channel; // conversationType 服务端未用到此字段，直接返回所有类型

                  conversationType = conversationType || ConversationType$1.PRIVATE;

                  if (!channel) {
                    _context7.next = 17;
                    break;
                  }

                  buff = channel.codec.encodeOldConversationList({
                    count: count,
                    type: conversationType,
                    startTime: startTime,
                    order: order
                  });
                  writer = new QueryWriter(QueryTopic.GET_OLD_CONVERSATION_LIST, buff, currentUserId);
                  _context7.next = 11;
                  return channel.send(writer, PBName.RelationsOutput, {
                    currentUserId: currentUserId,
                    connectedTime: channel.connectedTime,
                    afterDecode: function afterDecode(conversation) {
                      var conversationType = conversation.conversationType,
                          targetId = conversation.targetId;

                      var localConversation = _this5._conversationManager.get(conversationType, targetId); // 将本地存储的会话属性和从 Server 获取到的会话属性进行合并


                      Object.assign(conversation, localConversation);
                      return conversation;
                    }
                  });

                case 11:
                  resp = _context7.sent;
                  logger.info('GetConversationList =>', resp);
                  code = resp.code, data = resp.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context7.next = 16;
                    break;
                  }

                  return _context7.abrupt("return", {
                    code: code
                  });

                case 16:
                  return _context7.abrupt("return", {
                    code: code,
                    data: data
                  });

                case 17:
                  return _context7.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 18:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function getConversationList() {
          return _getConversationList.apply(this, arguments);
        }

        return getConversationList;
      }()
    }, {
      key: "removeConversation",
      value: function () {
        var _removeConversation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(conversationType, targetId) {
          var channel, data, writer, resp, code;
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  channel = this._channel;

                  if (!channel) {
                    _context8.next = 12;
                    break;
                  }

                  data = channel.codec.encodeOldConversationList({
                    type: conversationType
                  });
                  writer = new QueryWriter(QueryTopic.REMOVE_OLD_CONVERSATION, data, targetId);
                  _context8.next = 6;
                  return channel.send(writer);

                case 6:
                  resp = _context8.sent;
                  logger.info('RemoveConversation =>', resp);
                  code = resp.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context8.next = 11;
                    break;
                  }

                  return _context8.abrupt("return", code);

                case 11:
                  return _context8.abrupt("return", code);

                case 12:
                  return _context8.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 13:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function removeConversation(_x17, _x18) {
          return _removeConversation.apply(this, arguments);
        }

        return removeConversation;
      }()
    }, {
      key: "getConversation",
      value: function getConversation(conversationType, targetId, tag) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getAllConversationUnreadCount",
      value: function getAllConversationUnreadCount(channelId, conversationTypes, includeMuted) {
        var allUnreadCount = this._conversationManager.getAllUnreadCount(channelId, conversationTypes, includeMuted);

        return Promise.resolve({
          code: ErrorCode$1.SUCCESS,
          data: allUnreadCount
        });
      }
    }, {
      key: "getConversationUnreadCount",
      value: function getConversationUnreadCount(conversationType, targetId) {
        var unreadCount = this._conversationManager.getUnreadCount(conversationType, targetId);

        return Promise.resolve({
          code: ErrorCode$1.SUCCESS,
          data: unreadCount
        });
      }
    }, {
      key: "clearConversationUnreadCount",
      value: function clearConversationUnreadCount(conversationType, targetId) {
        this._conversationManager.clearUnreadCount(conversationType, targetId);

        return Promise.resolve(ErrorCode$1.SUCCESS);
      }
    }, {
      key: "saveConversationMessageDraft",
      value: function saveConversationMessageDraft(conversationType, targetId, draft) {
        this._conversationManager.setDraft(conversationType, targetId, draft);

        return Promise.resolve(ErrorCode$1.SUCCESS);
      }
    }, {
      key: "getConversationMessageDraft",
      value: function getConversationMessageDraft(conversationType, targetId) {
        var draft = this._conversationManager.getDraft(conversationType, targetId);

        return Promise.resolve({
          code: ErrorCode$1.SUCCESS,
          data: draft
        });
      }
    }, {
      key: "clearConversationMessageDraft",
      value: function clearConversationMessageDraft(conversationType, targetId) {
        this._conversationManager.clearDraft(conversationType, targetId);

        return Promise.resolve(ErrorCode$1.SUCCESS);
      }
    }, {
      key: "pullConversationStatus",
      value: function () {
        var _pullConversationStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(timestamp) {
          var channel, currentUserId, buff, writer, resp, code, data;
          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  channel = this._channel, currentUserId = this.currentUserId;

                  if (!channel) {
                    _context9.next = 11;
                    break;
                  }

                  buff = channel.codec.encodeGetConversationStatus(timestamp);
                  writer = new QueryWriter(Topic$1[Topic$1.pullSeAtts], buff, currentUserId);
                  _context9.next = 6;
                  return channel.send(writer, PBName.SessionStates);

                case 6:
                  resp = _context9.sent;
                  code = resp.code, data = resp.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context9.next = 10;
                    break;
                  }

                  return _context9.abrupt("return", {
                    code: code
                  });

                case 10:
                  return _context9.abrupt("return", {
                    code: code,
                    data: data
                  });

                case 11:
                  return _context9.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 12:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function pullConversationStatus(_x19) {
          return _pullConversationStatus.apply(this, arguments);
        }

        return pullConversationStatus;
      }()
    }, {
      key: "batchSetConversationStatus",
      value: function () {
        var _batchSetConversationStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(statusList) {
          var _this6 = this;

          var currentUserId, channel, buff, writer, resp, code, data, versionData;
          return regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  currentUserId = this.currentUserId, channel = this._channel;

                  if (!channel) {
                    _context10.next = 13;
                    break;
                  }

                  buff = channel.codec.encodeSetConversationStatus(statusList);
                  writer = new QueryWriter(QueryTopic.SET_CONVERSATION_STATUS, buff, currentUserId);
                  _context10.next = 6;
                  return channel.send(writer, PBName.SessionStateModifyResp);

                case 6:
                  resp = _context10.sent;
                  code = resp.code, data = resp.data;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context10.next = 12;
                    break;
                  }

                  versionData = data;
                  statusList.forEach(function (item) {
                    _this6._conversationManager.addStatus(_objectSpread2(_objectSpread2({}, item), {}, {
                      updatedTime: versionData.version
                    }), true);
                  });
                  return _context10.abrupt("return", code);

                case 12:
                  return _context10.abrupt("return", code);

                case 13:
                  return _context10.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 14:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function batchSetConversationStatus(_x20) {
          return _batchSetConversationStatus.apply(this, arguments);
        }

        return batchSetConversationStatus;
      }()
    }, {
      key: "_joinChrm",
      value: function () {
        var _joinChrm2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(chrmId, count, isJoinExist) {
          var channel, buff, topic, writer, _yield$channel$send, code, info, isOpenKVService;

          return regeneratorRuntime.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  channel = this._channel;

                  if (channel) {
                    _context11.next = 3;
                    break;
                  }

                  return _context11.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 3:
                  buff = channel.codec.encodeJoinOrQuitChatRoom();
                  topic = isJoinExist ? QueryTopic.JOIN_EXIST_CHATROOM : QueryTopic.JOIN_CHATROOM;
                  writer = new QueryWriter(topic, buff, chrmId);
                  _context11.next = 8;
                  return channel.send(writer);

                case 8:
                  _yield$channel$send = _context11.sent;
                  code = _yield$channel$send.code;
                  _yield$channel$send.data;

                  // 加入聊天室成功后，需要拉取聊天室最近消息, 并抛给消息监听器
                  if (code === ErrorCode$1.SUCCESS) {
                    info = this._chrmsQueue[chrmId]; // 断线重连情况下，重复加房间不能重置消息拉取信息

                    if (!info) {
                      this._chrmsQueue[chrmId] = {
                        pulling: false,
                        queue: [],
                        timestamp: 0
                      };
                    }

                    this._pullChrmMsg(chrmId, count); // 如果开通聊天室 KV 存储服务, 加入成功后拉取聊天室 KV 存储


                    isOpenKVService = this._naviInfo.kvStorage;

                    if (isOpenKVService) {
                      this._chrmEntryHandler.pullEntry(chrmId, 0);
                    } // sessionStorage 存储加入房间的信息


                    this._joinedChrmManager.set(chrmId, count);
                  }

                  return _context11.abrupt("return", code);

                case 13:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this);
        }));

        function _joinChrm(_x21, _x22, _x23) {
          return _joinChrm2.apply(this, arguments);
        }

        return _joinChrm;
      }()
      /**
       * 断网重连成功后，从 sessionStorage 缓存中获取用户已加入的聊天室，然后重新加入已存在的聊天室，并拉取消息
      */

    }, {
      key: "_rejoinChrm",
      value: function () {
        var _rejoinChrm2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
          var joinedChrms, chrmId, code;
          return regeneratorRuntime.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  joinedChrms = this._joinedChrmManager.get();
                  _context12.t0 = regeneratorRuntime.keys(joinedChrms);

                case 2:
                  if ((_context12.t1 = _context12.t0()).done) {
                    _context12.next = 10;
                    break;
                  }

                  chrmId = _context12.t1.value;
                  _context12.next = 6;
                  return this._joinChrm(chrmId, joinedChrms[chrmId], true);

                case 6:
                  code = _context12.sent;

                  if (code === ErrorCode$1.SUCCESS) {
                    this._watcher.chatroom({
                      rejoinedRoom: {
                        chatroomId: chrmId,
                        count: joinedChrms[chrmId]
                      }
                    });
                  } else {
                    this._watcher.chatroom({
                      rejoinedRoom: {
                        chatroomId: chrmId,
                        errorCode: code
                      }
                    });
                  }

                  _context12.next = 2;
                  break;

                case 10:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, this);
        }));

        function _rejoinChrm() {
          return _rejoinChrm2.apply(this, arguments);
        }

        return _rejoinChrm;
      }()
      /**
       * 拉取聊天室消息
       * @param chrmId
       * @param count 默认拉取 10 条，最大一次拉取 50 条，只在加入房间时第一次拉取时有效
       */

    }, {
      key: "_pullChrmMsg",
      value: function () {
        var _pullChrmMsg2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(chrmId) {
          var _this7 = this;

          var count,
              chrmInfo,
              pulling,
              timestamp,
              reqBody,
              signal,
              _yield$this$_channel$2,
              code,
              data,
              list,
              syncTime,
              finished,
              _args13 = arguments;

          return regeneratorRuntime.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  count = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : 10;

                  if (this._channel) {
                    _context13.next = 3;
                    break;
                  }

                  return _context13.abrupt("return");

                case 3:
                  chrmInfo = this._chrmsQueue[chrmId];
                  pulling = chrmInfo.pulling, timestamp = chrmInfo.timestamp;

                  if (!pulling) {
                    _context13.next = 7;
                    break;
                  }

                  return _context13.abrupt("return");

                case 7:
                  chrmInfo.pulling = true;
                  reqBody = this._channel.codec.encodeChrmSyncMsg(timestamp, count);
                  signal = new QueryWriter(Topic$1[Topic$1.chrmPull], reqBody, chrmId);
                  _context13.next = 12;
                  return this._channel.send(signal, PBName.DownStreamMessages, {
                    connectedTime: this._channel.connectedTime,
                    currentUserId: this.currentUserId
                  });

                case 12:
                  _yield$this$_channel$2 = _context13.sent;
                  code = _yield$this$_channel$2.code;
                  data = _yield$this$_channel$2.data;
                  chrmInfo.pulling = false;

                  if (!(code !== ErrorCode$1.SUCCESS || !data)) {
                    _context13.next = 19;
                    break;
                  }

                  logger.warn('pull chatroom msg failed, code:', code, ', data:', data);
                  return _context13.abrupt("return");

                case 19:
                  list = data.list, syncTime = data.syncTime, finished = data.finished;
                  chrmInfo.timestamp = syncTime; // 清除无效时间戳

                  chrmInfo.queue = chrmInfo.queue.filter(function (item) {
                    return item > syncTime;
                  }); // 派发消息

                  list.forEach(function (item) {
                    if (item.sentTime < timestamp) {
                      return;
                    }

                    _this7._watcher.message(item);
                  });

                  if (!finished || chrmInfo.queue.length > 0) {
                    this._pullChrmMsg(chrmId);
                  }

                case 24:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13, this);
        }));

        function _pullChrmMsg(_x24) {
          return _pullChrmMsg2.apply(this, arguments);
        }

        return _pullChrmMsg;
      }()
    }, {
      key: "joinChatroom",
      value: function () {
        var _joinChatroom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(chatroomId, count) {
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", this._joinChrm(chatroomId, count, false));

                case 1:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14, this);
        }));

        function joinChatroom(_x25, _x26) {
          return _joinChatroom.apply(this, arguments);
        }

        return joinChatroom;
      }()
    }, {
      key: "joinExistChatroom",
      value: function () {
        var _joinExistChatroom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(chatroomId, count) {
          return regeneratorRuntime.wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  return _context15.abrupt("return", this._joinChrm(chatroomId, count, true));

                case 1:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15, this);
        }));

        function joinExistChatroom(_x27, _x28) {
          return _joinExistChatroom.apply(this, arguments);
        }

        return joinExistChatroom;
      }()
    }, {
      key: "quitChatroom",
      value: function () {
        var _quitChatroom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(chrmId) {
          var channel, buff, writer, resp, code;
          return regeneratorRuntime.wrap(function _callee16$(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  channel = this._channel;

                  if (channel) {
                    _context16.next = 3;
                    break;
                  }

                  return _context16.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 3:
                  buff = channel.codec.encodeJoinOrQuitChatRoom();
                  writer = new QueryWriter(QueryTopic.QUIT_CHATROOM, buff, chrmId);
                  _context16.next = 7;
                  return channel.send(writer);

                case 7:
                  resp = _context16.sent;
                  code = resp.code;

                  if (code === ErrorCode$1.SUCCESS) {
                    delete this._chrmsQueue[chrmId];

                    this._chrmEntryHandler.reset(chrmId); // 移除加入聊天室存储信息


                    this._joinedChrmManager.remove(chrmId);
                  }

                  return _context16.abrupt("return", code);

                case 11:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee16, this);
        }));

        function quitChatroom(_x29) {
          return _quitChatroom.apply(this, arguments);
        }

        return quitChatroom;
      }()
    }, {
      key: "getChatroomInfo",
      value: function () {
        var _getChatroomInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(chatroomId, count, order) {
          var channel, buff, writer, resp, code, data;
          return regeneratorRuntime.wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  channel = this._channel;

                  if (channel) {
                    _context17.next = 3;
                    break;
                  }

                  return _context17.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 3:
                  buff = channel.codec.encodeGetChatRoomInfo(count, order);
                  writer = new QueryWriter(Topic$1[Topic$1.queryChrmI], buff, chatroomId);
                  _context17.next = 7;
                  return channel.send(writer, PBName.QueryChatRoomInfoOutput);

                case 7:
                  resp = _context17.sent;
                  code = resp.code, data = resp.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context17.next = 11;
                    break;
                  }

                  return _context17.abrupt("return", {
                    code: code
                  });

                case 11:
                  return _context17.abrupt("return", {
                    code: code,
                    data: data
                  });

                case 12:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17, this);
        }));

        function getChatroomInfo(_x30, _x31, _x32) {
          return _getChatroomInfo.apply(this, arguments);
        }

        return getChatroomInfo;
      }()
    }, {
      key: "getChatroomHistoryMessages",
      value: function () {
        var _getChatroomHistoryMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(chatroomId, timestamp, count, order) {
          var channel, buff, writer, resp, code, data;
          return regeneratorRuntime.wrap(function _callee18$(_context18) {
            while (1) {
              switch (_context18.prev = _context18.next) {
                case 0:
                  channel = this._channel;

                  if (channel) {
                    _context18.next = 3;
                    break;
                  }

                  return _context18.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 3:
                  buff = channel.codec.encodeGetHistoryMsg(chatroomId, {
                    timestamp: timestamp,
                    count: count,
                    order: order
                  });
                  writer = new QueryWriter(QueryHistoryTopic.CHATROOM, buff, chatroomId);
                  _context18.next = 7;
                  return channel.send(writer, PBName.HistoryMsgOuput, {
                    conversation: {
                      targetId: chatroomId
                    }
                  });

                case 7:
                  resp = _context18.sent;
                  code = resp.code;
                  data = resp.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context18.next = 12;
                    break;
                  }

                  return _context18.abrupt("return", {
                    code: code
                  });

                case 12:
                  return _context18.abrupt("return", {
                    code: code,
                    data: {
                      list: data.list,
                      hasMore: data.hasMore
                    }
                  });

                case 13:
                case "end":
                  return _context18.stop();
              }
            }
          }, _callee18, this);
        }));

        function getChatroomHistoryMessages(_x33, _x34, _x35, _x36) {
          return _getChatroomHistoryMessages.apply(this, arguments);
        }

        return getChatroomHistoryMessages;
      }()
    }, {
      key: "_modifyChatroomKV",
      value: function () {
        var _modifyChatroomKV2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(chatroomId, entry) {
          var channel, currentUserId, buff, topic, writer, resp, code;
          return regeneratorRuntime.wrap(function _callee19$(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  channel = this._channel, currentUserId = this.currentUserId;

                  if (channel) {
                    _context19.next = 3;
                    break;
                  }

                  return _context19.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 3:
                  buff = channel.codec.encodeModifyChatRoomKV(chatroomId, entry, currentUserId);
                  topic = entry.type === ChatroomEntryType$1.UPDATE ? QueryTopic.UPDATE_CHATROOM_KV : QueryTopic.DELETE_CHATROOM_KV;
                  writer = new QueryWriter(topic, buff, chatroomId);
                  _context19.next = 8;
                  return channel.send(writer);

                case 8:
                  resp = _context19.sent;
                  code = resp.code;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context19.next = 13;
                    break;
                  }

                  this._chrmEntryHandler.setLocal(chatroomId, {
                    kvEntries: [entry],
                    syncTime: new Date().getTime()
                  }, currentUserId);

                  return _context19.abrupt("return", code);

                case 13:
                  return _context19.abrupt("return", code);

                case 14:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee19, this);
        }));

        function _modifyChatroomKV(_x37, _x38) {
          return _modifyChatroomKV2.apply(this, arguments);
        }

        return _modifyChatroomKV;
      }()
    }, {
      key: "setChatroomEntry",
      value: function () {
        var _setChatroomEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(chatroomId, entry) {
          return regeneratorRuntime.wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  entry.type = ChatroomEntryType$1.UPDATE;
                  return _context20.abrupt("return", this._modifyChatroomKV(chatroomId, entry));

                case 2:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20, this);
        }));

        function setChatroomEntry(_x39, _x40) {
          return _setChatroomEntry.apply(this, arguments);
        }

        return setChatroomEntry;
      }()
    }, {
      key: "forceSetChatroomEntry",
      value: function () {
        var _forceSetChatroomEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(chatroomId, entry) {
          return regeneratorRuntime.wrap(function _callee21$(_context21) {
            while (1) {
              switch (_context21.prev = _context21.next) {
                case 0:
                  entry.type = ChatroomEntryType$1.UPDATE;
                  entry.isOverwrite = true;
                  return _context21.abrupt("return", this._modifyChatroomKV(chatroomId, entry));

                case 3:
                case "end":
                  return _context21.stop();
              }
            }
          }, _callee21, this);
        }));

        function forceSetChatroomEntry(_x41, _x42) {
          return _forceSetChatroomEntry.apply(this, arguments);
        }

        return forceSetChatroomEntry;
      }()
    }, {
      key: "removeChatroomEntry",
      value: function () {
        var _removeChatroomEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(chatroomId, entry) {
          return regeneratorRuntime.wrap(function _callee22$(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  entry.type = ChatroomEntryType$1.DELETE;
                  return _context22.abrupt("return", this._modifyChatroomKV(chatroomId, entry));

                case 2:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee22, this);
        }));

        function removeChatroomEntry(_x43, _x44) {
          return _removeChatroomEntry.apply(this, arguments);
        }

        return removeChatroomEntry;
      }()
    }, {
      key: "forceRemoveChatroomEntry",
      value: function () {
        var _forceRemoveChatroomEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(chatroomId, entry) {
          return regeneratorRuntime.wrap(function _callee23$(_context23) {
            while (1) {
              switch (_context23.prev = _context23.next) {
                case 0:
                  entry.type = ChatroomEntryType$1.DELETE;
                  entry.isOverwrite = true;
                  return _context23.abrupt("return", this._modifyChatroomKV(chatroomId, entry));

                case 3:
                case "end":
                  return _context23.stop();
              }
            }
          }, _callee23, this);
        }));

        function forceRemoveChatroomEntry(_x45, _x46) {
          return _forceRemoveChatroomEntry.apply(this, arguments);
        }

        return forceRemoveChatroomEntry;
      }()
    }, {
      key: "getChatroomEntry",
      value: function getChatroomEntry(chatroomId, key) {
        // 1、判断用户是否在聊天室，不在抛出 不在聊天室 错误码 2、从本地获取 key value 属性
        var entry = this._chrmEntryHandler.getValue(chatroomId, key);

        if (entry) {
          return Promise.resolve({
            code: ErrorCode$1.SUCCESS,
            data: entry
          });
        } else {
          return Promise.resolve({
            code: ErrorCode$1.CHATROOM_KEY_NOT_EXIST
          });
        }
      }
    }, {
      key: "getAllChatroomEntry",
      value: function getAllChatroomEntry(chatroomId) {
        // 1、判断用户是否在聊天室，不在抛出 不在聊天室 错误码 2、从本地获取 key value 属性
        var entries = this._chrmEntryHandler.getAll(chatroomId);

        return Promise.resolve({
          code: ErrorCode$1.SUCCESS,
          data: entries
        });
      }
      /**
       * 拉取聊天室 KV 存储
       * @param chatroomId
       * @param timestamp
      */

    }, {
      key: "pullChatroomEntry",
      value: function () {
        var _pullChatroomEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(chatroomId, timestamp) {
          var channel, currentUserId, buff, writer, resp, code, data, kvEntries, updatedEntries;
          return regeneratorRuntime.wrap(function _callee24$(_context24) {
            while (1) {
              switch (_context24.prev = _context24.next) {
                case 0:
                  channel = this._channel, currentUserId = this.currentUserId;

                  if (channel) {
                    _context24.next = 3;
                    break;
                  }

                  return _context24.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 3:
                  buff = channel.codec.encodePullChatRoomKV(timestamp);
                  writer = new QueryWriter(Topic$1[Topic$1.pullKV], buff, chatroomId);
                  _context24.next = 7;
                  return channel.send(writer, PBName.ChrmKVOutput);

                case 7:
                  resp = _context24.sent;
                  code = resp.code, data = resp.data;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context24.next = 15;
                    break;
                  }

                  // 拉取完成后，向本地缓存 kv
                  this._chrmEntryHandler.setLocal(chatroomId, data, currentUserId); // 拉取完成后, 如果有拉取到更新的 entry 通知聊天室 KV 监听器


                  kvEntries = data.kvEntries;
                  updatedEntries = [];

                  if (kvEntries.length > 0) {
                    kvEntries.forEach(function (entry) {
                      var key = entry.key,
                          value = entry.value,
                          type = entry.type,
                          timestamp = entry.timestamp;
                      updatedEntries.push({
                        key: key,
                        value: value,
                        type: type,
                        timestamp: timestamp,
                        chatroomId: chatroomId
                      });
                    });

                    this._watcher.chatroom({
                      updatedEntries: updatedEntries
                    });
                  }

                  return _context24.abrupt("return", {
                    code: code,
                    data: data
                  });

                case 15:
                  return _context24.abrupt("return", {
                    code: code
                  });

                case 16:
                case "end":
                  return _context24.stop();
              }
            }
          }, _callee24, this);
        }));

        function pullChatroomEntry(_x47, _x48) {
          return _pullChatroomEntry.apply(this, arguments);
        }

        return pullChatroomEntry;
      }()
      /**
       * 消息发送
       * @param conversationType
       * @param targetId
       * @param options
       */

    }, {
      key: "sendMessage",
      value: function () {
        var _sendMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(conversationType, targetId, options) {
          var _options$pushConfig;

          var isStatusMessage, topic, data, signal, _yield$this$_channel$3, code, resp, pubAck, receivedMessage;

          return regeneratorRuntime.wrap(function _callee25$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  if (this._channel) {
                    _context25.next = 2;
                    break;
                  }

                  return _context25.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  options = handleInnerMsgOptions(options, this.currentUserId);
                  options = this._handleMsgProperties(options, true); // 检查是否为状态消息，状态消息只在单聊、群聊类型会话中有效

                  isStatusMessage = [ConversationType$1.PRIVATE, ConversationType$1.GROUP].includes(conversationType) ? options.isStatusMessage : false;
                  topic = isStatusMessage ? getStatPubTopic(conversationType) : getPubTopic(conversationType) || Topic$1.ppMsgP;

                  if (isStatusMessage) {
                    options.isPersited = false;
                    options.isCounted = false;
                  }

                  options.pushContent = ((_options$pushConfig = options.pushConfig) === null || _options$pushConfig === void 0 ? void 0 : _options$pushConfig.pushContent) || options.pushContent || '';
                  data = this._channel.codec.encodeUpMsg({
                    type: conversationType,
                    targetId: targetId
                  }, options);
                  signal = new PublishWriter(Topic$1[topic], data, targetId);
                  signal.setHeaderQos(QOS.AT_LEAST_ONCE); // 状态消息无 Ack 应答

                  if (!isStatusMessage) {
                    _context25.next = 14;
                    break;
                  }

                  this._channel.sendOnly(signal);

                  return _context25.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: transSentAttrs2IReceivedMessage(conversationType, targetId, _objectSpread2({}, options), '', 0, this.currentUserId)
                  });

                case 14:
                  _context25.next = 16;
                  return this._channel.send(signal);

                case 16:
                  _yield$this$_channel$3 = _context25.sent;
                  code = _yield$this$_channel$3.code;
                  resp = _yield$this$_channel$3.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context25.next = 21;
                    break;
                  }

                  return _context25.abrupt("return", {
                    code: code
                  });

                case 21:
                  pubAck = resp; // 更新发件箱时间

                  this._letterbox.setOutboxTime(pubAck.timestamp, this.currentUserId); // 更新会话监听


                  receivedMessage = transSentAttrs2IReceivedMessage(conversationType, targetId, _objectSpread2({}, options), pubAck.messageUId, pubAck.timestamp, this.currentUserId);

                  this._conversationManager.setConversationCacheByMessage(receivedMessage, true);

                  return _context25.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: receivedMessage
                  });

                case 26:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee25, this);
        }));

        function sendMessage(_x49, _x50, _x51) {
          return _sendMessage.apply(this, arguments);
        }

        return sendMessage;
      }()
    }, {
      key: "recallMsg",
      value: function () {
        var _recallMsg = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(conversationType, targetId, messageUId, sentTime, recallMsgOptions) {
          var _recallMsgOptions$pus;

          var user, msg, topic, data, signal, _yield$this$_channel$4, code, resp, pubAck;

          return regeneratorRuntime.wrap(function _callee26$(_context26) {
            while (1) {
              switch (_context26.prev = _context26.next) {
                case 0:
                  if (this._channel) {
                    _context26.next = 2;
                    break;
                  }

                  return _context26.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  user = recallMsgOptions.user; // user 为发送撤回消息携带的用户信息

                  msg = {
                    content: {
                      conversationType: conversationType,
                      targetId: targetId,
                      messageUId: messageUId,
                      sentTime: sentTime,
                      user: user
                    },
                    messageType: 'RC:RcCmd',
                    disableNotification: recallMsgOptions === null || recallMsgOptions === void 0 ? void 0 : recallMsgOptions.disableNotification,
                    pushConfig: recallMsgOptions === null || recallMsgOptions === void 0 ? void 0 : recallMsgOptions.pushConfig,
                    pushContent: ((_recallMsgOptions$pus = recallMsgOptions.pushConfig) === null || _recallMsgOptions$pus === void 0 ? void 0 : _recallMsgOptions$pus.pushContent) || recallMsgOptions.pushContent || ''
                  };
                  topic = Topic$1[Topic$1.recallMsg];
                  data = this._channel.codec.encodeUpMsg({
                    type: conversationType,
                    targetId: targetId
                  }, msg);
                  signal = new PublishWriter(topic, data, this.currentUserId);
                  signal.setHeaderQos(QOS.AT_LEAST_ONCE);
                  _context26.next = 10;
                  return this._channel.send(signal);

                case 10:
                  _yield$this$_channel$4 = _context26.sent;
                  code = _yield$this$_channel$4.code;
                  resp = _yield$this$_channel$4.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context26.next = 15;
                    break;
                  }

                  return _context26.abrupt("return", {
                    code: code
                  });

                case 15:
                  pubAck = resp;
                  return _context26.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: transSentAttrs2IReceivedMessage(conversationType, targetId, _objectSpread2({}, msg), pubAck.messageUId, pubAck.timestamp, this.currentUserId)
                  });

                case 17:
                case "end":
                  return _context26.stop();
              }
            }
          }, _callee26, this);
        }));

        function recallMsg(_x52, _x53, _x54, _x55, _x56) {
          return _recallMsg.apply(this, arguments);
        }

        return recallMsg;
      }()
      /**
       * 拉取用户配置
       * @todo 需要确定 version 的作用是什么
       * @param version
       */

    }, {
      key: "pullUserSettings",
      value: function () {
        var _pullUserSettings = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(version) {
          var buff, writer;
          return regeneratorRuntime.wrap(function _callee27$(_context27) {
            while (1) {
              switch (_context27.prev = _context27.next) {
                case 0:
                  if (this._channel) {
                    _context27.next = 2;
                    break;
                  }

                  return _context27.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  buff = this._channel.codec.encodePullUserSetting(version);
                  writer = new QueryWriter(Topic$1[Topic$1.pullUS], buff, this.currentUserId);
                  return _context27.abrupt("return", this._channel.send(writer, PBName.PullUserSettingOutput));

                case 5:
                case "end":
                  return _context27.stop();
              }
            }
          }, _callee27, this);
        }));

        function pullUserSettings(_x57) {
          return _pullUserSettings.apply(this, arguments);
        }

        return pullUserSettings;
      }()
    }, {
      key: "getFileToken",
      value: function () {
        var _getFileToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(fileType, fileName) {
          var uploadFileName, buff, writer, _yield$this$_channel$5, code, data;

          return regeneratorRuntime.wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  if (this._channel) {
                    _context28.next = 2;
                    break;
                  }

                  return _context28.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  // 若不设置 fileName 百度上传的认证数据均返回 null
                  uploadFileName = getUploadFileName(fileType, fileName);
                  buff = this._channel.codec.encodeGetFileToken(fileType, uploadFileName);
                  writer = new QueryWriter(Topic$1[Topic$1.qnTkn], buff, this.currentUserId);
                  _context28.next = 7;
                  return this._channel.send(writer, PBName.GetQNupTokenOutput);

                case 7:
                  _yield$this$_channel$5 = _context28.sent;
                  code = _yield$this$_channel$5.code;
                  data = _yield$this$_channel$5.data;
                  data = Object.assign(data, {
                    fileName: uploadFileName
                  });
                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context28.next = 13;
                    break;
                  }

                  return _context28.abrupt("return", {
                    code: code,
                    data: data
                  });

                case 13:
                  return _context28.abrupt("return", {
                    code: code
                  });

                case 14:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28, this);
        }));

        function getFileToken(_x58, _x59) {
          return _getFileToken.apply(this, arguments);
        }

        return getFileToken;
      }()
    }, {
      key: "getFileUrl",
      value: function () {
        var _getFileUrl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(fileType, uploadMethod, fileName, originName) {
          var topic, inputPBName, outputPBName, buff, writer, _yield$this$_channel$6, code, data, resp;

          return regeneratorRuntime.wrap(function _callee29$(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  if (this._channel) {
                    _context29.next = 2;
                    break;
                  }

                  return _context29.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  topic = '';
                  inputPBName = '';
                  outputPBName = '';

                  if (uploadMethod === UploadMethod$1.QINIU) {
                    topic = Topic$1[Topic$1.qnUrl];
                    inputPBName = PBName.GetQNdownloadUrlInput;
                    outputPBName = PBName.GetQNdownloadUrlOutput;
                  } else if (uploadMethod === UploadMethod$1.AWS) {
                    topic = Topic$1[Topic$1.s3Url];
                    inputPBName = PBName.GetDownloadUrlInput;
                    outputPBName = PBName.GetDownloadUrlOutput;
                  } else {
                    topic = Topic$1[Topic$1.aliUrl];
                    inputPBName = PBName.GetDownloadUrlInput;
                    outputPBName = PBName.GetDownloadUrlOutput;
                  }

                  buff = this._channel.codec.encodeGetFileUrl(inputPBName, fileType, fileName, originName);
                  writer = new QueryWriter(topic, buff, this.currentUserId);
                  _context29.next = 10;
                  return this._channel.send(writer, outputPBName);

                case 10:
                  _yield$this$_channel$6 = _context29.sent;
                  code = _yield$this$_channel$6.code;
                  data = _yield$this$_channel$6.data;
                  resp = data;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context29.next = 16;
                    break;
                  }

                  return _context29.abrupt("return", {
                    code: code,
                    data: resp
                  });

                case 16:
                  return _context29.abrupt("return", {
                    code: code
                  });

                case 17:
                case "end":
                  return _context29.stop();
              }
            }
          }, _callee29, this);
        }));

        function getFileUrl(_x60, _x61, _x62, _x63) {
          return _getFileUrl.apply(this, arguments);
        }

        return getFileUrl;
      }()
    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this._channel) {
          this._channel.close();

          this._channel = undefined;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        throw new Error('JSEngine\'s method not implemented.');
      }
    }, {
      key: "registerMessageType",
      value: function registerMessageType(objectName, isPersited, isCounted, searchProps) {
        // ✔️ 根据 objectName 将自定义消息属性内存态存储 [objectName]: {isPersited, isCounted}
        this._customMessageType[objectName] = {
          isPersited: isPersited,
          isCounted: isCounted
        }; // 根据 messageName searchProps 生成构造消息（ V3 不实现 V2 API 层实现）
        // ✔️ SDK 发消息时，根据内置消息类型或自定义消息类型去处理 存储、计数属性
        // ✔️ SDK 收到消息后，内置消息类型的属性（存储、计数）去处理收到的消息、本地会话未读数存储
      } // ===================== 标签 相关接口 =====================

      /**
       * 创建标签
       * @param tag 标签
       */

    }, {
      key: "createTag",
      value: function () {
        var _createTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(tag) {
          var buff, signal, _yield$this$_channel$7, code, data, version;

          return regeneratorRuntime.wrap(function _callee30$(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  if (this._channel) {
                    _context30.next = 2;
                    break;
                  }

                  return _context30.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  buff = this._channel.codec.encodeCreateTag([tag]);
                  signal = new QueryWriter(Topic$1[Topic$1.addSeTag], buff, this.currentUserId);
                  _context30.next = 6;
                  return this._channel.send(signal, PBName.SetUserSettingOutput);

                case 6:
                  _yield$this$_channel$7 = _context30.sent;
                  code = _yield$this$_channel$7.code;
                  data = _yield$this$_channel$7.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context30.next = 11;
                    break;
                  }

                  return _context30.abrupt("return", {
                    code: code
                  });

                case 11:
                  version = data.version;

                  this._tagManager.addTag([_objectSpread2(_objectSpread2({}, tag), {}, {
                    createdTime: version
                  })]);

                  return _context30.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: data
                  });

                case 14:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee30, this);
        }));

        function createTag(_x64) {
          return _createTag.apply(this, arguments);
        }

        return createTag;
      }()
      /**
       * 删除标签
       * @param tagId 标签id
       */

    }, {
      key: "removeTag",
      value: function () {
        var _removeTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(tagId) {
          var buff, signal, _yield$this$_channel$8, code;

          return regeneratorRuntime.wrap(function _callee31$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  if (this._channel) {
                    _context31.next = 2;
                    break;
                  }

                  return _context31.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  buff = this._channel.codec.encodeRemoveTag([tagId]);
                  signal = new QueryWriter(Topic$1[Topic$1.delSeTag], buff, this.currentUserId);
                  _context31.next = 6;
                  return this._channel.send(signal);

                case 6:
                  _yield$this$_channel$8 = _context31.sent;
                  code = _yield$this$_channel$8.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context31.next = 10;
                    break;
                  }

                  return _context31.abrupt("return", {
                    code: code
                  });

                case 10:
                  this._tagManager.deleteTag([tagId]);

                  return _context31.abrupt("return", {
                    code: ErrorCode$1.SUCCESS
                  });

                case 12:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee31, this);
        }));

        function removeTag(_x65) {
          return _removeTag.apply(this, arguments);
        }

        return removeTag;
      }()
      /**
       * 更新标签
       * @param tag 标签
       */

    }, {
      key: "updateTag",
      value: function () {
        var _updateTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(tag) {
          var buff, signal, _yield$this$_channel$9, code, data;

          return regeneratorRuntime.wrap(function _callee32$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  if (this._channel) {
                    _context32.next = 2;
                    break;
                  }

                  return _context32.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  buff = this._channel.codec.encodeCreateTag([tag]);
                  signal = new QueryWriter(Topic$1[Topic$1.addSeTag], buff, this.currentUserId);
                  _context32.next = 6;
                  return this._channel.send(signal);

                case 6:
                  _yield$this$_channel$9 = _context32.sent;
                  code = _yield$this$_channel$9.code;
                  data = _yield$this$_channel$9.data;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context32.next = 11;
                    break;
                  }

                  return _context32.abrupt("return", {
                    code: code
                  });

                case 11:
                  this._tagManager.addTag([tag]);

                  return _context32.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: data
                  });

                case 13:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee32, this);
        }));

        function updateTag(_x66) {
          return _updateTag.apply(this, arguments);
        }

        return updateTag;
      }()
      /**
       * 获取标签列表
       * @param timestamp
       */

    }, {
      key: "getTagList",
      value: function () {
        var _getTagList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33() {
          var list, conversationObj;
          return regeneratorRuntime.wrap(function _callee33$(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  list = this._tagManager.getTags();
                  conversationObj = this._conversationManager.getConversationListForTag();
                  list.forEach(function (item) {
                    item.conversationCount = conversationObj[item.tagId] ? conversationObj[item.tagId].length : 0;
                  });
                  return _context33.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: list
                  });

                case 4:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee33, this);
        }));

        function getTagList() {
          return _getTagList.apply(this, arguments);
        }

        return getTagList;
      }()
    }, {
      key: "addTagForConversations",
      value: function () {
        var _addTagForConversations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(tagId, conversations) {
          var _this8 = this;

          var buff, signal, _yield$this$_channel$10, code, tag;

          return regeneratorRuntime.wrap(function _callee34$(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  if (this._channel) {
                    _context34.next = 2;
                    break;
                  }

                  return _context34.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  if (this._tagManager.getTagById(tagId)) {
                    _context34.next = 4;
                    break;
                  }

                  return _context34.abrupt("return", {
                    code: ErrorCode$1.TAG_NOT_EXIST
                  });

                case 4:
                  buff = this._channel.codec.encodeUpdateConversationTag([{
                    tagId: tagId
                  }], conversations);
                  signal = new QueryWriter(Topic$1[Topic$1.addTag], buff, this.currentUserId);
                  _context34.next = 8;
                  return this._channel.send(signal);

                case 8:
                  _yield$this$_channel$10 = _context34.sent;
                  code = _yield$this$_channel$10.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context34.next = 12;
                    break;
                  }

                  return _context34.abrupt("return", {
                    code: code
                  });

                case 12:
                  tag = {};
                  tag[tagId] = {};
                  conversations.forEach(function (con) {
                    _this8._conversationManager.addTagStatus(con.type, con.targetId, tag);
                  });
                  return _context34.abrupt("return", {
                    code: ErrorCode$1.SUCCESS
                  });

                case 16:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee34, this);
        }));

        function addTagForConversations(_x67, _x68) {
          return _addTagForConversations.apply(this, arguments);
        }

        return addTagForConversations;
      }()
    }, {
      key: "removeTagForConversations",
      value: function () {
        var _removeTagForConversations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(tagId, conversations) {
          var _this9 = this;

          var buff, signal, _yield$this$_channel$11, code;

          return regeneratorRuntime.wrap(function _callee35$(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  if (this._channel) {
                    _context35.next = 2;
                    break;
                  }

                  return _context35.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  buff = this._channel.codec.encodeUpdateConversationTag([{
                    tagId: tagId
                  }], conversations);
                  signal = new QueryWriter(Topic$1[Topic$1.delTag], buff, this.currentUserId);
                  _context35.next = 6;
                  return this._channel.send(signal);

                case 6:
                  _yield$this$_channel$11 = _context35.sent;
                  code = _yield$this$_channel$11.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context35.next = 10;
                    break;
                  }

                  return _context35.abrupt("return", {
                    code: code
                  });

                case 10:
                  conversations.forEach(function (con) {
                    _this9._conversationManager.deleteTagStatus(con.type, con.targetId, [tagId]);
                  });
                  return _context35.abrupt("return", {
                    code: ErrorCode$1.SUCCESS
                  });

                case 12:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee35, this);
        }));

        function removeTagForConversations(_x69, _x70) {
          return _removeTagForConversations.apply(this, arguments);
        }

        return removeTagForConversations;
      }()
    }, {
      key: "removeTagsForConversation",
      value: function () {
        var _removeTagsForConversation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(conversation, tagIds) {
          var type, targetId, tags, buff, signal, _yield$this$_channel$12, code;

          return regeneratorRuntime.wrap(function _callee36$(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  if (this._channel) {
                    _context36.next = 2;
                    break;
                  }

                  return _context36.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  type = conversation.type, targetId = conversation.targetId;
                  tags = tagIds.map(function (tagId) {
                    return {
                      tagId: tagId
                    };
                  });
                  buff = this._channel.codec.encodeUpdateConversationTag(tags, [conversation]);
                  signal = new QueryWriter(Topic$1[Topic$1.delTag], buff, this.currentUserId);
                  _context36.next = 8;
                  return this._channel.send(signal);

                case 8:
                  _yield$this$_channel$12 = _context36.sent;
                  code = _yield$this$_channel$12.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context36.next = 12;
                    break;
                  }

                  return _context36.abrupt("return", {
                    code: code
                  });

                case 12:
                  this._conversationManager.deleteTagStatus(type, targetId, tagIds);

                  return _context36.abrupt("return", {
                    code: ErrorCode$1.SUCCESS
                  });

                case 14:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee36, this);
        }));

        function removeTagsForConversation(_x71, _x72) {
          return _removeTagsForConversation.apply(this, arguments);
        }

        return removeTagsForConversation;
      }()
    }, {
      key: "getConversationListByTag",
      value: function () {
        var _getConversationListByTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(tagId, startTime, count) {
          var currentUserId, channel, buff, writer, resp, code, data, list;
          return regeneratorRuntime.wrap(function _callee37$(_context37) {
            while (1) {
              switch (_context37.prev = _context37.next) {
                case 0:
                  currentUserId = this.currentUserId, channel = this._channel;

                  if (channel) {
                    _context37.next = 3;
                    break;
                  }

                  return _context37.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 3:
                  // type 服务端未用到此字段，直接返回所有类型
                  buff = channel.codec.encodeOldConversationList({
                    count: count,
                    type: ConversationType$1.PRIVATE,
                    startTime: startTime
                  });
                  writer = new QueryWriter(QueryTopic.GET_OLD_CONVERSATION_LIST, buff, currentUserId);
                  _context37.next = 7;
                  return channel.send(writer, PBName.RelationsOutput, {
                    currentUserId: currentUserId,
                    connectedTime: channel.connectedTime
                  });

                case 7:
                  resp = _context37.sent;
                  logger.info('GetConversationList =>', resp);
                  code = resp.code, data = resp.data;
                  list = this._conversationHasTagFilter(tagId, data);
                  logger.info('GetConversationListByTag', list);

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context37.next = 14;
                    break;
                  }

                  return _context37.abrupt("return", {
                    code: code
                  });

                case 14:
                  return _context37.abrupt("return", {
                    code: code,
                    data: list
                  });

                case 15:
                case "end":
                  return _context37.stop();
              }
            }
          }, _callee37, this);
        }));

        function getConversationListByTag(_x73, _x74, _x75) {
          return _getConversationListByTag.apply(this, arguments);
        }

        return getConversationListByTag;
      }()
      /**
       * 筛选出拥有指定标签的会话并排序
       * @param tagId
       * @param list
       */

    }, {
      key: "_conversationHasTagFilter",
      value: function _conversationHasTagFilter(tagId, list) {
        var _this10 = this;

        var isTopList = [];
        var commonList = []; // 拆分数组为置顶和非置顶两个数组

        list.forEach(function (item) {
          var conversationType = item.conversationType,
              targetId = item.targetId;

          var _this10$_conversation = _this10._conversationManager.get(conversationType, targetId),
              hasMentioned = _this10$_conversation.hasMentioned,
              mentionedInfo = _this10$_conversation.mentionedInfo,
              lastUnreadTime = _this10$_conversation.lastUnreadTime,
              notificationStatus = _this10$_conversation.notificationStatus,
              isTop = _this10$_conversation.isTop,
              tags = _this10$_conversation.tags;

          var tagStatus = tags && tags[tagId];

          if (tagStatus) {
            var con = _objectSpread2(_objectSpread2({}, item), {}, {
              hasMentioned: hasMentioned,
              mentionedInfo: mentionedInfo,
              lastUnreadTime: lastUnreadTime,
              notificationStatus: notificationStatus,
              isTop: isTop
            });

            if (tagStatus.isTop) {
              isTopList.push(_objectSpread2(_objectSpread2({}, con), {}, {
                isTopInTag: true
              }));
            } else {
              commonList.push(_objectSpread2(_objectSpread2({}, con), {}, {
                isTopInTag: false
              }));
            }
          }
        });

        function compare(a, b) {
          return a.latestMessage && b.latestMessage ? a.latestMessage.sentTime - b.latestMessage.sentTime : 0;
        } // 合并 并 排序


        var data = [].concat(_toConsumableArray(isTopList.sort(compare)), _toConsumableArray(commonList.sort(compare)));
        return data;
      }
    }, {
      key: "getUnreadCountByTag",
      value: function () {
        var _getUnreadCountByTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(tagId, containMuted) {
          var count;
          return regeneratorRuntime.wrap(function _callee38$(_context38) {
            while (1) {
              switch (_context38.prev = _context38.next) {
                case 0:
                  if (this._channel) {
                    _context38.next = 2;
                    break;
                  }

                  return _context38.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  count = this._conversationManager.getUnreadCountByTag(tagId, containMuted);
                  return _context38.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: count
                  });

                case 4:
                case "end":
                  return _context38.stop();
              }
            }
          }, _callee38, this);
        }));

        function getUnreadCountByTag(_x76, _x77) {
          return _getUnreadCountByTag.apply(this, arguments);
        }

        return getUnreadCountByTag;
      }()
    }, {
      key: "setConversationStatusInTag",
      value: function () {
        var _setConversationStatusInTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(tagId, conversation, status) {
          var targetId, type, isTop, tags, localConversation, buff, signal, _yield$this$_channel$13, code, tagStatus;

          return regeneratorRuntime.wrap(function _callee39$(_context39) {
            while (1) {
              switch (_context39.prev = _context39.next) {
                case 0:
                  if (this._channel) {
                    _context39.next = 2;
                    break;
                  }

                  return _context39.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  targetId = conversation.targetId, type = conversation.type;
                  isTop = status.isTop;
                  tags = [{
                    tagId: tagId,
                    isTop: isTop
                  }]; // 校验会话中是否存在标签

                  localConversation = this._conversationManager.get(type, targetId);

                  if (!(!localConversation.tags || !Object.hasOwnProperty.call(localConversation.tags, tagId))) {
                    _context39.next = 8;
                    break;
                  }

                  return _context39.abrupt("return", {
                    code: ErrorCode$1.NO_TAG_IN_CONVER
                  });

                case 8:
                  buff = this._channel.codec.encodeUpdateConversationTag(tags, [conversation]);
                  signal = new QueryWriter(Topic$1[Topic$1.addTag], buff, this.currentUserId);
                  _context39.next = 12;
                  return this._channel.send(signal);

                case 12:
                  _yield$this$_channel$13 = _context39.sent;
                  code = _yield$this$_channel$13.code;

                  if (!(code !== ErrorCode$1.SUCCESS)) {
                    _context39.next = 16;
                    break;
                  }

                  return _context39.abrupt("return", {
                    code: code
                  });

                case 16:
                  tagStatus = {};
                  tagStatus[tagId] = {};

                  if (isTop) {
                    tagStatus[tagId].isTop = true;
                  }

                  this._conversationManager.addTagStatus(type, targetId, tagStatus);

                  return _context39.abrupt("return", {
                    code: ErrorCode$1.SUCCESS
                  });

                case 21:
                case "end":
                  return _context39.stop();
              }
            }
          }, _callee39, this);
        }));

        function setConversationStatusInTag(_x78, _x79, _x80) {
          return _setConversationStatusInTag.apply(this, arguments);
        }

        return setConversationStatusInTag;
      }()
    }, {
      key: "getTagsForConversation",
      value: function () {
        var _getTagsForConversation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(conversation) {
          var con, tags, tagList, tagId, _tags$tagId;

          return regeneratorRuntime.wrap(function _callee40$(_context40) {
            while (1) {
              switch (_context40.prev = _context40.next) {
                case 0:
                  if (this._channel) {
                    _context40.next = 2;
                    break;
                  }

                  return _context40.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  con = this._conversationManager.get(conversation.type, conversation.targetId);
                  tags = this._tagManager.getTagsInfo();
                  tagList = [];

                  if (con.tags) {
                    for (tagId in con.tags) {
                      tagList.push({
                        tagId: tagId,
                        tagName: (_tags$tagId = tags[tagId]) === null || _tags$tagId === void 0 ? void 0 : _tags$tagId.tagName
                      });
                    }
                  }

                  return _context40.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    data: tagList
                  });

                case 7:
                case "end":
                  return _context40.stop();
              }
            }
          }, _callee40, this);
        }));

        function getTagsForConversation(_x81) {
          return _getTagsForConversation.apply(this, arguments);
        }

        return getTagsForConversation;
      }() // ===================== 标签 相关接口 end =====================
      // ===================== RTC 相关接口 =====================

    }, {
      key: "joinRTCRoom",
      value: function () {
        var _joinRTCRoom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(roomId, mode, broadcastType) {
          var reqBody, writer;
          return regeneratorRuntime.wrap(function _callee41$(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  if (this._channel) {
                    _context41.next = 2;
                    break;
                  }

                  return _context41.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  reqBody = this._channel.codec.encodeJoinRTCRoom(mode, broadcastType);
                  writer = new QueryWriter(Topic$1[Topic$1.rtcRJoin_data], reqBody, roomId);
                  return _context41.abrupt("return", this._channel.send(writer, PBName.RtcUserListOutput));

                case 5:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee41, this);
        }));

        function joinRTCRoom(_x82, _x83, _x84) {
          return _joinRTCRoom.apply(this, arguments);
        }

        return joinRTCRoom;
      }()
    }, {
      key: "quitRTCRoom",
      value: function () {
        var _quitRTCRoom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(roomId) {
          var reqBody, writer, _yield$this$_channel$14, code;

          return regeneratorRuntime.wrap(function _callee42$(_context42) {
            while (1) {
              switch (_context42.prev = _context42.next) {
                case 0:
                  if (this._channel) {
                    _context42.next = 2;
                    break;
                  }

                  return _context42.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeQuitRTCRoom();
                  writer = new QueryWriter(Topic$1[Topic$1.rtcRExit], reqBody, roomId);
                  _context42.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$14 = _context42.sent;
                  code = _yield$this$_channel$14.code;
                  return _context42.abrupt("return", code);

                case 9:
                case "end":
                  return _context42.stop();
              }
            }
          }, _callee42, this);
        }));

        function quitRTCRoom(_x85) {
          return _quitRTCRoom.apply(this, arguments);
        }

        return quitRTCRoom;
      }()
    }, {
      key: "rtcPing",
      value: function () {
        var _rtcPing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(roomId, mode, broadcastType) {
          var reqBody, writer, _yield$this$_channel$15, code;

          return regeneratorRuntime.wrap(function _callee43$(_context43) {
            while (1) {
              switch (_context43.prev = _context43.next) {
                case 0:
                  if (this._channel) {
                    _context43.next = 2;
                    break;
                  }

                  return _context43.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeJoinRTCRoom(mode, broadcastType);
                  writer = new QueryWriter(Topic$1[Topic$1.rtcPing], reqBody, roomId);
                  _context43.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$15 = _context43.sent;
                  code = _yield$this$_channel$15.code;
                  return _context43.abrupt("return", code);

                case 9:
                case "end":
                  return _context43.stop();
              }
            }
          }, _callee43, this);
        }));

        function rtcPing(_x86, _x87, _x88) {
          return _rtcPing.apply(this, arguments);
        }

        return rtcPing;
      }()
    }, {
      key: "getRTCRoomInfo",
      value: function () {
        var _getRTCRoomInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(roomId) {
          var reqBody, writer;
          return regeneratorRuntime.wrap(function _callee44$(_context44) {
            while (1) {
              switch (_context44.prev = _context44.next) {
                case 0:
                  if (this._channel) {
                    _context44.next = 2;
                    break;
                  }

                  return _context44.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  reqBody = this._channel.codec.encodeGetRTCRoomInfo();
                  writer = new QueryWriter(Topic$1[Topic$1.rtcRInfo], reqBody, roomId);
                  return _context44.abrupt("return", this._channel.send(writer, PBName.RtcRoomInfoOutput));

                case 5:
                case "end":
                  return _context44.stop();
              }
            }
          }, _callee44, this);
        }));

        function getRTCRoomInfo(_x89) {
          return _getRTCRoomInfo.apply(this, arguments);
        }

        return getRTCRoomInfo;
      }()
    }, {
      key: "getRTCUserInfoList",
      value: function () {
        var _getRTCUserInfoList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(roomId) {
          var reqBody, writer, _yield$this$_channel$16, code, data;

          return regeneratorRuntime.wrap(function _callee45$(_context45) {
            while (1) {
              switch (_context45.prev = _context45.next) {
                case 0:
                  if (this._channel) {
                    _context45.next = 2;
                    break;
                  }

                  return _context45.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  reqBody = this._channel.codec.encodeGetRTCRoomInfo();
                  writer = new QueryWriter(Topic$1[Topic$1.rtcUData], reqBody, roomId);
                  _context45.next = 6;
                  return this._channel.send(writer, PBName.RtcUserListOutput);

                case 6:
                  _yield$this$_channel$16 = _context45.sent;
                  code = _yield$this$_channel$16.code;
                  data = _yield$this$_channel$16.data;
                  return _context45.abrupt("return", {
                    code: code,
                    data: data ? {
                      users: data.users
                    } : data
                  });

                case 10:
                case "end":
                  return _context45.stop();
              }
            }
          }, _callee45, this);
        }));

        function getRTCUserInfoList(_x90) {
          return _getRTCUserInfoList.apply(this, arguments);
        }

        return getRTCUserInfoList;
      }() // TODO: 排查 rtcUPut 超时无响应问题

    }, {
      key: "setRTCUserInfo",
      value: function () {
        var _setRTCUserInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46(roomId, key, value) {
          var reqBody, writer, _yield$this$_channel$17, code;

          return regeneratorRuntime.wrap(function _callee46$(_context46) {
            while (1) {
              switch (_context46.prev = _context46.next) {
                case 0:
                  if (this._channel) {
                    _context46.next = 2;
                    break;
                  }

                  return _context46.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeSetRTCUserInfo(key, value);
                  writer = new QueryWriter(Topic$1[Topic$1.rtcUPut], reqBody, roomId);
                  _context46.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$17 = _context46.sent;
                  code = _yield$this$_channel$17.code;
                  return _context46.abrupt("return", code);

                case 9:
                case "end":
                  return _context46.stop();
              }
            }
          }, _callee46, this);
        }));

        function setRTCUserInfo(_x91, _x92, _x93) {
          return _setRTCUserInfo.apply(this, arguments);
        }

        return setRTCUserInfo;
      }()
    }, {
      key: "removeRTCUserInfo",
      value: function () {
        var _removeRTCUserInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(roomId, keys) {
          var reqBody, writer, _yield$this$_channel$18, code;

          return regeneratorRuntime.wrap(function _callee47$(_context47) {
            while (1) {
              switch (_context47.prev = _context47.next) {
                case 0:
                  if (this._channel) {
                    _context47.next = 2;
                    break;
                  }

                  return _context47.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeRemoveRTCUserInfo(keys);
                  writer = new PublishWriter(Topic$1[Topic$1.rtcUDel], reqBody, roomId);
                  _context47.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$18 = _context47.sent;
                  code = _yield$this$_channel$18.code;
                  return _context47.abrupt("return", code);

                case 9:
                case "end":
                  return _context47.stop();
              }
            }
          }, _callee47, this);
        }));

        function removeRTCUserInfo(_x94, _x95) {
          return _removeRTCUserInfo.apply(this, arguments);
        }

        return removeRTCUserInfo;
      }()
    }, {
      key: "setRTCData",
      value: function () {
        var _setRTCData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(roomId, key, value, isInner, apiType, message) {
          var reqBody, writer, _yield$this$_channel$19, code;

          return regeneratorRuntime.wrap(function _callee48$(_context48) {
            while (1) {
              switch (_context48.prev = _context48.next) {
                case 0:
                  if (this._channel) {
                    _context48.next = 2;
                    break;
                  }

                  return _context48.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeSetRTCData(key, value, isInner, apiType, message);
                  writer = new PublishWriter(Topic$1[Topic$1.rtcSetData], reqBody, roomId);
                  _context48.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$19 = _context48.sent;
                  code = _yield$this$_channel$19.code;
                  return _context48.abrupt("return", code);

                case 9:
                case "end":
                  return _context48.stop();
              }
            }
          }, _callee48, this);
        }));

        function setRTCData(_x96, _x97, _x98, _x99, _x100, _x101) {
          return _setRTCData.apply(this, arguments);
        }

        return setRTCData;
      }()
    }, {
      key: "setRTCTotalRes",
      value: function () {
        var _setRTCTotalRes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49(roomId, message, valueInfo, objectName) {
          var reqBody, writer, _yield$this$_channel$20, code;

          return regeneratorRuntime.wrap(function _callee49$(_context49) {
            while (1) {
              switch (_context49.prev = _context49.next) {
                case 0:
                  if (this._channel) {
                    _context49.next = 2;
                    break;
                  }

                  return _context49.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeUserSetRTCData(message, valueInfo, objectName);
                  writer = new PublishWriter(Topic$1[Topic$1.userSetData], reqBody, roomId);
                  _context49.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$20 = _context49.sent;
                  code = _yield$this$_channel$20.code;
                  return _context49.abrupt("return", code);

                case 9:
                case "end":
                  return _context49.stop();
              }
            }
          }, _callee49, this);
        }));

        function setRTCTotalRes(_x102, _x103, _x104, _x105) {
          return _setRTCTotalRes.apply(this, arguments);
        }

        return setRTCTotalRes;
      }()
    }, {
      key: "getRTCData",
      value: function getRTCData(roomId, keys, isInner, apiType) {
        if (!this._channel) {
          return Promise.resolve({
            code: ErrorCode$1.RC_NET_CHANNEL_INVALID
          });
        }

        var reqBody = this._channel.codec.encodeGetRTCData(keys, isInner, apiType);

        var writer = new QueryWriter(Topic$1[Topic$1.rtcQryData], reqBody, roomId);
        return this._channel.send(writer, PBName.RtcQryOutput);
      }
    }, {
      key: "removeRTCData",
      value: function () {
        var _removeRTCData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(roomId, keys, isInner, apiType, message) {
          var reqBody, writer, _yield$this$_channel$21, code;

          return regeneratorRuntime.wrap(function _callee50$(_context50) {
            while (1) {
              switch (_context50.prev = _context50.next) {
                case 0:
                  if (this._channel) {
                    _context50.next = 2;
                    break;
                  }

                  return _context50.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeRemoveRTCData(keys, isInner, apiType, message);
                  writer = new PublishWriter(Topic$1[Topic$1.rtcDelData], reqBody, roomId);
                  _context50.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$21 = _context50.sent;
                  code = _yield$this$_channel$21.code;
                  return _context50.abrupt("return", code);

                case 9:
                case "end":
                  return _context50.stop();
              }
            }
          }, _callee50, this);
        }));

        function removeRTCData(_x106, _x107, _x108, _x109, _x110) {
          return _removeRTCData.apply(this, arguments);
        }

        return removeRTCData;
      }()
    }, {
      key: "setRTCOutData",
      value: function setRTCOutData(roomId, rtcData, type, message) {
        // const data = this._serverDataCodec.encodeSetRTCOutData(rtcData, type, message);
        // let writer = new PublishWriter(QUERY_TOPIC.SET_RTC_OUT_DATA, data, roomId);
        // return this._sendSignalForData(writer);
        throw new Error('JSEngine\'s method not implemented.');
      }
    }, {
      key: "getRTCOutData",
      value: function getRTCOutData(roomId, userIds) {
        // const data = this._serverDataCodec.ecnodeGetRTCOutData(userIds);
        // let writer = new QueryWriter(QUERY_TOPIC.GET_RTC_OUT_DATA, data, roomId);
        // return this._sendSignalForData(writer, PBName.RtcUserOutDataOutput);
        throw new Error('JSEngine\'s method not implemented.');
      }
    }, {
      key: "getRTCToken",
      value: function () {
        var _getRTCToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(roomId, mode, broadcastType) {
          var reqBody, writer;
          return regeneratorRuntime.wrap(function _callee51$(_context51) {
            while (1) {
              switch (_context51.prev = _context51.next) {
                case 0:
                  if (this._channel) {
                    _context51.next = 2;
                    break;
                  }

                  return _context51.abrupt("return", {
                    code: ErrorCode$1.RC_NET_CHANNEL_INVALID
                  });

                case 2:
                  reqBody = this._channel.codec.encodeJoinRTCRoom(mode, broadcastType);
                  writer = new QueryWriter(Topic$1[Topic$1.rtcToken], reqBody, roomId);
                  return _context51.abrupt("return", this._channel.send(writer, PBName.RtcTokenOutput));

                case 5:
                case "end":
                  return _context51.stop();
              }
            }
          }, _callee51, this);
        }));

        function getRTCToken(_x111, _x112, _x113) {
          return _getRTCToken.apply(this, arguments);
        }

        return getRTCToken;
      }()
    }, {
      key: "setRTCState",
      value: function () {
        var _setRTCState = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52(roomId, report) {
          var reqBody, writer, _yield$this$_channel$22, code;

          return regeneratorRuntime.wrap(function _callee52$(_context52) {
            while (1) {
              switch (_context52.prev = _context52.next) {
                case 0:
                  if (this._channel) {
                    _context52.next = 2;
                    break;
                  }

                  return _context52.abrupt("return", ErrorCode$1.RC_NET_CHANNEL_INVALID);

                case 2:
                  reqBody = this._channel.codec.encodeSetRTCState(report);
                  writer = new QueryWriter(Topic$1[Topic$1.rtcUserState], reqBody, roomId);
                  _context52.next = 6;
                  return this._channel.send(writer);

                case 6:
                  _yield$this$_channel$22 = _context52.sent;
                  code = _yield$this$_channel$22.code;
                  return _context52.abrupt("return", code);

                case 9:
                case "end":
                  return _context52.stop();
              }
            }
          }, _callee52, this);
        }));

        function setRTCState(_x114, _x115) {
          return _setRTCState.apply(this, arguments);
        }

        return setRTCState;
      }()
    }, {
      key: "getRTCUserInfo",
      value: function () {
        var _getRTCUserInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(roomId) {
          return regeneratorRuntime.wrap(function _callee53$(_context53) {
            while (1) {
              switch (_context53.prev = _context53.next) {
                case 0:
                  throw new Error('Method not implemented.');

                case 1:
                case "end":
                  return _context53.stop();
              }
            }
          }, _callee53);
        }));

        function getRTCUserInfo(_x116) {
          return _getRTCUserInfo.apply(this, arguments);
        }

        return getRTCUserInfo;
      }()
    }, {
      key: "getRTCUserList",
      value: function getRTCUserList(roomId) {
        if (!this._channel) {
          return Promise.resolve({
            code: ErrorCode$1.RC_NET_CHANNEL_INVALID
          });
        }

        var data = this._channel.codec.encodeGetRTCRoomInfo();

        var writer = new QueryWriter(Topic$1[Topic$1.rtcUList], data, roomId);
        return this._channel.send(writer, PBName.RtcUserListOutput);
      }
      /* ================ 非标准接口调用实现 ================== */

      /**
       * 调用非标准方法。所谓非标准方法，是为某些特定需求或产品添加，暂未作为标准接口添加至 API 层。
       * 对于未实现的方法，接口响应 Unsupport 错误码
       * @param method 方法名
       * @param args
       */

    }, {
      key: "callExtra",
      value: function callExtra(method) {
        return Promise.resolve({
          code: ErrorCode$1.EXTRA_METHOD_UNDEFINED
        });
      }
      /* ================ 以下为 CPP 特有接口，JSEngine 无需实现 ================== */

    }, {
      key: "clearConversations",
      value: function clearConversations() {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "setUserStatusListener",
      value: function setUserStatusListener(config, listener) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "setUserStatus",
      value: function setUserStatus(status) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "subscribeUserStatus",
      value: function subscribeUserStatus(userIds) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getUserStatus",
      value: function getUserStatus(userId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "addToBlacklist",
      value: function addToBlacklist(userId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "removeFromBlacklist",
      value: function removeFromBlacklist(userId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getBlacklist",
      value: function getBlacklist() {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getBlacklistStatus",
      value: function getBlacklistStatus(userId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "insertMessage",
      value: function insertMessage(conversationType, targetId, insertOptions) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "deleteMessages",
      value: function deleteMessages(timestamps) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "deleteMessagesByTimestamp",
      value: function deleteMessagesByTimestamp(conversationType, targetId, timestamp, cleanSpace, channelId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "clearMessages",
      value: function clearMessages(conversationType, targetId, channelId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getMessage",
      value: function getMessage(messageId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "setMessageContent",
      value: function setMessageContent(messageId, content, objectName) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "setMessageSearchField",
      value: function setMessageSearchField(messageId, content, searchFiles) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "searchConversationByContent",
      value: function searchConversationByContent(keyword, messageTypes, channelId, conversationTypes) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "searchMessageByContent",
      value: function searchMessageByContent(conversationType, targetId, keyword, timestamp, count, total) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getUnreadMentionedMessages",
      value: function getUnreadMentionedMessages(conversationType, targetId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "setMessageSentStatus",
      value: function setMessageSentStatus(messageId, sentStatus) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "setMessageReceivedStatus",
      value: function setMessageReceivedStatus(messageId, receivedStatus) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "clearUnreadCountByTimestamp",
      value: function clearUnreadCountByTimestamp(conversationType, targetId, timestamp, channelId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getConversationNotificationStatus",
      value: function getConversationNotificationStatus(conversationType, targetId, channelId) {
        throw new Error('Method not implemented.');
      }
    }, {
      key: "getRemoteHistoryMessages",
      value: function getRemoteHistoryMessages(conversationType, targetId, timestamp, count, order, channelId) {
        throw new Error('Method not implemented.');
      }
    }]);

    return JSEngine;
  }(AEngine);

  /**
   * 音视频模式
   */
  exports.RTCMode = void 0;

  (function (RTCMode) {
    /**
     * 普通音视频模式
     */
    RTCMode[RTCMode["RTC"] = 0] = "RTC";
    /**
     * 直播模式
     */

    RTCMode[RTCMode["LIVE"] = 2] = "LIVE";
  })(exports.RTCMode || (exports.RTCMode = {}));
  /**
   * 直播类型
   */


  exports.LiveType = void 0;

  (function (LiveType) {
    /**
     * 音视频直播
     */
    LiveType[LiveType["AUDIO_AND_VIDEO"] = 0] = "AUDIO_AND_VIDEO";
    /**
     * 音频直播
     */

    LiveType[LiveType["AUDIO"] = 1] = "AUDIO";
  })(exports.LiveType || (exports.LiveType = {}));

  exports.LiveRole = void 0;

  (function (LiveRole) {
    /**
     * 主播身份
     */
    LiveRole[LiveRole["ANCHOR"] = 1] = "ANCHOR";
    /**
     * 观众身份
     */

    LiveRole[LiveRole["AUDIENCE"] = 2] = "AUDIENCE";
  })(exports.LiveRole || (exports.LiveRole = {}));
  /**
   * CallLib 流程消息
   */


  var CallLibMsgType = {
    'RC:VCAccept': 'RC:VCAccept',
    'RC:VCRinging': 'RC:VCRinging',
    'RC:VCSummary': 'RC:VCSummary',
    'RC:VCHangup': 'RC:VCHangup',
    'RC:VCInvite': 'RC:VCInvite',
    'RC:VCModifyMedia': 'RC:VCModifyMedia',
    'RC:VCModifyMem': 'RC:VCModifyMem'
  };
  exports.RTCApiType = void 0;

  (function (RTCApiType) {
    RTCApiType[RTCApiType["ROOM"] = 1] = "ROOM";
    RTCApiType[RTCApiType["PERSON"] = 2] = "PERSON";
  })(exports.RTCApiType || (exports.RTCApiType = {}));

  var PluginContext = /*#__PURE__*/function () {
    function PluginContext(_context) {
      _classCallCheck(this, PluginContext);

      this._context = _context;
    }
    /**
     * 获取 `@rongcloud/engine` 包版本
     */


    _createClass(PluginContext, [{
      key: "getCoreVersion",
      value: function getCoreVersion() {
        return this._context.coreVersion;
      }
      /**
       * 获取当前运行中的 IMLib 版本号
       */

    }, {
      key: "getAPIVersion",
      value: function getAPIVersion() {
        return this._context.apiVersion;
      }
      /**
       * 获取当前应用的 appkey
       */

    }, {
      key: "getAppkey",
      value: function getAppkey() {
        return this._context.appkey;
      }
      /**
       * 获取当前已连接用户的 userId
       * 用户连接建立之前及 disconnect 之后，该方法返回 '' 值
       */

    }, {
      key: "getCurrentId",
      value: function getCurrentId() {
        return this._context.getCurrentUserId();
      }
      /**
       * 获取当前连接状态
       */

    }, {
      key: "getConnectionStatus",
      value: function getConnectionStatus() {
        return this._context.getConnectionStatus();
      }
      /**
       * 发送消息
       */

    }, {
      key: "sendMessage",
      value: function sendMessage(conversationType, targetId, options) {
        return this._context.sendMessage(conversationType, targetId, options);
      }
      /**
       * 消息注册
       * @description 消息注册需在应用初始化完成前进行
       * @param objectName 消息类型，如：RC:TxtMsg
       * @param isPersited 是否存储
       * @param isCounted 是否技术
       * @param searchProps 搜索字段，只在搭配协议栈使用时有效
       */

    }, {
      key: "registerMessageType",
      value: function registerMessageType(objectName, isPersited, isCounted) {
        var searchProps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

        this._context.registerMessageType(objectName, isPersited, isCounted, searchProps);
      }
    }]);

    return PluginContext;
  }();

  var RTCPluginContext = /*#__PURE__*/function (_PluginContext) {
    _inherits(RTCPluginContext, _PluginContext);

    var _super = _createSuper(RTCPluginContext);

    function RTCPluginContext() {
      _classCallCheck(this, RTCPluginContext);

      return _super.apply(this, arguments);
    }

    _createClass(RTCPluginContext, [{
      key: "getNaviInfo",
      value:
      /**
       * 获取当前的导航数据
       */
      function getNaviInfo() {
        return this._context.getInfoFromCache();
      }
      /**
       * 加入 RTC 房间
       * @todo 需确认 `broadcastType` 参数的作用与有效值
       * @param roomId
       * @param mode 房间模式：直播 or 会议
       * @param broadcastType
       */

    }, {
      key: "joinRTCRoom",
      value: function joinRTCRoom(roomId, mode, broadcastType) {
        return this._context.joinRTCRoom(roomId, mode, broadcastType);
      }
    }, {
      key: "quitRTCRoom",
      value: function quitRTCRoom(roomId) {
        return this._context.quitRTCRoom(roomId);
      }
    }, {
      key: "rtcPing",
      value: function rtcPing(roomId, mode, broadcastType) {
        return this._context.rtcPing(roomId, mode, broadcastType);
      }
    }, {
      key: "getRTCRoomInfo",
      value: function getRTCRoomInfo(roomId) {
        return this._context.getRTCRoomInfo(roomId);
      }
    }, {
      key: "getRTCUserInfoList",
      value: function getRTCUserInfoList(roomId) {
        return this._context.getRTCUserInfoList(roomId);
      }
    }, {
      key: "getRTCUserInfo",
      value: function getRTCUserInfo(roomId) {
        return this._context.getRTCUserInfo(roomId);
      }
    }, {
      key: "setRTCUserInfo",
      value: function setRTCUserInfo(roomId, key, value) {
        return this._context.setRTCUserInfo(roomId, key, value);
      }
    }, {
      key: "removeRTCUserInfo",
      value: function removeRTCUserInfo(roomId, keys) {
        return this._context.removeRTCUserInfo(roomId, keys);
      }
    }, {
      key: "setRTCData",
      value: function setRTCData(roomId, key, value, isInner, apiType, message) {
        return this._context.setRTCData(roomId, key, value, isInner, apiType, message);
      }
      /**
       * @param - roomId
       * @param - message 向前兼容的消息数据，以兼容旧版本 SDK，即增量数据，如：
       * ```
       * JSON.stringify({
       *  name: 'RCRTC:PublishResource',
       *  content: {
       *  }
       * })
       * ```
       * @param - valueInfo 全量资源数据
       * @param - 全量 URI 消息名，即 `RCRTC:TotalContentResources`
       */

    }, {
      key: "setRTCTotalRes",
      value: function setRTCTotalRes(roomId,
      /**
       * 向旧版本 RTCLib 兼容的消息数据
       */
      message, valueInfo, objectName) {
        return this._context.setRTCTotalRes(roomId, message, valueInfo, objectName);
      }
    }, {
      key: "getRTCData",
      value: function getRTCData(roomId, keys, isInner, apiType) {
        return this._context.getRTCData(roomId, keys, isInner, apiType);
      }
    }, {
      key: "removeRTCData",
      value: function removeRTCData(roomId, keys, isInner, apiType, message) {
        return this._context.removeRTCData(roomId, keys, isInner, apiType, message);
      }
    }, {
      key: "setRTCOutData",
      value: function setRTCOutData(roomId, rtcData, type, message) {
        return this._context.setRTCOutData(roomId, rtcData, type, message);
      }
    }, {
      key: "getRTCOutData",
      value: function getRTCOutData(roomId, userIds) {
        return this._context.getRTCOutData(roomId, userIds);
      }
    }, {
      key: "getRTCToken",
      value: function getRTCToken(roomId, mode, broadcastType) {
        return this._context.getRTCToken(roomId, mode, broadcastType);
      }
    }, {
      key: "setRTCState",
      value: function setRTCState(roomId, report) {
        return this._context.setRTCState(roomId, report);
      }
    }, {
      key: "getRTCUserList",
      value: function getRTCUserList(roomId) {
        return this._context.getRTCUserList(roomId);
      }
    }]);

    return RTCPluginContext;
  }(PluginContext);

  function cloneMessage(message) {
    return Object.assign({}, message);
  }

  var APIContext = /*#__PURE__*/function () {
    function APIContext(_runtime, options) {
      _classCallCheck(this, APIContext);

      this._runtime = _runtime;
      this._token = '';
      /**
       * 插件队列，用于逐一派发消息与信令
       */

      this._pluginContextQueue = [];
      /**
       * 核心库版本号，后期与 4.0 IM SDK 版本号保持一致
       */

      this.coreVersion = "4.3.0-alpha.8";
      this._connectionStatus = ConnectionStatus$1.DISCONNECTED;
      /**
       * 业务层事件监听器挂载点
       */

      this._watcher = {
        message: undefined,
        conversationState: undefined,
        chatroomState: undefined,
        connectionState: undefined,
        rtcInnerWatcher: undefined,
        expansion: undefined,
        tag: undefined,
        conversationTagChanged: undefined
      };
      this._options = Object.assign({}, options);
      this.appkey = this._options.appkey;
      this.apiVersion = this._options.apiVersion; // 过滤无效地址

      this._options.navigators = this._options.navigators.filter(function (item) {
        return /^https?:\/\//.test(item);
      }); // 有自定义导航的状态下，不再使用内置导航地址

      if (this._options.navigators.length === 0) {
        var _this$_options$naviga;

        (_this$_options$naviga = this._options.navigators).push.apply(_this$_options$naviga, _toConsumableArray(PUBLIC_CLOUD_NAVI_URIS));
      } // 初始化引擎监听器，监听连接状态变化、消息变化以及聊天室状态变化


      var engineWatcher = {
        status: this._connectionStatusListener.bind(this),
        message: this._messageReceiver.bind(this),
        chatroom: this._chatroomInfoListener.bind(this),
        conversation: this._conversationInfoListener.bind(this),
        expansion: this._expansionInfoListener.bind(this),
        tag: this._tagListener.bind(this),
        conversationTag: this._conversationTagListener.bind(this)
      }; // 初始化引擎

      this._engine = usingCppEngine() ? new RCCppEngine(_runtime, engineWatcher, this._options) : new JSEngine(_runtime, engineWatcher, this._options);
    }

    _createClass(APIContext, [{
      key: "install",
      value:
      /**
       * 安装使用插件，并初始化插件实例
       * @param plugin
       * @param options
       */
      function install(plugin, options) {
        var context = plugin.tag === 'RCRTC' ? new RTCPluginContext(this) : new PluginContext(this);
        var pluginClient = null;

        try {
          if (!plugin.verify(this._runtime)) {
            return null;
          }

          pluginClient = plugin.setup(context, this._runtime, options);
        } catch (error) {
          logger.error('install plugin error!\n', error);
        }

        pluginClient && this._pluginContextQueue.push(context);
        return pluginClient;
      }
      /**
       * 连接状态变更回调
       * @param message
       */

    }, {
      key: "_connectionStatusListener",
      value: function _connectionStatusListener(status) {
        var _this$_watcher$rtcInn;

        this._connectionStatus = status; // 通知旧版本 RTCLib、CallLib

        ((_this$_watcher$rtcInn = this._watcher.rtcInnerWatcher) === null || _this$_watcher$rtcInn === void 0 ? void 0 : _this$_watcher$rtcInn.status) && this._watcher.rtcInnerWatcher.status(status); // 通知插件连接状态变更

        this._pluginContextQueue.forEach(function (item) {
          item.onconnectionstatechange && item.onconnectionstatechange(status);
        }); // 通知应用层连接状态变更


        this._watcher.connectionState && this._watcher.connectionState(status);
      }
    }, {
      key: "_messageReceiver",
      value: function _messageReceiver(message) {
        /**
         * 为兼容非插件化的 RTCLib、CallLib，需预先将
         * conversationType === 12
         * 或
         * RCRTC:AcceptMsg... 等消息分别分发给 RTCLib\CallLib
         */
        if (message.conversationType === ConversationType$1.RTC_ROOM || Object.prototype.hasOwnProperty.call(CallLibMsgType, message.messageType)) {
          /**
           * 分发 RTCLib 或 CallLib 消息，如果未找到 RTCLib 或 CallLib 注册的消息监听，
           * 说明未使用旧版本 RTCLib 或 CallLib，消息要分发到插件钩子
           */
          if (this._watcher.rtcInnerWatcher && this._watcher.rtcInnerWatcher.message) {
            this._watcher.rtcInnerWatcher.message(cloneMessage(message));

            return;
          }
        } // 消息分发至插件，并根据插件响应结果确定是否继续向业务层派发


        if (this._pluginContextQueue.some(function (item) {
          // 插件不接收消息
          if (!item.onmessage) {
            return false;
          }

          try {
            return item.onmessage(cloneMessage(message));
          } catch (err) {
            logger.error('plugin error =>', err);
            return false;
          }
        })) {
          return;
        } // 最终未被过滤的消息派发给应用层


        this._watcher.message && this._watcher.message(cloneMessage(message));
      }
      /**
       * 聊天室相关信息监听
      */

    }, {
      key: "_chatroomInfoListener",
      value: function _chatroomInfoListener(info) {
        this._watcher.chatroomState && this._watcher.chatroomState(info);
      }
      /**
       * 会话监听相关
      */

    }, {
      key: "_conversationInfoListener",
      value: function _conversationInfoListener(info) {
        this._watcher.conversationState && this._watcher.conversationState(info);
      }
      /**
       * 消息扩展监听相关
      */

    }, {
      key: "_expansionInfoListener",
      value: function _expansionInfoListener(info) {
        this._watcher.expansion && this._watcher.expansion(info);
      }
      /**
       * 标签增删改监听
       */

    }, {
      key: "_tagListener",
      value: function _tagListener() {
        this._watcher.tag && this._watcher.tag();
      }
      /**
       * 会话标签状态监听
       */

    }, {
      key: "_conversationTagListener",
      value: function _conversationTagListener() {
        this._watcher.conversationTagChanged && this._watcher.conversationTagChanged();
      }
      /**
       * 添加事件监听
       * @param options
       */

    }, {
      key: "assignWatcher",
      value: function assignWatcher(watcher) {
        var _this = this;

        // 只取有效的四个 key，避免引用透传造成内存泄露
        Object.keys(this._watcher).forEach(function (key) {
          if (Object.prototype.hasOwnProperty.call(watcher, key)) {
            var value = watcher[key];
            _this._watcher[key] = isFunction(value) || isObject$1(value) ? value : undefined;
          }
        });
      }
    }, {
      key: "getConnectedTime",
      value: function getConnectedTime() {
        return this._engine.getConnectedTime();
      }
    }, {
      key: "getCurrentUserId",
      value: function getCurrentUserId() {
        return this._engine.currentUserId;
      }
    }, {
      key: "getConnectionStatus",
      value: function getConnectionStatus() {
        return this._connectionStatus;
      }
      /**
       * 建立连接，连接失败则抛出异常，连接成功后返回用户 userId，否则返回相应的错误码
       * @param token
       * @param refreshNavi 是否需要重新请求导航，当值为 `false` 时，优先使用有效缓存导航，若缓存失效则重新获取导航
       */

    }, {
      key: "connect",
      value: function () {
        var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token) {
          var refreshNavi,
              _token$split,
              _token$split2,
              tmpArr,
              dynamicUris,
              naviInfo,
              code,
              _args = arguments;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  refreshNavi = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;

                  if (!(this._connectionStatus === ConnectionStatus$1.CONNECTED)) {
                    _context.next = 3;
                    break;
                  }

                  return _context.abrupt("return", {
                    code: ErrorCode$1.SUCCESS,
                    userId: this._engine.currentUserId
                  });

                case 3:
                  if (!(this._connectionStatus === ConnectionStatus$1.CONNECTING)) {
                    _context.next = 5;
                    break;
                  }

                  return _context.abrupt("return", {
                    code: ErrorCode$1.BIZ_ERROR_CONNECTING
                  });

                case 5:
                  if (!(typeof token !== 'string' || token.length === 0)) {
                    _context.next = 7;
                    break;
                  }

                  return _context.abrupt("return", {
                    code: ErrorCode$1.RC_CONN_USER_OR_PASSWD_ERROR
                  });

                case 7:
                  this._token = token; // 根据 token 解析动态导航，优先从动态导航获取数据

                  _token$split = token.split('@'), _token$split2 = _slicedToArray(_token$split, 2), tmpArr = _token$split2[1];
                  dynamicUris = tmpArr ? tmpArr.split(';').map(function (item) {
                    return /^https?:/.test(item) ? item : "https://".concat(item);
                  }) : []; // 获取导航数据

                  _context.next = 12;
                  return this._engine.navi.getInfo(this._getTokenWithoutNavi(), dynamicUris, refreshNavi);

                case 12:
                  naviInfo = _context.sent;

                  if (!(!naviInfo && !usingCppEngine())) {
                    _context.next = 15;
                    break;
                  }

                  return _context.abrupt("return", {
                    code: ErrorCode$1.RC_NAVI_RESOURCE_ERROR
                  });

                case 15:
                  _context.next = 17;
                  return this._engine.connect(this._getTokenWithoutNavi(), naviInfo);

                case 17:
                  code = _context.sent;

                  if (code === ErrorCode$1.SUCCESS && !usingCppEngine()) {
                    // TODO 限制 !isCppMode 防止报错，临时解决方案
                    // 拉取用户级配置
                    naviInfo.openUS === 1 && this._pullUserSettings();
                  }

                  return _context.abrupt("return", {
                    code: code,
                    userId: this._engine.currentUserId
                  });

                case 20:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function connect(_x) {
          return _connect.apply(this, arguments);
        }

        return connect;
      }()
      /**
       * 拉取实时配置 web 端需更新 voipCall 字段
       */

    }, {
      key: "_pullUserSettings",
      value: function () {
        var _pullUserSettings2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // const res = await this._engine.pullUserSettings(version)
                  // logger.error('TODO：存储配置，需要使用时获取', res)

                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function _pullUserSettings() {
          return _pullUserSettings2.apply(this, arguments);
        }

        return _pullUserSettings;
      }()
    }, {
      key: "disconnect",
      value: function disconnect() {
        this._engine.disconnect();

        this._pluginContextQueue.forEach(function (item) {
          if (!item.ondisconnect) {
            return;
          }

          try {
            item.ondisconnect();
          } catch (err) {
            logger.error('plugin error =>', err);
          }
        }); // 为照顾 API 层的 Promise 链式调用，故增加返回 Promise


        return Promise.resolve();
      }
    }, {
      key: "reconnect",
      value: function reconnect() {
        return this.connect(this._getTokenWithoutNavi());
      } // 获取 token 动态导航前的部分

    }, {
      key: "_getTokenWithoutNavi",
      value: function _getTokenWithoutNavi() {
        return this._token.replace(/@.+$/, '@');
      }
      /**
       * 获取当前缓存的导航数据
       */

    }, {
      key: "getInfoFromCache",
      value: function getInfoFromCache() {
        return this._engine.navi.getInfoFromCache(this._getTokenWithoutNavi());
      }
      /**
       * 消息注册
       * @description 消息注册需在应用初始化完成前进行
       * @param objectName 消息类型，如：RC:TxtMsg
       * @param isPersited 是否存储
       * @param isCounted 是否技术
       * @param searchProps 搜索字段，只在搭配协议栈使用时有效
       */

    }, {
      key: "registerMessageType",
      value: function registerMessageType(objectName, isPersited, isCounted) {
        var searchProps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

        this._engine.registerMessageType(objectName, isPersited, isCounted, searchProps);
      }
      /**
       * 发送消息
       * @param conversationType
       * @param targetId
       * @param objectName
       * @param content
       * @param options
       */

    }, {
      key: "sendMessage",
      value: function sendMessage(conversationType, targetId, options, onBefore) {
        // 端上不能发送系统消息，若会话类型传入 6 ，抛出参数错误，与移动端一致
        if (conversationType === ConversationType$1.SYSTEM) {
          return Promise.resolve({
            code: ErrorCode$1.BIZ_ERROR_INVALID_PARAMETER
          });
        } // 消息 content 需小于 128 KB


        var contentJson = JSON.stringify(options.content);

        if (getByteLength(contentJson) > MAX_MESSAGE_CONTENT_BYTES) {
          return Promise.resolve({
            code: ErrorCode$1.RC_MSG_CONTENT_EXCEED_LIMIT
          });
        }

        return this._engine.sendMessage(conversationType, targetId, options, onBefore);
      }
      /**
       * 发送扩展消息
       * @param messageUId 消息 Id
       * @param keys 需要删除的 key
       * @param expansion 设置的扩展
      */

    }, {
      key: "sendExpansionMessage",
      value: function () {
        var _sendExpansionMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(options) {
          var conversationType, targetId, messageUId, keys, expansion, originExpansion, removeAll, canIncludeExpansion, isExceedLimit, isIllgalEx, exKeysLength, totalExpansion, totalExKeysLength, key, val, content, _yield$this$_engine$s, code;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  conversationType = options.conversationType, targetId = options.targetId, messageUId = options.messageUId, keys = options.keys, expansion = options.expansion, originExpansion = options.originExpansion, removeAll = options.removeAll, canIncludeExpansion = options.canIncludeExpansion; // 校验消息是否支持扩展

                  if (canIncludeExpansion) {
                    _context3.next = 3;
                    break;
                  }

                  return _context3.abrupt("return", {
                    code: ErrorCode$1.MESSAGE_KV_NOT_SUPPORT
                  });

                case 3:
                  isExceedLimit = false;
                  isIllgalEx = false;

                  if (isObject$1(expansion)) {
                    // 验证扩展总数是否 大于 300
                    originExpansion = originExpansion || {};
                    exKeysLength = Object.keys(expansion).length;
                    totalExpansion = Object.assign(originExpansion, expansion);
                    totalExKeysLength = Object.keys(totalExpansion).length;
                    isExceedLimit = totalExKeysLength > 300 || exKeysLength > 20; // 验证 expansion key value 是否合法

                    for (key in expansion) {
                      val = expansion[key];
                      isExceedLimit = key.length > 32 || val.length > 64;
                      isIllgalEx = !/^[A-Za-z0-9_=+-]+$/.test(key);
                    }
                  }

                  if (!isExceedLimit) {
                    _context3.next = 8;
                    break;
                  }

                  return _context3.abrupt("return", {
                    code: ErrorCode$1.EXPANSION_LIMIT_EXCEET
                  });

                case 8:
                  if (!isIllgalEx) {
                    _context3.next = 10;
                    break;
                  }

                  return _context3.abrupt("return", {
                    code: ErrorCode$1.BIZ_ERROR_INVALID_PARAMETER
                  });

                case 10:
                  content = {
                    mid: messageUId
                  };
                  expansion && (content.put = expansion);
                  keys && (content.del = keys);
                  removeAll && (content.removeAll = 1); // RC:MsgExMsg 类型消息需使用单群聊消息信令：ppMsgP、pgMsgP（ Server 端处理不存到历史消息云存储）

                  _context3.next = 16;
                  return this._engine.sendMessage(conversationType, targetId, {
                    content: content,
                    messageType: MessageType$1.EXPANSION_NOTIFY
                  });

                case 16:
                  _yield$this$_engine$s = _context3.sent;
                  code = _yield$this$_engine$s.code;
                  return _context3.abrupt("return", {
                    code: code
                  });

                case 19:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function sendExpansionMessage(_x2) {
          return _sendExpansionMessage.apply(this, arguments);
        }

        return sendExpansionMessage;
      }()
      /**
       * 反初始化，清空所有监听及计时器
       */

    }, {
      key: "_destroy",
      value: function _destroy() {
        this._watcher = {};

        this._engine.disconnect();

        this._pluginContextQueue.forEach(function (item) {
          if (!item.ondestroy) {
            return;
          }

          try {
            item.ondestroy();
          } catch (err) {
            logger.error('plugin error =>', err);
          }
        });

        this._pluginContextQueue.length = 0;
      }
      /**
       * @param conversationType
       * @param targetId 会话 Id
       * @param timestamp 拉取时间戳
       * @param count 拉取条数
       * @param order 1 正序拉取，0 为倒序拉取
       * @param channelId
       * @param objectName
       */

    }, {
      key: "getHistoryMessage",
      value: function getHistoryMessage(conversationType, targetId) {
        var timestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;
        var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var channelId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
        var objectName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '';
        return this._engine.getHistoryMessage(conversationType, targetId, timestamp, count, order, channelId, objectName || '');
      }
      /**
       * 获取会话列表
       * @param count 指定获取数量, 不传则获取全部会话列表，默认 `300`
       */

    }, {
      key: "getConversationList",
      value: function getConversationList() {
        var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 300;
        var conversationType = arguments.length > 1 ? arguments[1] : undefined;
        var startTime = arguments.length > 2 ? arguments[2] : undefined;
        var order = arguments.length > 3 ? arguments[3] : undefined;
        var channelId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
        return this._engine.getConversationList(count, conversationType, startTime, order, channelId);
      }
      /**
       * 删除会话
       */

    }, {
      key: "removeConversation",
      value: function removeConversation(conversationType, targetId) {
        var channelId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
        return this._engine.removeConversation(conversationType, targetId, channelId);
      }
      /**
       * 清除会话消息未读数
       */

    }, {
      key: "clearUnreadCount",
      value: function clearUnreadCount(conversationType, targetId) {
        var channelId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
        return this._engine.clearConversationUnreadCount(conversationType, targetId, channelId);
      }
      /**
       * 获取指定会话消息未读数
       */

    }, {
      key: "getUnreadCount",
      value: function getUnreadCount(conversationType, targetId) {
        var channelId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
        return this._engine.getConversationUnreadCount(conversationType, targetId, channelId);
      }
      /**
       * 获取所有会话未读数
       * @param channelId 多组织 Id
       * @param conversationTypes
       * @param includeMuted 包含已设置免打扰的会话
       */

    }, {
      key: "getTotalUnreadCount",
      value: function getTotalUnreadCount(channelId, conversationTypes, includeMuted) {
        return this._engine.getAllConversationUnreadCount(channelId, conversationTypes && conversationTypes.length > 0 ? conversationTypes : [ConversationType$1.PRIVATE, ConversationType$1.GROUP, ConversationType$1.SYSTEM, ConversationType$1.PUBLIC_SERVICE], !!includeMuted);
      }
    }, {
      key: "setConversationStatus",
      value: function setConversationStatus(conversationType, targetId, isTop, notificationStatus) {
        var channelId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
        var statusList = [{
          conversationType: conversationType,
          targetId: targetId,
          isTop: isTop,
          notificationStatus: notificationStatus,
          channelId: channelId
        }];
        return this._engine.batchSetConversationStatus(statusList);
      }
    }, {
      key: "saveConversationMessageDraft",
      value: function saveConversationMessageDraft(conversationType, targetId, draft) {
        return this._engine.saveConversationMessageDraft(conversationType, targetId, draft);
      }
    }, {
      key: "getConversationMessageDraft",
      value: function getConversationMessageDraft(conversationType, targetId) {
        return this._engine.getConversationMessageDraft(conversationType, targetId);
      }
    }, {
      key: "clearConversationMessageDraft",
      value: function clearConversationMessageDraft(conversationType, targetId) {
        return this._engine.clearConversationMessageDraft(conversationType, targetId);
      }
    }, {
      key: "recallMessage",
      value: function recallMessage(conversationType, targetId, messageUId, sentTime, recallMsgOptions) {
        return this._engine.recallMsg(conversationType, targetId, messageUId, sentTime, recallMsgOptions);
      }
      /**
       * 删除远端消息
       * @param conversationType
       * @param targetId
       * @param list
       */

    }, {
      key: "deleteRemoteMessage",
      value: function deleteRemoteMessage(conversationType, targetId, list) {
        var channelId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
        return this._engine.deleteRemoteMessage(conversationType, targetId, list, channelId);
      }
      /**
       * 根据时间戳删除指定时间之前的
       * @param conversationType
       * @param targetId
       * @param timestamp
       */

    }, {
      key: "deleteRemoteMessageByTimestamp",
      value: function deleteRemoteMessageByTimestamp(conversationType, targetId, timestamp) {
        var channelId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
        return this._engine.deleteRemoteMessageByTimestamp(conversationType, targetId, timestamp, channelId);
      }
      /**
       * 加入聊天室，若聊天室不存在则创建聊天室
       * @param roomId 聊天室房间 Id
       * @param count 进入聊天室成功后，自动拉取的历史消息数量，默认值为 `10`，最大有效值为 `50`，`-1` 为不拉取
       */

    }, {
      key: "joinChatroom",
      value: function joinChatroom(roomId) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
        return this._engine.joinChatroom(roomId, count);
      }
      /**
       * 加入聊天室，若聊天室不存在则抛出异常
       * @param roomId 聊天室房间 Id
       * @param count 进入聊天室成功后，自动拉取的历史消息数量，默认值为 `10`，最大有效值为 `50`，`-1` 为不拉取
       */

    }, {
      key: "joinExistChatroom",
      value: function joinExistChatroom(roomId) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
        return this._engine.joinExistChatroom(roomId, count);
      }
      /**
       * 退出聊天室
       * @param roomId
       */

    }, {
      key: "quitChatroom",
      value: function quitChatroom(roomId) {
        return this._engine.quitChatroom(roomId);
      }
      /**
       * 获取聊天室房间数据
       * @description count 或 order 有一个为 0 时，只返回成员总数，不返回成员列表信息
       * @param roomId 聊天室 Id
       * @param count 获取房间人员列表数量，最大有效值 `20`，最小值未 `0`，默认为 0
       * @param order 人员排序方式，`1` 为正序，`2` 为倒序，默认为 0
       */

    }, {
      key: "getChatroomInfo",
      value: function getChatroomInfo(roomId) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this._engine.getChatroomInfo(roomId, count, order);
      }
      /**
       * 在指定聊天室中设置自定义属性
       * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
       * @param roomId 聊天室房间 id
       * @param entry 属性信息
       */

    }, {
      key: "setChatroomEntry",
      value: function setChatroomEntry(roomId, entry) {
        var key = entry.key,
            value = entry.value;

        if (!isValidChrmEntryKey(key) || !isValidChrmEntryValue(value)) {
          return Promise.resolve(ErrorCode$1.BIZ_ERROR_INVALID_PARAMETER);
        }

        return this._engine.setChatroomEntry(roomId, entry);
      }
      /**
       * 在指定聊天室中强制增加 / 修改任意聊天室属性
       * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
       * @param roomId 聊天室房间 id
       * @param entry 属性信息
       */

    }, {
      key: "forceSetChatroomEntry",
      value: function forceSetChatroomEntry(roomId, entry) {
        var key = entry.key,
            value = entry.value;

        if (!isValidChrmEntryKey(key) || !isValidChrmEntryValue(value)) {
          return Promise.resolve(ErrorCode$1.BIZ_ERROR_INVALID_PARAMETER);
        }

        return this._engine.forceSetChatroomEntry(roomId, entry);
      }
      /**
       * 删除聊天室属性
       * @description 该方法仅限于删除自己设置的聊天室属性
       * @param roomId 聊天室房间 id
       * @param entry 要移除的属性信息
       */

    }, {
      key: "removeChatroomEntry",
      value: function removeChatroomEntry(roomId, entry) {
        var key = entry.key;

        if (!isValidChrmEntryKey(key)) {
          return Promise.resolve(ErrorCode$1.BIZ_ERROR_INVALID_PARAMETER);
        }

        return this._engine.removeChatroomEntry(roomId, entry);
      }
      /**
       * 强制删除任意聊天室属性
       * @description 该方法仅限于删除自己设置的聊天室属性
       * @param roomId 聊天室房间 id
       * @param entry 要移除的属性信息
       */

    }, {
      key: "forceRemoveChatroomEntry",
      value: function forceRemoveChatroomEntry(roomId, entry) {
        var key = entry.key;

        if (!isValidChrmEntryKey(key)) {
          return Promise.resolve(ErrorCode$1.BIZ_ERROR_INVALID_PARAMETER);
        }

        return this._engine.forceRemoveChatroomEntry(roomId, entry);
      }
      /**
       * 获取聊天室中的指定属性
       * @param roomId 聊天室房间 id
       * @param key 属性键名
       */

    }, {
      key: "getChatroomEntry",
      value: function getChatroomEntry(roomId, key) {
        return this._engine.getChatroomEntry(roomId, key);
      }
      /**
       * 获取聊天室内的所有属性
       * @param roomId 聊天室房间 id
       */

    }, {
      key: "getAllChatroomEntries",
      value: function getAllChatroomEntries(roomId) {
        return this._engine.getAllChatroomEntry(roomId);
      }
      /**
       * 拉取聊天室内的历史消息
       * @param roomId
       * @param count 拉取消息条数, 有效值范围 `1 - 20`
       * @param order 获取顺序，默认值为 0。
       * * 0：降序，用于获取早于指定时间戳发送的消息
       * * 1：升序，用于获取晚于指定时间戳发送的消息
       * @param timestamp 指定拉取消息用到的时间戳。默认值为 `0`，表示按当前时间拉取
       */

    }, {
      key: "getChatRoomHistoryMessages",
      value: function getChatRoomHistoryMessages(roomId) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
        var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var timestamp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return this._engine.getChatroomHistoryMessages(roomId, timestamp, count, order);
      }
      /**
       * 获取 七牛、百度上传认证信息
       * @param fileType 文件类型
       * @param fileName 文件名
      */

    }, {
      key: "getFileToken",
      value: function () {
        var _getFileToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(fileType, fileName) {
          var naviInfo, bos, qiniu, ossConfig, _yield$this$_engine$g, code, data;

          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  naviInfo = this.getInfoFromCache();
                  bos = (naviInfo === null || naviInfo === void 0 ? void 0 : naviInfo.bosAddr) || '';
                  qiniu = (naviInfo === null || naviInfo === void 0 ? void 0 : naviInfo.uploadServer) || '';
                  ossConfig = (naviInfo === null || naviInfo === void 0 ? void 0 : naviInfo.ossConfig) || '';
                  _context4.next = 6;
                  return this._engine.getFileToken(fileType, fileName);

                case 6:
                  _yield$this$_engine$g = _context4.sent;
                  code = _yield$this$_engine$g.code;
                  data = _yield$this$_engine$g.data;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context4.next = 11;
                    break;
                  }

                  return _context4.abrupt("return", Promise.resolve(Object.assign(data, {
                    bos: bos,
                    qiniu: qiniu,
                    ossConfig: ossConfig
                  })));

                case 11:
                  return _context4.abrupt("return", Promise.reject(code));

                case 12:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function getFileToken(_x3, _x4) {
          return _getFileToken.apply(this, arguments);
        }

        return getFileToken;
      }()
      /**
       * 获取 七牛、百度、阿里云 上传成功可下载的 URL
       * @param fileType 文件类型
       * @param uploadMethod 上传方式
       * @param fileName 文件名
       * @param originName 文件源名
       * @param uploadRes 插件上传返回的结果。降级百度上传后，用户传入返回结果，再把结果里的下载地址返回给用户，保证兼容之前结果获取
      */

    }, {
      key: "getFileUrl",
      value: function () {
        var _getFileUrl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(fileType, fileName, originName, uploadRes) {
          var uploadMethod,
              _yield$this$_engine$g2,
              code,
              data,
              _args5 = arguments;

          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  uploadMethod = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : UploadMethod$1.QINIU;

                  if (!(uploadRes !== null && uploadRes !== void 0 && uploadRes.isBosRes)) {
                    _context5.next = 3;
                    break;
                  }

                  return _context5.abrupt("return", Promise.resolve(uploadRes));

                case 3:
                  _context5.next = 5;
                  return this._engine.getFileUrl(fileType, uploadMethod, fileName, originName);

                case 5:
                  _yield$this$_engine$g2 = _context5.sent;
                  code = _yield$this$_engine$g2.code;
                  data = _yield$this$_engine$g2.data;

                  if (!(code === ErrorCode$1.SUCCESS)) {
                    _context5.next = 10;
                    break;
                  }

                  return _context5.abrupt("return", Promise.resolve(data));

                case 10:
                  return _context5.abrupt("return", Promise.reject(code));

                case 11:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function getFileUrl(_x5, _x6, _x7, _x8) {
          return _getFileUrl.apply(this, arguments);
        }

        return getFileUrl;
      }()
      /**
       * 创建标签
       * @param tag 标签
       */

    }, {
      key: "createTag",
      value: function () {
        var _createTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(tag) {
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  return _context6.abrupt("return", this._engine.createTag(tag));

                case 1:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function createTag(_x9) {
          return _createTag.apply(this, arguments);
        }

        return createTag;
      }()
      /**
       * 删除标签
       * @param tagId 标签id
       */

    }, {
      key: "removeTag",
      value: function () {
        var _removeTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(tagId) {
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  return _context7.abrupt("return", this._engine.removeTag(tagId));

                case 1:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function removeTag(_x10) {
          return _removeTag.apply(this, arguments);
        }

        return removeTag;
      }()
      /**
       * 更新标签
       * @param tag 标签
       */

    }, {
      key: "updateTag",
      value: function () {
        var _updateTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(tag) {
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  return _context8.abrupt("return", this._engine.updateTag(tag));

                case 1:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function updateTag(_x11) {
          return _updateTag.apply(this, arguments);
        }

        return updateTag;
      }()
      /**
       * 获取标签列表
       */

    }, {
      key: "getTagList",
      value: function () {
        var _getTagList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  return _context9.abrupt("return", this._engine.getTagList());

                case 1:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function getTagList() {
          return _getTagList.apply(this, arguments);
        }

        return getTagList;
      }()
      /**
       * 添加会话到标签（给多个会话增加标签）
       * @param tagId 标签id
       * @param conversations 要添加的会话列表
       */

    }, {
      key: "addTagForConversations",
      value: function () {
        var _addTagForConversations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(tagId, conversations) {
          return regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  if (!(conversations.length > 1000)) {
                    _context10.next = 2;
                    break;
                  }

                  return _context10.abrupt("return", Promise.reject(ErrorCode$1.CONVER_OUT_LIMIT_ERROR));

                case 2:
                  return _context10.abrupt("return", this._engine.addTagForConversations(tagId, conversations));

                case 3:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function addTagForConversations(_x12, _x13) {
          return _addTagForConversations.apply(this, arguments);
        }

        return addTagForConversations;
      }()
      /**
       * 删除标签中的会话(从多个会话中批量删除指定标签)
       * @param tagId 标签id
       * @param conversations 要删除的会话列表
       */

    }, {
      key: "removeTagForConversations",
      value: function () {
        var _removeTagForConversations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(tagId, conversations) {
          return regeneratorRuntime.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  return _context11.abrupt("return", this._engine.removeTagForConversations(tagId, conversations));

                case 1:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this);
        }));

        function removeTagForConversations(_x14, _x15) {
          return _removeTagForConversations.apply(this, arguments);
        }

        return removeTagForConversations;
      }()
      /**
       * 删除会话中的标签(从单一会话中批量删除标签)
       * @param conversationType 会话类型
       * @param targetId 会话id
       * @param tagIds 要删除的标签列表
       */

    }, {
      key: "removeTagsForConversation",
      value: function () {
        var _removeTagsForConversation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(conversation, tagIds) {
          return regeneratorRuntime.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  return _context12.abrupt("return", this._engine.removeTagsForConversation(conversation, tagIds));

                case 1:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, this);
        }));

        function removeTagsForConversation(_x16, _x17) {
          return _removeTagsForConversation.apply(this, arguments);
        }

        return removeTagsForConversation;
      }()
      /**
       * 获取标签下的会话列表
       * @param tagId 标签id
       */

    }, {
      key: "getConversationListByTag",
      value: function () {
        var _getConversationListByTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(tagId, startTime, count, channelId) {
          return regeneratorRuntime.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  return _context13.abrupt("return", this._engine.getConversationListByTag(tagId, startTime, count, channelId));

                case 1:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13, this);
        }));

        function getConversationListByTag(_x18, _x19, _x20, _x21) {
          return _getConversationListByTag.apply(this, arguments);
        }

        return getConversationListByTag;
      }()
      /**
       * 获取标签下的未读消息数
       * @param tagId 标签id
       * @param containMuted 是否包含免打扰会话
       */

    }, {
      key: "getUnreadCountByTag",
      value: function () {
        var _getUnreadCountByTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(tagId, containMuted) {
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", this._engine.getUnreadCountByTag(tagId, containMuted));

                case 1:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14, this);
        }));

        function getUnreadCountByTag(_x22, _x23) {
          return _getUnreadCountByTag.apply(this, arguments);
        }

        return getUnreadCountByTag;
      }()
      /**
       * 设置标签中会话置顶
       * @param conversation 会话
       */

    }, {
      key: "setConversationStatusInTag",
      value: function () {
        var _setConversationStatusInTag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(tagId, conversation, status) {
          return regeneratorRuntime.wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  return _context15.abrupt("return", this._engine.setConversationStatusInTag(tagId, conversation, status));

                case 1:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15, this);
        }));

        function setConversationStatusInTag(_x24, _x25, _x26) {
          return _setConversationStatusInTag.apply(this, arguments);
        }

        return setConversationStatusInTag;
      }()
      /**
       * 获取会话里的标签
       * @param conversation
       */

    }, {
      key: "getTagsForConversation",
      value: function () {
        var _getTagsForConversation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(conversation) {
          return regeneratorRuntime.wrap(function _callee16$(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  return _context16.abrupt("return", this._engine.getTagsForConversation(conversation));

                case 1:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee16, this);
        }));

        function getTagsForConversation(_x27) {
          return _getTagsForConversation.apply(this, arguments);
        }

        return getTagsForConversation;
      }()
      /* ============================= 以下为 CPP 接口 ================================== */

      /**
       * 调用非标准方法。所谓非标准方法，是为某些特定需求或产品添加，暂未作为标准接口添加至 API 层。
       * 对于未实现的方法，接口响应 Unsupport 错误码
       * @param method 方法名
       * @param args
       */

    }, {
      key: "callExtra",
      value: function callExtra(method) {
        var _this$_engine;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return (_this$_engine = this._engine).callExtra.apply(_this$_engine, [method].concat(args));
      }
      /* ============================= 以下为 CPP 接口 ================================== */

      /**
       * 删除所有会话
      */

    }, {
      key: "clearConversations",
      value: function () {
        var _clearConversations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(conversationTypes, tag) {
          return regeneratorRuntime.wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  _context17.next = 2;
                  return this._engine.clearConversations(conversationTypes, tag);

                case 2:
                  return _context17.abrupt("return", _context17.sent);

                case 3:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17, this);
        }));

        function clearConversations(_x28, _x29) {
          return _clearConversations.apply(this, arguments);
        }

        return clearConversations;
      }()
      /**
       * 设置用户连接状态监听器
      */

    }, {
      key: "setUserStatusListener",
      value: function setUserStatusListener(config, listener) {
        return this._engine.setUserStatusListener(config, function (data) {
          try {
            listener(data);
          } catch (error) {
            logger.error(error);
          }
        });
      }
      /**
       * 添加用户黑名单
      */

    }, {
      key: "addToBlacklist",
      value: function () {
        var _addToBlacklist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(userId) {
          return regeneratorRuntime.wrap(function _callee18$(_context18) {
            while (1) {
              switch (_context18.prev = _context18.next) {
                case 0:
                  return _context18.abrupt("return", this._engine.addToBlacklist(userId));

                case 1:
                case "end":
                  return _context18.stop();
              }
            }
          }, _callee18, this);
        }));

        function addToBlacklist(_x30) {
          return _addToBlacklist.apply(this, arguments);
        }

        return addToBlacklist;
      }()
      /**
       * 将指定用户移除黑名单
      */

    }, {
      key: "removeFromBlacklist",
      value: function () {
        var _removeFromBlacklist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(userId) {
          return regeneratorRuntime.wrap(function _callee19$(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  return _context19.abrupt("return", this._engine.removeFromBlacklist(userId));

                case 1:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee19, this);
        }));

        function removeFromBlacklist(_x31) {
          return _removeFromBlacklist.apply(this, arguments);
        }

        return removeFromBlacklist;
      }()
      /**
       * 获取黑名单列表
      */

    }, {
      key: "getBlacklist",
      value: function () {
        var _getBlacklist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
          return regeneratorRuntime.wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  return _context20.abrupt("return", this._engine.getBlacklist());

                case 1:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20, this);
        }));

        function getBlacklist() {
          return _getBlacklist.apply(this, arguments);
        }

        return getBlacklist;
      }()
      /**
       * 获取指定人员在黑名单中的状态
      */

    }, {
      key: "getBlacklistStatus",
      value: function () {
        var _getBlacklistStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(userId) {
          return regeneratorRuntime.wrap(function _callee21$(_context21) {
            while (1) {
              switch (_context21.prev = _context21.next) {
                case 0:
                  return _context21.abrupt("return", this._engine.getBlacklistStatus(userId));

                case 1:
                case "end":
                  return _context21.stop();
              }
            }
          }, _callee21, this);
        }));

        function getBlacklistStatus(_x32) {
          return _getBlacklistStatus.apply(this, arguments);
        }

        return getBlacklistStatus;
      }()
      /**
       * 向本地插入一条消息，不发送到服务器
      */

    }, {
      key: "insertMessage",
      value: function () {
        var _insertMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(conversationType, targetId, insertOptions) {
          return regeneratorRuntime.wrap(function _callee22$(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  return _context22.abrupt("return", this._engine.insertMessage(conversationType, targetId, insertOptions));

                case 1:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee22, this);
        }));

        function insertMessage(_x33, _x34, _x35) {
          return _insertMessage.apply(this, arguments);
        }

        return insertMessage;
      }()
      /**
       * 删除本地消息
      */

    }, {
      key: "deleteMessages",
      value: function () {
        var _deleteMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(timestamp) {
          return regeneratorRuntime.wrap(function _callee23$(_context23) {
            while (1) {
              switch (_context23.prev = _context23.next) {
                case 0:
                  return _context23.abrupt("return", this._engine.deleteMessages(timestamp));

                case 1:
                case "end":
                  return _context23.stop();
              }
            }
          }, _callee23, this);
        }));

        function deleteMessages(_x36) {
          return _deleteMessages.apply(this, arguments);
        }

        return deleteMessages;
      }()
      /**
       * 从本地消息数据库中删除某一会话指定时间之前的消息数据
      */

    }, {
      key: "deleteMessagesByTimestamp",
      value: function () {
        var _deleteMessagesByTimestamp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(conversationType, targetId, timestamp, cleanSpace) {
          var channelId,
              _args24 = arguments;
          return regeneratorRuntime.wrap(function _callee24$(_context24) {
            while (1) {
              switch (_context24.prev = _context24.next) {
                case 0:
                  channelId = _args24.length > 4 && _args24[4] !== undefined ? _args24[4] : '';
                  return _context24.abrupt("return", this._engine.deleteMessagesByTimestamp(conversationType, targetId, timestamp, cleanSpace, channelId));

                case 2:
                case "end":
                  return _context24.stop();
              }
            }
          }, _callee24, this);
        }));

        function deleteMessagesByTimestamp(_x37, _x38, _x39, _x40) {
          return _deleteMessagesByTimestamp.apply(this, arguments);
        }

        return deleteMessagesByTimestamp;
      }()
      /**
       * 清空会话下历史消息
      */

    }, {
      key: "clearMessages",
      value: function () {
        var _clearMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(conversationType, targetId) {
          var channelId,
              _args25 = arguments;
          return regeneratorRuntime.wrap(function _callee25$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  channelId = _args25.length > 2 && _args25[2] !== undefined ? _args25[2] : '';
                  return _context25.abrupt("return", this._engine.clearMessages(conversationType, targetId, channelId));

                case 2:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee25, this);
        }));

        function clearMessages(_x41, _x42) {
          return _clearMessages.apply(this, arguments);
        }

        return clearMessages;
      }()
      /**
       * 获取本地消息
      */

    }, {
      key: "getMessage",
      value: function () {
        var _getMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(messageId) {
          return regeneratorRuntime.wrap(function _callee26$(_context26) {
            while (1) {
              switch (_context26.prev = _context26.next) {
                case 0:
                  return _context26.abrupt("return", this._engine.getMessage(messageId));

                case 1:
                case "end":
                  return _context26.stop();
              }
            }
          }, _callee26, this);
        }));

        function getMessage(_x43) {
          return _getMessage.apply(this, arguments);
        }

        return getMessage;
      }()
      /**
       * 设置消息内容
      */

    }, {
      key: "setMessageContent",
      value: function () {
        var _setMessageContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(messageId, content, messageType) {
          return regeneratorRuntime.wrap(function _callee27$(_context27) {
            while (1) {
              switch (_context27.prev = _context27.next) {
                case 0:
                  return _context27.abrupt("return", this._engine.setMessageContent(messageId, content, messageType));

                case 1:
                case "end":
                  return _context27.stop();
              }
            }
          }, _callee27, this);
        }));

        function setMessageContent(_x44, _x45, _x46) {
          return _setMessageContent.apply(this, arguments);
        }

        return setMessageContent;
      }()
      /**
       * 设置消息搜索字段
      */

    }, {
      key: "setMessageSearchField",
      value: function () {
        var _setMessageSearchField = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(messageId, content, searchFiles) {
          return regeneratorRuntime.wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  return _context28.abrupt("return", this._engine.setMessageSearchField(messageId, content, searchFiles));

                case 1:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28, this);
        }));

        function setMessageSearchField(_x47, _x48, _x49) {
          return _setMessageSearchField.apply(this, arguments);
        }

        return setMessageSearchField;
      }()
      /**
       * 设置消息发送状态
      */

    }, {
      key: "setMessageSentStatus",
      value: function () {
        var _setMessageSentStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(messageId, sentStatus) {
          return regeneratorRuntime.wrap(function _callee29$(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  return _context29.abrupt("return", this._engine.setMessageSentStatus(messageId, sentStatus));

                case 1:
                case "end":
                  return _context29.stop();
              }
            }
          }, _callee29, this);
        }));

        function setMessageSentStatus(_x50, _x51) {
          return _setMessageSentStatus.apply(this, arguments);
        }

        return setMessageSentStatus;
      }()
      /**
      * 设置消息接收状态
      */

    }, {
      key: "setMessageReceivedStatus",
      value: function () {
        var _setMessageReceivedStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(messageId, receivedStatus) {
          return regeneratorRuntime.wrap(function _callee30$(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  return _context30.abrupt("return", this._engine.setMessageReceivedStatus(messageId, receivedStatus));

                case 1:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee30, this);
        }));

        function setMessageReceivedStatus(_x52, _x53) {
          return _setMessageReceivedStatus.apply(this, arguments);
        }

        return setMessageReceivedStatus;
      }()
      /**
       * 设置当前用户在线状态
      */

    }, {
      key: "setUserStatus",
      value: function () {
        var _setUserStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(status) {
          return regeneratorRuntime.wrap(function _callee31$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  return _context31.abrupt("return", this._engine.setUserStatus(status));

                case 1:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee31, this);
        }));

        function setUserStatus(_x54) {
          return _setUserStatus.apply(this, arguments);
        }

        return setUserStatus;
      }()
      /**
       * 订阅用户在线状态
      */

    }, {
      key: "subscribeUserStatus",
      value: function () {
        var _subscribeUserStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(userIds) {
          return regeneratorRuntime.wrap(function _callee32$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  return _context32.abrupt("return", this._engine.subscribeUserStatus(userIds));

                case 1:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee32, this);
        }));

        function subscribeUserStatus(_x55) {
          return _subscribeUserStatus.apply(this, arguments);
        }

        return subscribeUserStatus;
      }()
      /**
       * 获取用户在线状态
      */

    }, {
      key: "getUserStatus",
      value: function () {
        var _getUserStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(userId) {
          return regeneratorRuntime.wrap(function _callee33$(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  return _context33.abrupt("return", this._engine.getUserStatus(userId));

                case 1:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee33, this);
        }));

        function getUserStatus(_x56) {
          return _getUserStatus.apply(this, arguments);
        }

        return getUserStatus;
      }()
    }, {
      key: "searchConversationByContent",
      value: function () {
        var _searchConversationByContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(keyword) {
          var customMessageTypes,
              channelId,
              conversationTypes,
              _args34 = arguments;
          return regeneratorRuntime.wrap(function _callee34$(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  customMessageTypes = _args34.length > 1 && _args34[1] !== undefined ? _args34[1] : [];
                  channelId = _args34.length > 2 && _args34[2] !== undefined ? _args34[2] : '';
                  conversationTypes = _args34.length > 3 ? _args34[3] : undefined;
                  return _context34.abrupt("return", this._engine.searchConversationByContent(keyword, customMessageTypes, channelId, conversationTypes));

                case 4:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee34, this);
        }));

        function searchConversationByContent(_x57) {
          return _searchConversationByContent.apply(this, arguments);
        }

        return searchConversationByContent;
      }()
    }, {
      key: "searchMessageByContent",
      value: function () {
        var _searchMessageByContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(conversationType, targetId, keyword, timestamp, count, total) {
          var channelId,
              _args35 = arguments;
          return regeneratorRuntime.wrap(function _callee35$(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  channelId = _args35.length > 6 && _args35[6] !== undefined ? _args35[6] : '';
                  return _context35.abrupt("return", this._engine.searchMessageByContent(conversationType, targetId, keyword, timestamp, count, total, channelId));

                case 2:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee35, this);
        }));

        function searchMessageByContent(_x58, _x59, _x60, _x61, _x62, _x63) {
          return _searchMessageByContent.apply(this, arguments);
        }

        return searchMessageByContent;
      }()
    }, {
      key: "getUnreadMentionedMessages",
      value: function getUnreadMentionedMessages(conversationType, targetId) {
        var channelId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
        return this._engine.getUnreadMentionedMessages(conversationType, targetId, channelId);
      }
    }, {
      key: "clearUnreadCountByTimestamp",
      value: function clearUnreadCountByTimestamp(conversationType, targetId, timestamp) {
        var channelId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
        return this._engine.clearUnreadCountByTimestamp(conversationType, targetId, timestamp, channelId);
      }
      /**
       * 获取会话免打扰状态
      */

    }, {
      key: "getConversationNotificationStatus",
      value: function getConversationNotificationStatus(conversationType, targetId) {
        var channelId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
        return this._engine.getConversationNotificationStatus(conversationType, targetId, channelId);
      }
    }, {
      key: "getRemoteHistoryMessages",
      value: function getRemoteHistoryMessages(conversationType, targetId, timestamp, count, order, channelId) {
        return this._engine.getRemoteHistoryMessages(conversationType, targetId, timestamp, count, order, channelId);
      }
      /* ============================= CPP 接口 END =================================== */

      /* ============================= 以下为 RTC 相关接口 ============================== */

      /**
       * 加入房间
       * @param roomId
       * @param mode 房间模式：直播 or 会议
       * @param mediaType 直播房间模式下的媒体资源类型
       */

    }, {
      key: "joinRTCRoom",
      value: function joinRTCRoom(roomId, mode, mediaType) {
        return this._engine.joinRTCRoom(roomId, mode, mediaType);
      }
    }, {
      key: "quitRTCRoom",
      value: function quitRTCRoom(roomId) {
        return this._engine.quitRTCRoom(roomId);
      }
    }, {
      key: "rtcPing",
      value: function rtcPing(roomId, mode, mediaType) {
        return this._engine.rtcPing(roomId, mode, mediaType);
      }
    }, {
      key: "getRTCRoomInfo",
      value: function getRTCRoomInfo(roomId) {
        return this._engine.getRTCRoomInfo(roomId);
      }
    }, {
      key: "getRTCUserInfoList",
      value: function getRTCUserInfoList(roomId) {
        return this._engine.getRTCUserInfoList(roomId);
      }
    }, {
      key: "getRTCUserInfo",
      value: function getRTCUserInfo(roomId) {
        return this._engine.getRTCUserInfo(roomId);
      }
    }, {
      key: "setRTCUserInfo",
      value: function setRTCUserInfo(roomId, key, value) {
        return this._engine.setRTCUserInfo(roomId, key, value);
      }
    }, {
      key: "removeRTCUserInfo",
      value: function removeRTCUserInfo(roomId, keys) {
        return this._engine.removeRTCUserInfo(roomId, keys);
      }
    }, {
      key: "setRTCData",
      value: function setRTCData(roomId, key, value, isInner, apiType, message) {
        return this._engine.setRTCData(roomId, key, value, isInner, apiType, message);
      }
    }, {
      key: "setRTCTotalRes",
      value: function setRTCTotalRes(roomId, message, valueInfo, objectName) {
        return this._engine.setRTCTotalRes(roomId, message, valueInfo, objectName);
      }
    }, {
      key: "getRTCData",
      value: function getRTCData(roomId, keys, isInner, apiType) {
        return this._engine.getRTCData(roomId, keys, isInner, apiType);
      }
    }, {
      key: "removeRTCData",
      value: function removeRTCData(roomId, keys, isInner, apiType, message) {
        return this._engine.removeRTCData(roomId, keys, isInner, apiType, message);
      }
    }, {
      key: "setRTCOutData",
      value: function setRTCOutData(roomId, rtcData, type, message) {
        return this._engine.setRTCOutData(roomId, rtcData, type, message);
      }
    }, {
      key: "getRTCOutData",
      value: function getRTCOutData(roomId, userIds) {
        return this._engine.getRTCOutData(roomId, userIds);
      }
    }, {
      key: "getRTCToken",
      value: function getRTCToken(roomId, mode, broadcastType) {
        return this._engine.getRTCToken(roomId, mode, broadcastType);
      } // RTC 北极星数据上报

    }, {
      key: "setRTCState",
      value: function setRTCState(roomId, report) {
        return this._engine.setRTCState(roomId, report);
      }
    }, {
      key: "getRTCUserList",
      value: function getRTCUserList(roomId) {
        return this._engine.getRTCUserList(roomId);
      }
    }], [{
      key: "init",
      value: function init(runtime, options) {
        if ([0, 1, 2, 3, 4].indexOf(options.logLevel) > -1) {
          logger.set(options.logLevel);
        }

        logger.debug('APIContext.init =>', options.appkey, options.navigators);

        if (this._context) {
          logger.error('Repeat initialize!');
          return this._context;
        }

        {
          logger.warn('VersionCode:', "6c6ffee27a93e4fce8289ae56803f3c019f915c0");
        }

        this._context = new APIContext(runtime, options);
        return this._context;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._context) {
          this._context._destroy();

          this._context = undefined;
        }
      }
    }]);

    return APIContext;
  }();

  /**
   * 标签相关接口
   */
  exports.TagChangeType = void 0;

  (function (TagChangeType) {
    TagChangeType[TagChangeType["add"] = 1] = "add";
    TagChangeType[TagChangeType["update"] = 2] = "update";
    TagChangeType[TagChangeType["delete"] = 3] = "delete";
  })(exports.TagChangeType || (exports.TagChangeType = {})); // export interface ITagChange {
  //   type: TagChangeType,
  //   list: ITagParam[]
  // }
  // export interface IReceivedTag {
  //   tagId: string
  //   name?: string
  //   createdTime?: number
  // }

  /**
   * engine 版本号
   */

  var version$1 = "4.3.0-alpha.8";

  exports.AEngine = AEngine;
  exports.ANavi = ANavi;
  exports.APIContext = APIContext;
  exports.AppStorage = AppStorage;
  exports.CPP_PROTOCAL_MSGTYPE_OPTION = CPP_PROTOCAL_MSGTYPE_OPTION;
  exports.CallLibMsgType = CallLibMsgType;
  exports.CometChannel = CometChannel;
  exports.ConnectResultCode = ConnectResultCode;
  exports.ConnectionStatus = ConnectionStatus$1;
  exports.ConversationType = ConversationType$1;
  exports.DelayTimer = DelayTimer;
  exports.ErrorCode = ErrorCode$1;
  exports.EventEmitter = EventEmitter;
  exports.FileType = FileType$1;
  exports.IM_COMET_PULLMSG_TIMEOUT = IM_COMET_PULLMSG_TIMEOUT;
  exports.IM_PING_INTERVAL_TIME = IM_PING_INTERVAL_TIME;
  exports.IM_PING_MAX_TIMEOUT = IM_PING_MAX_TIMEOUT;
  exports.IM_PING_MIN_TIMEOUT = IM_PING_MIN_TIMEOUT;
  exports.IM_SIGNAL_TIMEOUT = IM_SIGNAL_TIMEOUT;
  exports.Logger = Logger;
  exports.MAX_MESSAGE_CONTENT_BYTES = MAX_MESSAGE_CONTENT_BYTES;
  exports.MINI_COMET_CONNECT_URIS = MINI_COMET_CONNECT_URIS;
  exports.MINI_SOCKET_CONNECT_URIS = MINI_SOCKET_CONNECT_URIS;
  exports.MentionedType = MentionedType$1;
  exports.MessageDirection = MessageDirection$1;
  exports.MessageType = MessageType$1;
  exports.NAVI_CACHE_DURATION = NAVI_CACHE_DURATION;
  exports.NAVI_REQ_TIMEOUT = NAVI_REQ_TIMEOUT;
  exports.NotificationStatus = NotificationStatus$1;
  exports.PING_REQ_TIMEOUT = PING_REQ_TIMEOUT;
  exports.PUBLIC_CLOUD_NAVI_URIS = PUBLIC_CLOUD_NAVI_URIS;
  exports.PluginContext = PluginContext;
  exports.RCAssertError = RCAssertError;
  exports.RTCPluginContext = RTCPluginContext;
  exports.ReceivedStatus = ReceivedStatus$1;
  exports.SEND_MESSAGE_TYPE_OPTION = SEND_MESSAGE_TYPE_OPTION;
  exports.STORAGE_ROOT_KEY = STORAGE_ROOT_KEY;
  exports.UploadMethod = UploadMethod$1;
  exports.WEB_SOCKET_TIMEOUT = WEB_SOCKET_TIMEOUT;
  exports.WebSocketChannel = WebSocketChannel;
  exports.appendUrl = appendUrl;
  exports.assert = assert;
  exports.cloneByJSON = cloneByJSON;
  exports.forEach = forEach;
  exports.getMimeKey = getMimeKey;
  exports.getUploadFileName = getUploadFileName;
  exports.indexOf = indexOf$1;
  exports.isArray = isArray$1;
  exports.isArrayBuffer = isArrayBuffer;
  exports.isFunction = isFunction;
  exports.isHttpUrl = isHttpUrl;
  exports.isInObject = isInObject;
  exports.isInclude = isInclude;
  exports.isNull = isNull;
  exports.isNumber = isNumber;
  exports.isObject = isObject$1;
  exports.isString = isString;
  exports.isUndefined = isUndefined;
  exports.isValidChrmEntryKey = isValidChrmEntryKey;
  exports.isValidChrmEntryValue = isValidChrmEntryValue;
  exports.isValidConversationType = isValidConversationType;
  exports.isValidFileType = isValidFileType;
  exports.map = map;
  exports.notEmptyArray = notEmptyArray;
  exports.notEmptyObject = notEmptyObject;
  exports.notEmptyString = notEmptyString;
  exports.pushConfigsToJSON = pushConfigsToJSON;
  exports.todo = todo;
  exports.usingCppEngine = usingCppEngine;
  exports.validate = validate;
  exports.version = version$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
/*
* RongIMLib - v4.3.0-alpha.2
* CommitId - 136374afeafaa25eb5c8f9509518d3e6668d67f8
* Thu Mar 04 2021 10:53:19 GMT+0800 (中国标准时间)
* ©2020 RongCloud, Inc. All rights reserved.
*/
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@rongcloud/engine')) :
typeof define === 'function' && define.amd ? define(['exports', '@rongcloud/engine'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RongIMLib = {}, global.RCEngine));
}(this, (function (exports, engine) { 'use strict';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
  return fn(module, module.exports), module.exports;
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

createCommonjsModule(function (module) {
var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$1 =
  /* global globalThis -- safe */
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
var f$5 = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$2(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

var objectPropertyIsEnumerable = {
  f: f$5
};

var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings



var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has$1 = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var document$3 = global$1.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document$3) && isObject(document$3.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document$3.createElement(it) : {};
};

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
var f$4 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has$1(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};

var objectGetOwnPropertyDescriptor = {
  f: f$4
};

var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
var f$3 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var objectDefineProperty = {
  f: f$3
};

var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function (key, value) {
  try {
    createNonEnumerableProperty(global$1, key, value);
  } catch (error) {
    global$1[key] = value;
  } return value;
};

var SHARED = '__core-js_shared__';
var store$1 = global$1[SHARED] || setGlobal(SHARED, {});

var sharedStore = store$1;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof sharedStore.inspectSource != 'function') {
  sharedStore.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

var inspectSource = sharedStore.inspectSource;

var WeakMap$1 = global$1.WeakMap;

var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

var shared = createCommonjsModule(function (module) {
(module.exports = function (key, value) {
  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.9.1',
  mode: 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});
});

var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys$1 = {};

var WeakMap = global$1.WeakMap;
var set$1, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set$1(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (nativeWeakMap) {
  var store = sharedStore.state || (sharedStore.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set$1 = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys$1[STATE] = true;
  set$1 = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return has$1(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return has$1(it, STATE);
  };
}

var internalState = {
  set: set$1,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var redefine = createCommonjsModule(function (module) {
var getInternalState = internalState.get;
var enforceInternalState = internalState.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has$1(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global$1) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});
});

var path = global$1;

var aFunction$1 = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global$1[namespace])
    : path[namespace] && path[namespace][method] || global$1[namespace] && global$1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min$1 = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength = function (argument) {
  return argument > 0 ? min$1(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$1 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$1(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$1(false)
};

var indexOf = arrayIncludes.indexOf;


var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has$1(hiddenKeys$1, key) && has$1(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has$1(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
var f$2 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys);
};

var objectGetOwnPropertyNames = {
  f: f$2
};

var f$1 = Object.getOwnPropertySymbols;

var objectGetOwnPropertySymbols = {
  f: f$1
};

// all object keys, includes non-enumerable and symbols
var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has$1(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

var isForced_1 = isForced;

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$1;
  } else if (STATIC) {
    target = global$1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global$1[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

var aFunction = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};

// optional / simple context binding
var functionBindContext = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject = function (argument) {
  return Object(requireObjectCoercible(argument));
};

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

var engineIsNode = classofRaw(global$1.process) == 'process';

var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

var process$4 = global$1.process;
var versions = process$4 && process$4.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (engineUserAgent) {
  match = engineUserAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = engineUserAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var engineV8Version = version && +version;

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  /* global Symbol -- required for testing */
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (engineIsNode ? engineV8Version === 38 : engineV8Version > 37 && engineV8Version < 41);
});

var useSymbolAsUid = nativeSymbol
  /* global Symbol -- safe */
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';

var WellKnownSymbolsStore = shared('wks');
var Symbol$1 = global$1.Symbol;
var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

var wellKnownSymbol = function (name) {
  if (!has$1(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (nativeSymbol && has$1(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};

var SPECIES$4 = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES$4];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = functionBindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};

var SPECIES$3 = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return engineV8Version >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$3] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var $map = arrayIteration.map;


var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var nativePromiseConstructor = global$1.Promise;

var redefineAll = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

var defineProperty = objectDefineProperty.f;



var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

var setToStringTag = function (it, TAG, STATIC) {
  if (it && !has$1(it = STATIC ? it : it.prototype, TO_STRING_TAG$3)) {
    defineProperty(it, TO_STRING_TAG$3, { configurable: true, value: TAG });
  }
};

var SPECIES$2 = wellKnownSymbol('species');

var setSpecies = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$2]) {
    defineProperty(Constructor, SPECIES$2, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

var anInstance = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};

var iterators = {};

var ITERATOR$5 = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod = function (it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
};

var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG$2] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof = toStringTagSupport ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var ITERATOR$4 = wellKnownSymbol('iterator');

var getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$4]
    || it['@@iterator']
    || iterators[classof(it)];
};

var iteratorClose = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

var ITERATOR$3 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$3] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$3] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

var SPECIES$1 = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
var speciesConstructor = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction(S);
};

var html = getBuiltIn('document', 'documentElement');

var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

var location = global$1.location;
var set = global$1.setImmediate;
var clear = global$1.clearImmediate;
var process$3 = global$1.process;
var MessageChannel = global$1.MessageChannel;
var Dispatch = global$1.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins -- safe
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global$1.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (engineIsNode) {
    defer = function (id) {
      process$3.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !engineIsIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = functionBindContext(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global$1.addEventListener &&
    typeof postMessage == 'function' &&
    !global$1.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global$1.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
    defer = function (id) {
      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task$1 = {
  set: set,
  clear: clear
};

var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;




var MutationObserver = global$1.MutationObserver || global$1.WebKitMutationObserver;
var document$2 = global$1.document;
var process$2 = global$1.process;
var Promise$1 = global$1.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$1, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify$1, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (engineIsNode && (parent = process$2.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify$1();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
    toggle = true;
    node = document$2.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify$1 = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise$1 && Promise$1.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$1.resolve(undefined);
    then = promise.then;
    notify$1 = function () {
      then.call(promise, flush);
    };
  // Node.js without promises
  } else if (engineIsNode) {
    notify$1 = function () {
      process$2.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify$1 = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global$1, flush);
    };
  }
}

var microtask = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify$1();
  } last = task;
};

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
var f = function (C) {
  return new PromiseCapability(C);
};

var newPromiseCapability$1 = {
  f: f
};

var promiseResolve = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability$1.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var hostReportErrors = function (a, b) {
  var console = global$1.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

var perform = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

var task = task$1.set;











var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState$1 = internalState.get;
var setInternalState$1 = internalState.set;
var getInternalPromiseState = internalState.getterFor(PROMISE);
var PromiseConstructor = nativePromiseConstructor;
var TypeError$1 = global$1.TypeError;
var document$1 = global$1.document;
var process$1 = global$1.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapability$1.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED$1 = isForced_1(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (engineV8Version === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!engineIsNode && !NATIVE_REJECTION_EVENT) return true;
  }
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED$1 || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$1.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  task.call(global$1, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (engineIsNode) {
          process$1.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  task.call(global$1, function () {
    var promise = state.facade;
    if (engineIsNode) {
      process$1.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED$1) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState$1(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = engineIsNode ? process$1.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState$1(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapability$1.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (typeof nativePromiseConstructor == 'function') {
    nativeThen = nativePromiseConstructor.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global$1, arguments));
      }
    });
  }
}

_export({ global: true, wrap: true, forced: FORCED$1 }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
_export({ target: PROMISE, stat: true, forced: FORCED$1 }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

_export({ target: PROMISE, stat: true, forced: FORCED$1 }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(this, x);
  }
});

_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
var objectToString = toStringTagSupport ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!toStringTagSupport) {
  redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
}

var logger = new engine.Logger('RCIM');
logger.set(engine.LogLevel.DEBUG );

var ERROR_INFO = {
  // 超时
  TIMEOUT: {
    code: -1,
    msg: 'Network timeout'
  },
  // SDK 内部错误
  SDK_INTERNAL_ERROR: {
    code: -2,
    msg: 'SDK internal error'
  },
  // 开发者参数传入错误
  PARAMETER_ERROR: {
    code: -3,
    msg: 'Please check the parameters, the {param} expected a value of {expect} but received {current}'
  },
  REJECTED_BY_BLACKLIST: {
    code: 405,
    msg: 'Blacklisted by the other party'
  },
  // 发送频率过快
  SEND_TOO_FAST: {
    code: 20604,
    msg: 'Sending messages too quickly'
  },
  // 不在群组中
  NOT_IN_GROUP: {
    code: 22406,
    msg: 'Not in group'
  },
  // 在群组中被禁言
  FORBIDDEN_IN_GROUP: {
    code: 22408,
    msg: 'Forbbiden from speaking in the group'
  },
  // 不在聊天室中
  NOT_IN_CHATROOM: {
    code: 23406,
    msg: 'Not in chatRoom'
  },
  // 在聊天室中被禁言
  FORBIDDEN_IN_CHATROOM: {
    code: 23408,
    msg: 'Forbbiden from speaking in the chatRoom'
  },
  // 已被踢出并禁止加入聊天室
  KICKED_FROM_CHATROOM: {
    code: 23409,
    msg: 'Kicked out and forbbiden from joining the chatRoom'
  },
  // 聊天室不存在
  CHATROOM_NOT_EXIST: {
    code: 23410,
    msg: 'ChatRoom does not exist'
  },
  // 聊天室成员超限
  CHATROOM_IS_FULL: {
    code: 23411,
    msg: 'ChatRoom members exceeded'
  },
  // 聊天室参数无效
  PARAMETER_INVALID_CHATROOM: {
    code: 23412,
    msg: 'Invalid chatRoom parameters'
  },
  // 聊天室云存储业务未开通
  ROAMING_SERVICE_UNAVAILABLE_CHATROOM: {
    code: 23414,
    msg: 'ChatRoom message roaming service is not open, Please go to the developer to open this service'
  },
  // 撤回消息失败
  RECALLMESSAGE_PARAMETER_INVALID: {
    code: 25101,
    msg: 'Invalid recall message parameter'
  },
  // 未开通单群聊消息云存储服务
  ROAMING_SERVICE_UNAVAILABLE_MESSAGE: {
    code: 25102,
    msg: 'Single group chat roaming service is not open, Please go to the developer to open this service'
  },
  // push 设置参数无效
  PUSHSETTING_PARAMETER_INVALID: {
    code: 26001,
    msg: 'Invalid push parameter'
  },
  // 操作被禁止
  OPERATION_BLOCKED: {
    code: 20605,
    msg: 'Operation is blocked'
  },
  // 操作不支持
  OPERATION_NOT_SUPPORT: {
    code: 20606,
    msg: 'Operation is not supported'
  },
  // 发送的消息中包含敏感词 (发送方发送失败，接收方不会收到消息)
  MSG_BLOCKED_SENSITIVE_WORD: {
    code: 21501,
    msg: 'The sent message contains sensitive words'
  },
  // 消息中敏感词已经被替换 (接收方可以收到被替换之后的消息)
  REPLACED_SENSITIVE_WORD: {
    code: 21502,
    msg: 'Sensitive words in the message have been replaced'
  },
  // 用户未连接成功
  NOT_CONNECTED: {
    code: 30001,
    msg: 'Please connect successfully first'
  },
  // 导航 http 请求失败
  NAVI_REQUEST_ERROR: {
    code: 30007,
    msg: 'Navigation http request failed'
  },
  // CMP 嗅探 http 请求失败
  CMP_REQUEST_ERROR: {
    code: 30010,
    msg: 'CMP sniff http request failed'
  },
  CONN_APPKEY_FAKE: {
    code: 31002,
    msg: 'Your appkey is fake'
  },
  CONN_MINI_SERVICE_NOT_OPEN: {
    code: 31003,
    msg: 'Mini program service is not open, Please go to the developer to open this service'
  },
  CONN_ACK_TIMEOUT: {
    code: 31000,
    msg: 'Connection ACK timeout'
  },
  CONN_TOKEN_INCORRECT: {
    code: 31004,
    msg: 'Your token is not valid or expired'
  },
  CONN_NOT_AUTHRORIZED: {
    code: 31005,
    msg: 'AppKey and Token do not match'
  },
  CONN_REDIRECTED: {
    code: 31006,
    msg: 'Connection redirection'
  },
  CONN_APP_BLOCKED_OR_DELETED: {
    code: 31008,
    msg: 'AppKey is banned or deleted'
  },
  CONN_USER_BLOCKED: {
    code: 31009,
    msg: 'User blocked'
  },
  // 域名无效
  CONN_DOMAIN_INCORRECT: {
    code: 31012,
    msg: 'Connect domain error, Please check the set security domain'
  },
  // 未开通单群聊历史消息云存储
  ROAMING_SERVICE_UNAVAILABLE: {
    code: 33007,
    msg: 'Roaming service cloud is not open, Please go to the developer to open this service'
  },
  // 已连接, 不可再次调用链接(错误码与移动端对齐)
  RC_CONNECTION_EXIST: {
    code: 34001,
    msg: 'Connection already exists'
  },
  // 聊天室 KV 设置超出最大值(已满, 默认最多设置 100 个)
  CHATROOM_KV_EXCEED: {
    code: 23423,
    msg: 'ChatRoom KV setting exceeds maximum'
  },
  // 聊天室 KV 已存在
  CHATROOM_KV_OVERWRITE_INVALID: {
    code: 23424,
    msg: 'ChatRoom KV already exists'
  },
  // 聊天室 KV 存储功能没有开通
  CHATROOM_KV_STORE_NOT_OPEN: {
    code: 23426,
    msg: 'ChatRoom KV storage service is not open, Please go to the developer to open this service'
  },
  // 聊天室Key不存在
  CHATROOM_KEY_NOT_EXIST: {
    code: 23427,
    msg: 'ChatRoom key does not exist'
  },
  // 消息不支持扩展存储(错误码与移动端对齐)
  MSG_KV_NOT_SUPPORT: {
    code: 34008,
    msg: 'The message cannot be extended'
  },
  // 发送扩展存储消息失败(错误码与移动端对齐)
  SEND_MESSAGE_KV_FAIL: {
    code: 34009,
    msg: 'Sending RC expansion message fail'
  },
  // 扩展存储 key value 超出限制(错误码与移动端对齐)
  EXPANSION_LIMIT_EXCEET: {
    code: 34010,
    msg: 'The message expansion size is beyond the limit'
  },
  // 调用接口时传入的参数不正确(错误码与移动端对齐)
  ILLGAL_PARAMS: {
    code: 33003,
    msg: 'Incorrect parameters passed in while calling the interface'
  }
};
var ERROR_CODE = {};

for (var name in ERROR_INFO) {
  var info = ERROR_INFO[name];
  var code = info.code; // ERROR_CODE[name] = code

  ERROR_CODE[code] = name;
} // 服务返回的错误码, 转化为 SDK 的 ErrorCode

var CONNECTION_STATUS = {
  CONNECTED: 0,
  CONNECTING: 1,
  DISCONNECTED: 2,
  NETWORK_UNAVAILABLE: 3,
  SOCKET_ERROR: 4,
  KICKED_OFFLINE_BY_OTHER_CLIENT: 6,
  BLOCKED: 12 // 用户被封禁(服务值为 2, 转为状态码后 + 10)

};

/**
 * 业务层枚举, 此处枚举会暴露给开发者
*/

var CONNECT_TYPE = {
  COMET: 'comet',
  WEBSOCKET: 'websocket'
};
var CONVERSATION_TYPE = engine.ConversationType;
var MESSAGE_DIRECTION = engine.MessageDirection;
var MESSAGS_TIME_ORDER = {
  DESC: 0,
  ASC: 1 // 正序

}; // 聊天室历史消息、聊天室用户信息排序

var CHATROOM_ORDER = {
  ASC: 1,
  DESC: 2
};
var RECALL_MESSAGE_TYPE = 'RC:RcCmd';
var MENTIONED_TYPE = {
  ALL: 1,
  SINGAL: 2
};
var MESSAGE_TYPE = {
  TEXT: 'RC:TxtMsg',
  VOICE: 'RC:VcMsg',
  HQ_VOICE: 'RC:HQVCMsg',
  IMAGE: 'RC:ImgMsg',
  GIF: 'RC:GIFMsg',
  RICH_CONTENT: 'RC:ImgTextMsg',
  LOCATION: 'RC:LBSMsg',
  FILE: 'RC:FileMsg',
  SIGHT: 'RC:SightMsg',
  COMBINE: 'RC:CombineMsg',
  CHRM_KV_NOTIFY: 'RC:chrmKVNotiMsg',
  LOG_COMMAND: 'RC:LogCmdMsg',
  EXPANSION_NOTIFY: 'RC:MsgExMsg',
  REFERENCE: 'RC:ReferenceMsg'
};
var FILE_TYPE = engine.FileType; // 聊天室 kv 存储操作类型. 对方操作, 己方收到消息(RC:chrmKVNotiMsg)中会带入此值. 根据此值判断是删除还是更新

var CHATROOM_ENTRY_TYPE = {
  UPDATE: 1,
  DELETE: 2
};
var NOTIFICATION_STATUS = {
  DO_NOT_DISTURB: 1,
  NOTIFY: 2 // 提醒(非免打扰)

};
var RECEIVED_STATUS = {
  READ: 0x1,
  LISTENED: 0x2,
  DOWNLOADED: 0x4,
  RETRIEVED: 0x8,
  UNREAD: 0 // 未读

};
var SDK_VERSION = "4.3.0-alpha.2";

/**
 * 转化 APIContext 传过来的消息数据
 * @param msg APIContext 消息
 * @returns V3 需要的消息数据
 */

function tranReceivedMessage(msg) {
  var type = msg.conversationType,
      messageType = msg.messageType,
      content = msg.content,
      senderUserId = msg.senderUserId,
      targetId = msg.targetId,
      sentTime = msg.sentTime,
      receivedTime = msg.receivedTime,
      messageUId = msg.messageUId,
      messageDirection = msg.messageDirection,
      isPersited = msg.isPersited,
      isCounted = msg.isCounted,
      isOffLineMessage = msg.isOffLineMessage,
      canIncludeExpansion = msg.canIncludeExpansion,
      expansion = msg.expansion,
      receivedStatus = msg.receivedStatus,
      disableNotification = msg.disableNotification,
      isMentioned = msg.isMentioned,
      isStatusMessage = msg.isStatusMessage;

  if (!receivedStatus) {
    receivedStatus = engine.ReceivedStatus.UNREAD;
  }

  return {
    messageType: messageType,
    content: content,
    senderUserId: senderUserId,
    targetId: targetId,
    type: type,
    sentTime: sentTime,
    receivedTime: receivedTime,
    messageUId: messageUId,
    messageDirection: messageDirection,
    isPersited: isPersited,
    isCounted: isCounted,
    isOffLineMessage: isOffLineMessage,
    isMentioned: isMentioned,
    disableNotification: disableNotification,
    isStatusMessage: isStatusMessage,
    canIncludeExpansion: canIncludeExpansion,
    expansion: expansion,
    receivedStatus: receivedStatus
  };
}
/**
 * 转化 APIContext 传过来的会话数据
 * @param conversation APIContext 会话
 * @returns V3 需要的会话数据
 */

function tranReceiveConversation(conversation) {
  var type = conversation.conversationType,
      targetId = conversation.targetId,
      latestMessage = conversation.latestMessage,
      unreadMessageCount = conversation.unreadMessageCount,
      hasMentioned = conversation.hasMentioned,
      mentionedInfo = conversation.mentionedInfo,
      lastUnreadTime = conversation.lastUnreadTime,
      notificationStatus = conversation.notificationStatus,
      isTop = conversation.isTop;
  var latestMessageV3 = latestMessage && tranReceivedMessage(latestMessage);
  var mentionedInfoV3;

  if (hasMentioned) {
    mentionedInfoV3 = {
      type: mentionedInfo === null || mentionedInfo === void 0 ? void 0 : mentionedInfo.type,
      userIdList: mentionedInfo === null || mentionedInfo === void 0 ? void 0 : mentionedInfo.userIdList
    };
  } else {
    mentionedInfoV3 = undefined;
  }

  return {
    type: type,
    targetId: targetId,
    latestMessage: latestMessageV3,
    unreadMessageCount: unreadMessageCount,
    hasMentioned: hasMentioned,
    mentionedInfo: mentionedInfoV3,
    lastUnreadTime: lastUnreadTime,
    notificationStatus: notificationStatus,
    isTop: isTop
  };
}
function tranReceiveUpdateConversation(conversation) {
  var updatedItems = conversation.updatedItems,
      type = conversation.conversationType,
      targetId = conversation.targetId,
      latestMessage = conversation.latestMessage,
      unreadMessageCount = conversation.unreadMessageCount,
      lastUnreadTime = conversation.lastUnreadTime,
      notificationStatus = conversation.notificationStatus,
      isTop = conversation.isTop,
      mentionedInfo = conversation.mentionedInfo,
      hasMentioned = conversation.hasMentioned;
  var latestMessageV3 = latestMessage && tranReceivedMessage(latestMessage);

  if (updatedItems && updatedItems.latestMessage) {
    updatedItems.latestMessage.val = latestMessageV3;
  }

  return {
    updatedItems: updatedItems,
    type: type,
    targetId: targetId,
    latestMessage: latestMessageV3,
    unreadMessageCount: unreadMessageCount,
    lastUnreadTime: lastUnreadTime,
    notificationStatus: notificationStatus,
    isTop: isTop,
    mentionedInfo: mentionedInfo,
    hasMentioned: hasMentioned
  };
}
/**
 * 校验发消息的参数
 */

function assertSendMsgOption(options) {
  engine.assert('options.messageType', options.messageType, engine.AssertRules.STRING, true);
  engine.assert('options.content', options.content, function (value) {
    return engine.isObject(value);
  }, true);
  engine.assert('options.isPersited', options.isPersited, engine.AssertRules.BOOLEAN);
  engine.assert('options.isCounted', options.isCounted, engine.AssertRules.BOOLEAN);
  engine.assert('options.pushContent', options.pushContent, engine.AssertRules.STRING);
  engine.assert('options.pushData', options.pushData, engine.AssertRules.STRING);
  engine.assert('options.isVoipPush', options.isVoipPush, engine.AssertRules.BOOLEAN);
  engine.assert('options.isStatusMessage', options.isStatusMessage, engine.AssertRules.BOOLEAN);
  engine.assert('options.isMentioned', options.isMentioned, engine.AssertRules.BOOLEAN);
  engine.assert('options.mentionedType', options.mentionedType, engine.AssertRules.NUMBER);
  engine.assert('options.mentionedUserIdList', options.mentionedUserIdList, function (value) {
    return engine.isArray(value) && (value.length === 0 || value.every(engine.isString));
  });
  engine.assert('options.directionalUserIdList', options.directionalUserIdList, function (value) {
    return engine.isArray(value) && (value.length === 0 || value.every(engine.isString));
  });

  if (!engine.isUndefined(options.isPersited) || !engine.isUndefined(options.isCounted) || !engine.isUndefined(options.isStatusMessage)) {
    logger.warn('The parameters `isPersited`, `isCounted`, `isStatusMessage` will be deprecated in future releases due to inconsistance of the values on mobile side and web side. Please use `registerMessageType` instead for non-integrated message type.');
  }
}

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

var arrayMethodIsStrict = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};

var $forEach = arrayIteration.forEach;


var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global$1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {
    createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype$1.forEach = arrayForEach;
  }
}

var createProperty = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
_export({ target: 'Array', proto: true, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

/**
 * 会话排序（拆分-排序-合并）
 * 将会话列表拆分为置顶和非置顶的两个数组
 * 再对两个数组按时间进行排序，时间戳大的说明是最近的消息排最上
*/

var sortConList = function sortConList(conversationList, order) {
  if (!conversationList) {
    return [];
  }

  var splitConversationList = splitConversationListByIsTop(conversationList);

  var topConversationList = _sortListBySentTime(splitConversationList.topConversationList, order);

  var unToppedConversationList = _sortListBySentTime(splitConversationList.unToppedConversationList, order);

  topConversationList.push.apply(topConversationList, unToppedConversationList);
  return topConversationList;
};
var mergeConversationList = function mergeConversationList(option) {
  option = option || {};
  var _option = option,
      conversationList = _option.conversationList,
      updatedConversationList = _option.updatedConversationList;
  conversationList = conversationList || [];
  updatedConversationList = updatedConversationList || [];
  var allConversationList = [].concat(_toConsumableArray(updatedConversationList), _toConsumableArray(conversationList)); // 按顺序合并相同会话的数值(顺序依然为上一步的排序, 只是数值合并, 顺序靠后的数值合并到顺序靠前数值中)

  var hashTable = {};
  var newList = [];
  var invalidDataIndexList = [];
  engine.forEach(allConversationList, function (conversation) {
    if (!engine.isObject(conversation)) {
      // 会话格式错误, 不添加至新列表
      return;
    }

    var _conversation = conversation,
        type = _conversation.type,
        targetId = _conversation.targetId;
    var key = getConversationKey({
      type: type,
      targetId: targetId
    });
    var hashItem = hashTable[key] || {};
    var hashIndex = engine.isUndefined(hashItem.index) ? newList.length : hashItem.index;
    var hashVal = hashItem.val || {};
    var cacheUpdatedItems = hashVal.updatedItems || {};
    var updatedItems = conversation.updatedItems;
    conversation = extend(conversation, hashVal);
    engine.forEach(cacheUpdatedItems, function (item, key) {
      conversation[key] = item.val;
    });
    engine.forEach(updatedItems, function (item, key) {
      var cacheItem = cacheUpdatedItems[key] || {};
      var cacheItemUpdatedTime = cacheItem.time || 0;

      if (item.time > cacheItemUpdatedTime) {
        conversation[key] = item.val;
      }
    });
    hashTable[key] = {
      index: hashIndex,
      val: conversation
    };
    newList[hashIndex] = conversation;
    isInValidConversationData(conversation) && invalidDataIndexList.push(hashIndex);
  });
  engine.forEach(invalidDataIndexList, function (invalidIndex) {
    var conversation = newList[invalidIndex];
    newList[invalidIndex] = fixConversationData(conversation);
  });
  newList = sortConList(newList);
  return engine.map(newList, function (item) {
    delete item.updatedItems;
    return item;
  });
};

var splitConversationListByIsTop = function splitConversationListByIsTop(conversationList) {
  var topConversationList = [];
  var unToppedConversationList = [];
  engine.forEach(conversationList, function (conversation) {
    // 兼容会话中单词拼写错误字段 hasMentiond、mentiondInfo
    var hasMentioned = conversation.hasMentioned,
        mentionedInfo = conversation.mentionedInfo;
    conversation.hasMentioned = hasMentioned;
    conversation.mentionedInfo = mentionedInfo; // 兼容接收

    var isTop = conversation.isTop || false;

    if (isTop) {
      topConversationList.push(conversation);
    } else {
      unToppedConversationList.push(conversation);
    }
  });
  return {
    topConversationList: topConversationList || [],
    unToppedConversationList: unToppedConversationList || []
  };
};

var getConversationKey = function getConversationKey(option) {
  var type = option.type,
      targetId = option.targetId;
  return type + '_' + targetId;
};

var _sortListBySentTime = function _sortListBySentTime(convers) {
  var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return quickSort(convers, function (before, after) {
    before = before || {};
    after = after || {};
    var beforeLatestMessage = before.latestMessage || {};
    var afterLatestMessage = after.latestMessage || {};
    var beforeLatestSentTime = beforeLatestMessage.sentTime || 0;
    var afterLatestSentTime = afterLatestMessage.sentTime || 0;

    if (!order) {
      return afterLatestSentTime <= beforeLatestSentTime;
    }

    return afterLatestSentTime >= beforeLatestSentTime;
  });
};

var fixConversationData = function fixConversationData(conversation) {
  conversation = conversation || {};
  var _conversation2 = conversation,
      targetId = _conversation2.targetId,
      type = _conversation2.type;
  var defaultType = engine.ConversationType.PRIVATE;
  var defaultMsg = {
    messageType: engine.MessageType.TextMessage,
    sentTime: engine.DelayTimer.getTime(),
    content: {
      content: ''
    },
    senderUserId: targetId,
    targetId: targetId,
    type: type
  };
  conversation.type = type || defaultType;
  conversation.targetId = targetId || '';
  conversation.latestMessage = conversation.latestMessage || defaultMsg;
  return conversation;
};

var quickSort = function quickSort(arr, event) {
  var sort = function sort(array, left, right, event) {
    event = event || function (a, b) {
      return a <= b;
    };

    if (left < right) {
      var x = array[right];
      var i = left - 1;
      var temp;

      for (var j = left; j <= right; j++) {
        if (event(array[j], x)) {
          i++;
          temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
      }

      sort(array, left, i - 1, event);
      sort(array, i + 1, right, event);
    }

    return array;
  };

  return sort(arr, 0, arr.length - 1, event);
};

var isInValidConversationData = function isInValidConversationData(conversation) {
  return !conversation.type || !conversation.targetId || !engine.isObject(conversation.latestMessage) || engine.isUndefined(conversation.unreadMessageCount);
};

var extend = function extend(destination, sources, option) {
  option = option || {};
  var _option2 = option,
      isAllowNull = _option2.isAllowNull;
  destination = destination || {};
  sources = sources || {};

  for (var key in sources) {
    var value = sources[key];

    if (!engine.isUndefined(value) || isAllowNull) {
      destination[key] = value;
    }
  }

  return destination;
};

var Conversation = /*#__PURE__*/function () {
  function Conversation(_context, option) {
    _classCallCheck(this, Conversation);

    this._context = _context;
    this.targetId = option.targetId;
    this.type = option.type;
  }
  /**
   * 删除指定会话
   */


  _createClass(Conversation, [{
    key: "destory",
    value: function () {
      var _destory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var code;
        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._context.removeConversation(this.type, this.targetId);

              case 2:
                code = _context2.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee, this);
      }));

      function destory() {
        return _destory.apply(this, arguments);
      }

      return destory;
    }()
    /**
     * 清除会话未读数
     */

  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var code;
        return regeneratorRuntime.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._context.clearUnreadCount(this.type, this.targetId);

              case 2:
                code = _context3.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this);
      }));

      function read() {
        return _read.apply(this, arguments);
      }

      return read;
    }()
    /**
     * 获取指定会话未读数
     */

  }, {
    key: "getUnreadCount",
    value: function () {
      var _getUnreadCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _yield$this$_context$, code, data;

        return regeneratorRuntime.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._context.getUnreadCount(this.type, this.targetId);

              case 2:
                _yield$this$_context$ = _context4.sent;
                code = _yield$this$_context$.code;
                data = _yield$this$_context$.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("return", data);

              case 7:
                return _context4.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3, this);
      }));

      function getUnreadCount() {
        return _getUnreadCount.apply(this, arguments);
      }

      return getUnreadCount;
    }()
    /**
     * 发送消息
     * @param options
     * @deprecated options.isPersited
     * @deprecated options.isCounted
     * @deprecated options.isStatusMessage
     */

  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(options) {
        var _yield$this$_context$2, code, data;

        return regeneratorRuntime.wrap(function _callee4$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                assertSendMsgOption(options);

                if (!Object.prototype.hasOwnProperty.call(options, 'isPersited')) {
                  options.isPersited = true;
                }

                if (!Object.prototype.hasOwnProperty.call(options, 'isCounted')) {
                  options.isCounted = true;
                }

                _context5.next = 5;
                return this._context.sendMessage(this.type, this.targetId, options);

              case 5:
                _yield$this$_context$2 = _context5.sent;
                code = _yield$this$_context$2.code;
                data = _yield$this$_context$2.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context5.next = 10;
                  break;
                }

                return _context5.abrupt("return", tranReceivedMessage(data));

              case 10:
                return _context5.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee4, this);
      }));

      function send(_x) {
        return _send.apply(this, arguments);
      }

      return send;
    }()
    /**
     * 设置会话状态
     */

  }, {
    key: "setStatus",
    value: function () {
      var _setStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(status) {
        var code;
        return regeneratorRuntime.wrap(function _callee5$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                engine.assert('options.notificationStatus', status.notificationStatus, function (value) {
                  return value === 1 || value === 2;
                });
                engine.assert('options.isTop', status.isTop, engine.AssertRules.BOOLEAN);
                _context6.next = 4;
                return this._context.setConversationStatus(this.type, this.targetId, status.isTop, status.notificationStatus);

              case 4:
                code = _context6.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context6.next = 7;
                  break;
                }

                return _context6.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee5, this);
      }));

      function setStatus(_x2) {
        return _setStatus.apply(this, arguments);
      }

      return setStatus;
    }()
    /**
     * 获取历史消息
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(options) {
        var _yield$this$_context$3, code, data, list;

        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                engine.assert('options.timestamp', options.timestamp, engine.AssertRules.NUMBER);
                engine.assert('options.count', options.count, engine.AssertRules.NUMBER);
                engine.assert('options.order', options.order, function (value) {
                  return value === 0 || value === 1;
                });
                _context7.next = 5;
                return this._context.getHistoryMessage(this.type, this.targetId, options === null || options === void 0 ? void 0 : options.timestamp, options === null || options === void 0 ? void 0 : options.count, options === null || options === void 0 ? void 0 : options.order);

              case 5:
                _yield$this$_context$3 = _context7.sent;
                code = _yield$this$_context$3.code;
                data = _yield$this$_context$3.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context7.next = 11;
                  break;
                }

                list = data.list.map(function (item) {
                  return tranReceivedMessage(item);
                });
                return _context7.abrupt("return", Promise.resolve({
                  list: list,
                  hasMore: data.hasMore
                }));

              case 11:
                return _context7.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee6, this);
      }));

      function getMessages(_x3) {
        return _getMessages.apply(this, arguments);
      }

      return getMessages;
    }()
    /**
     * 撤回消息
     * @param options
     */

  }, {
    key: "recall",
    value: function () {
      var _recall = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(options) {
        var recallOptions, _yield$this$_context$4, code, data;

        return regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                engine.assert('options.messageUId', options.messageUId, engine.AssertRules.STRING, true);
                engine.assert('options.sentTime', options.sentTime, engine.AssertRules.NUMBER, true);
                engine.assert('options.disableNotification', options === null || options === void 0 ? void 0 : options.disableNotification, engine.AssertRules.BOOLEAN);
                engine.assert('options.pushConfig', options === null || options === void 0 ? void 0 : options.pushConfig, engine.AssertRules.OBJECT);
                recallOptions = {
                  user: options.user,
                  channelId: '',
                  disableNotification: options === null || options === void 0 ? void 0 : options.disableNotification,
                  pushConfig: options === null || options === void 0 ? void 0 : options.pushConfig
                };
                _context8.next = 7;
                return this._context.recallMessage(this.type, this.targetId, options.messageUId, options.sentTime, recallOptions);

              case 7:
                _yield$this$_context$4 = _context8.sent;
                code = _yield$this$_context$4.code;
                data = _yield$this$_context$4.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context8.next = 12;
                  break;
                }

                return _context8.abrupt("return", tranReceivedMessage(data));

              case 12:
                return _context8.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee7, this);
      }));

      function recall(_x4) {
        return _recall.apply(this, arguments);
      }

      return recall;
    }()
    /**
     * 按消息 id 删除消息
     */

  }, {
    key: "deleteMessages",
    value: function () {
      var _deleteMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(messages) {
        var code;
        return regeneratorRuntime.wrap(function _callee8$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                engine.assert('options', messages, function (value) {
                  return engine.isArray(value) && value.length;
                }, true);
                messages.forEach(function (item) {
                  engine.assert('options.messageUId', item.messageUId, engine.AssertRules.STRING, true);
                  engine.assert('options.sentTime', item.sentTime, engine.AssertRules.NUMBER, true);
                  engine.assert('options.messageDirection', item.messageDirection, function (value) {
                    return value === 1 || value === 2;
                  }, true);
                });
                _context9.next = 4;
                return this._context.deleteRemoteMessage(this.type, this.targetId, messages);

              case 4:
                code = _context9.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context9.next = 7;
                  break;
                }

                return _context9.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee8, this);
      }));

      function deleteMessages(_x5) {
        return _deleteMessages.apply(this, arguments);
      }

      return deleteMessages;
    }()
    /**
     * 按时间戳删除消息
     */

  }, {
    key: "clearMessages",
    value: function () {
      var _clearMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee9$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                engine.assert('options.timestamp', options.timestamp, engine.AssertRules.NUMBER, true);
                _context10.next = 3;
                return this._context.deleteRemoteMessageByTimestamp(this.type, this.targetId, options.timestamp);

              case 3:
                code = _context10.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context10.next = 6;
                  break;
                }

                return _context10.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee9, this);
      }));

      function clearMessages(_x6) {
        return _clearMessages.apply(this, arguments);
      }

      return clearMessages;
    }()
    /**
     * 更新（添加、替换）消息扩展属性
     * @param expansion 要更新的消息扩展信息键值对
     * @param message 要更新的原始消息体
    */

  }, {
    key: "updateMessageExpansion",
    value: function () {
      var _updateMessageExpansion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(expansion, message) {
        var conversationType, targetId, messageUId, canIncludeExpansion, originExpansion, _yield$this$_context$5, code;

        return regeneratorRuntime.wrap(function _callee10$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                engine.assert('expansion', expansion, engine.AssertRules.OBJECT, true);
                engine.assert('message', message, engine.AssertRules.OBJECT, true);
                conversationType = message.type, targetId = message.targetId, messageUId = message.messageUId, canIncludeExpansion = message.canIncludeExpansion, originExpansion = message.expansion;
                _context11.next = 5;
                return this._context.sendExpansionMessage({
                  conversationType: conversationType,
                  targetId: targetId,
                  messageUId: messageUId,
                  expansion: expansion,
                  canIncludeExpansion: canIncludeExpansion,
                  originExpansion: originExpansion
                });

              case 5:
                _yield$this$_context$5 = _context11.sent;
                code = _yield$this$_context$5.code;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context11.next = 9;
                  break;
                }

                return _context11.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee10, this);
      }));

      function updateMessageExpansion(_x7, _x8) {
        return _updateMessageExpansion.apply(this, arguments);
      }

      return updateMessageExpansion;
    }()
    /**
     * 删除扩展存储
     * @params keys 需删除消息扩展的 keys
     * @params message 原始消息体
    */

  }, {
    key: "removeMessageExpansion",
    value: function () {
      var _removeMessageExpansion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(keys, message) {
        var conversationType, targetId, messageUId, canIncludeExpansion, _yield$this$_context$6, code;

        return regeneratorRuntime.wrap(function _callee11$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                engine.assert('keys', keys, engine.AssertRules.ARRAY, true);
                engine.assert('message', message, engine.AssertRules.OBJECT, true);
                conversationType = message.conversationType, targetId = message.targetId, messageUId = message.messageUId, canIncludeExpansion = message.canIncludeExpansion;
                _context12.next = 5;
                return this._context.sendExpansionMessage({
                  conversationType: conversationType,
                  targetId: targetId,
                  messageUId: messageUId,
                  canIncludeExpansion: canIncludeExpansion,
                  keys: keys
                });

              case 5:
                _yield$this$_context$6 = _context12.sent;
                code = _yield$this$_context$6.code;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context12.next = 9;
                  break;
                }

                return _context12.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee11, this);
      }));

      function removeMessageExpansion(_x9, _x10) {
        return _removeMessageExpansion.apply(this, arguments);
      }

      return removeMessageExpansion;
    }()
    /**
     * 设置会话文本草稿
     * @params conversationType 会话乐行
     * @params targetId 目标 ID
     * @params draft 草稿内容
    */

  }, {
    key: "setDraft",
    value: function () {
      var _setDraft = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(draft) {
        var code;
        return regeneratorRuntime.wrap(function _callee12$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                engine.assert('draft', draft, engine.AssertRules.STRING, true);
                _context13.next = 3;
                return this._context.saveConversationMessageDraft(this.type, this.targetId, draft);

              case 3:
                code = _context13.sent;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context13.next = 6;
                  break;
                }

                return _context13.abrupt("return", Promise.resolve());

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee12, this);
      }));

      function setDraft(_x11) {
        return _setDraft.apply(this, arguments);
      }

      return setDraft;
    }()
    /**
     * 获取会话文本草稿
     * @params conversationType 会话乐行
     * @params targetId 目标 ID
    */

  }, {
    key: "getDraft",
    value: function () {
      var _getDraft = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var _yield$this$_context$7, code, data;

        return regeneratorRuntime.wrap(function _callee13$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._context.getConversationMessageDraft(this.type, this.targetId);

              case 2:
                _yield$this$_context$7 = _context14.sent;
                code = _yield$this$_context$7.code;
                data = _yield$this$_context$7.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context14.next = 7;
                  break;
                }

                return _context14.abrupt("return", Promise.resolve(data));

              case 7:
                return _context14.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 8:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee13, this);
      }));

      function getDraft() {
        return _getDraft.apply(this, arguments);
      }

      return getDraft;
    }()
    /**
     * 删除会话文本草稿
     * @params conversationType 会话乐行
     * @params targetId 目标 ID
    */

  }, {
    key: "deleteDraft",
    value: function () {
      var _deleteDraft = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var code;
        return regeneratorRuntime.wrap(function _callee14$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._context.clearConversationMessageDraft(this.type, this.targetId);

              case 2:
                code = _context15.sent;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context15.next = 5;
                  break;
                }

                return _context15.abrupt("return", Promise.resolve());

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee14, this);
      }));

      function deleteDraft() {
        return _deleteDraft.apply(this, arguments);
      }

      return deleteDraft;
    }()
  }]);

  return Conversation;
}();
var ConversationModule = /*#__PURE__*/function () {
  function ConversationModule(apiContext) {
    _classCallCheck(this, ConversationModule);

    this._context = apiContext;
  }
  /**
   * 获取会话列表
   * @param options
   */


  _createClass(ConversationModule, [{
    key: "getList",
    value: function () {
      var _getList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(options) {
        var _yield$this$_context$8, code, data, list;

        return regeneratorRuntime.wrap(function _callee15$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._context.getConversationList(options === null || options === void 0 ? void 0 : options.count, undefined, options === null || options === void 0 ? void 0 : options.startTime, options === null || options === void 0 ? void 0 : options.order);

              case 2:
                _yield$this$_context$8 = _context16.sent;
                code = _yield$this$_context$8.code;
                data = _yield$this$_context$8.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context16.next = 8;
                  break;
                }

                list = data.map(function (item) {
                  return tranReceiveConversation(item);
                });
                return _context16.abrupt("return", sortConList(list));

              case 8:
                return _context16.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 9:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee15, this);
      }));

      function getList(_x12) {
        return _getList.apply(this, arguments);
      }

      return getList;
    }()
    /**
     * 获取指定会话实例，通过实例可实现向指定会话收发消息等功能
     * @description 通过该方法获取的会话可能并不存在于当前的会话列表中，此处只作为功能性封装语法糖
     * @param options
     */

  }, {
    key: "get",
    value: function get(options) {
      engine.assert('options.type', options.type, engine.isValidConversationType, true);
      return new Conversation(this._context, options);
    }
  }, {
    key: "remove",
    value: function remove(options) {
      engine.assert('options.type', options.type, engine.isValidConversationType, true);
      return new Conversation(this._context, options).destory();
    }
    /**
     * 获取当前所有会话的消息未读数
     */

  }, {
    key: "getTotalUnreadCount",
    value: function () {
      var _getTotalUnreadCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var _yield$this$_context$9, code, data;

        return regeneratorRuntime.wrap(function _callee16$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this._context.getTotalUnreadCount('');

              case 2:
                _yield$this$_context$9 = _context17.sent;
                code = _yield$this$_context$9.code;
                data = _yield$this$_context$9.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context17.next = 7;
                  break;
                }

                return _context17.abrupt("return", data);

              case 7:
                return _context17.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee16, this);
      }));

      function getTotalUnreadCount() {
        return _getTotalUnreadCount.apply(this, arguments);
      }

      return getTotalUnreadCount;
    }()
    /**
     * 合并会话
     * @param option
     */

  }, {
    key: "merge",
    value: function merge(option) {
      !option.conversationList && logger.warn('Parameter option.conversationList are required!');
      return mergeConversationList(option);
    }
  }]);

  return ConversationModule;
}();

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
};

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
  return O;
};

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys$1[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: objectCreate(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var $includes = arrayIncludes.includes;


// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
_export({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

/**
 * 校验设置聊天室属性的参数
 * @param options
 */

var assertSetChatRoomEntryOption = function assertSetChatRoomEntryOption(options) {
  engine.assert('options.key', options.key, engine.AssertRules.STRING, true);
  engine.assert('options.value', options.value, engine.AssertRules.STRING, true);
  engine.assert('options.isAutoDelete', options.isAutoDelete, engine.AssertRules.BOOLEAN);
  engine.assert('options.isSendNotification', options.isSendNotification, engine.AssertRules.BOOLEAN);
  engine.assert('options.notificationExtra', options.notificationExtra, engine.AssertRules.STRING);
};
/**
 * 校验删除聊天室属性的参数
 * @param options
 */


var assertRemoveChatRoomEntryOption = function assertRemoveChatRoomEntryOption(options) {
  engine.assert('options.key', options.key, engine.AssertRules.STRING, true);
  engine.assert('options.isSendNotification', options.isSendNotification, engine.AssertRules.BOOLEAN);
  engine.assert('options.notificationExtra', options.notificationExtra, engine.AssertRules.STRING);
};

var Chatroom = /*#__PURE__*/function () {
  function Chatroom(context, id) {
    _classCallCheck(this, Chatroom);

    this._context = context;
    this._id = id;
  }
  /**
   * 加入聊天室
   */


  _createClass(Chatroom, [{
    key: "join",
    value: function () {
      var _join = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                engine.assert('options.count', options.count, engine.AssertRules.NUMBER, true);
                _context.next = 3;
                return this._context.joinChatroom(this._id, options.count);

              case 3:
                code = _context.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function join(_x) {
        return _join.apply(this, arguments);
      }

      return join;
    }()
    /**
     * 加入已存在的聊天室
     */

  }, {
    key: "joinExist",
    value: function () {
      var _joinExist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                engine.assert('options.count', options.count, engine.AssertRules.NUMBER, true);
                _context2.next = 3;
                return this._context.joinExistChatroom(this._id, options.count);

              case 3:
                code = _context2.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function joinExist(_x2) {
        return _joinExist.apply(this, arguments);
      }

      return joinExist;
    }()
    /**
     * 退出聊天室
     */

  }, {
    key: "quit",
    value: function () {
      var _quit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var code;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._context.quitChatroom(this._id);

              case 2:
                code = _context3.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function quit() {
        return _quit.apply(this, arguments);
      }

      return quit;
    }()
    /**
     * 获取聊天室房间数据
     * @description count 或 order 有一个为 0 时，只返回成员总数，不返回成员列表信息
     */

  }, {
    key: "getInfo",
    value: function () {
      var _getInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var options,
            _yield$this$_context$,
            code,
            chatroomInfo,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                engine.assert('options.count', options.count, engine.AssertRules.NUMBER);
                engine.assert('options.order', options.order, function (value) {
                  return [0, 1, 2].includes(value);
                });
                _context4.next = 5;
                return this._context.getChatroomInfo(this._id, options.count, options.order);

              case 5:
                _yield$this$_context$ = _context4.sent;
                code = _yield$this$_context$.code;
                chatroomInfo = _yield$this$_context$.data;

                if (!(code === engine.ErrorCode.SUCCESS && chatroomInfo)) {
                  _context4.next = 10;
                  break;
                }

                return _context4.abrupt("return", chatroomInfo);

              case 10:
                return _context4.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getInfo() {
        return _getInfo.apply(this, arguments);
      }

      return getInfo;
    }()
    /**
     * 设置聊天室自定义属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     */

  }, {
    key: "setEntry",
    value: function () {
      var _setEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                assertSetChatRoomEntryOption(options);
                _context5.next = 3;
                return this._context.setChatroomEntry(this._id, options);

              case 3:
                code = _context5.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function setEntry(_x3) {
        return _setEntry.apply(this, arguments);
      }

      return setEntry;
    }()
    /**
     * 强制 增加/修改 任意聊天室属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     */

  }, {
    key: "forceSetEntry",
    value: function () {
      var _forceSetEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                assertSetChatRoomEntryOption(options);
                _context6.next = 3;
                return this._context.forceSetChatroomEntry(this._id, options);

              case 3:
                code = _context6.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context6.next = 6;
                  break;
                }

                return _context6.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function forceSetEntry(_x4) {
        return _forceSetEntry.apply(this, arguments);
      }

      return forceSetEntry;
    }()
    /**
     * 删除聊天室属性
     * @description 仅限于删除自己设置的聊天室属性
     * @param key 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     * @param isSendNotification? 删除成功后是否发送通知消息
     * @param notificationExtra? RC:chrmKVNotiMsg 通知消息中携带的附加信息
     */

  }, {
    key: "removeEntry",
    value: function () {
      var _removeEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                assertRemoveChatRoomEntryOption(options);
                _context7.next = 3;
                return this._context.removeChatroomEntry(this._id, options);

              case 3:
                code = _context7.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context7.next = 6;
                  break;
                }

                return _context7.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function removeEntry(_x5) {
        return _removeEntry.apply(this, arguments);
      }

      return removeEntry;
    }()
    /**
     * 强制删除聊天室内的任意属性
     * @description
     */

  }, {
    key: "forceRemoveEntry",
    value: function () {
      var _forceRemoveEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(options) {
        var code;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                assertRemoveChatRoomEntryOption(options);
                _context8.next = 3;
                return this._context.forceRemoveChatroomEntry(this._id, options);

              case 3:
                code = _context8.sent;

                if (!(code !== engine.ErrorCode.SUCCESS)) {
                  _context8.next = 6;
                  break;
                }

                return _context8.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function forceRemoveEntry(_x6) {
        return _forceRemoveEntry.apply(this, arguments);
      }

      return forceRemoveEntry;
    }()
    /**
     * 获取聊天室的指定属性
     */

  }, {
    key: "getEntry",
    value: function () {
      var _getEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(key
      /**
       * 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
       */
      ) {
        var _yield$this$_context$2, code, data;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                engine.assert('key', key, function (value) {
                  return engine.isString(value) && /[\w+=-]+/.test(value) && value.length <= 128;
                }, true);
                _context9.next = 3;
                return this._context.getChatroomEntry(this._id, key);

              case 3:
                _yield$this$_context$2 = _context9.sent;
                code = _yield$this$_context$2.code;
                data = _yield$this$_context$2.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context9.next = 8;
                  break;
                }

                return _context9.abrupt("return", data);

              case 8:
                return _context9.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getEntry(_x7) {
        return _getEntry.apply(this, arguments);
      }

      return getEntry;
    }()
    /**
     * 获取聊天室的所有属性
     */

  }, {
    key: "getAllEntries",
    value: function () {
      var _getAllEntries = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var _yield$this$_context$3, code, data;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._context.getAllChatroomEntries(this._id);

              case 2:
                _yield$this$_context$3 = _context10.sent;
                code = _yield$this$_context$3.code;
                data = _yield$this$_context$3.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context10.next = 7;
                  break;
                }

                return _context10.abrupt("return", data);

              case 7:
                return _context10.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getAllEntries() {
        return _getAllEntries.apply(this, arguments);
      }

      return getAllEntries;
    }()
    /**
     * 发送消息
     */

  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(options) {
        var _yield$this$_context$4, code, data;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                assertSendMsgOption(options);

                if (!Object.prototype.hasOwnProperty.call(options, 'isPersited')) {
                  options.isPersited = true;
                }

                if (!Object.prototype.hasOwnProperty.call(options, 'isCounted')) {
                  options.isCounted = true;
                }

                _context11.next = 5;
                return this._context.sendMessage(engine.ConversationType.CHATROOM, this._id, options);

              case 5:
                _yield$this$_context$4 = _context11.sent;
                code = _yield$this$_context$4.code;
                data = _yield$this$_context$4.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context11.next = 10;
                  break;
                }

                return _context11.abrupt("return", tranReceivedMessage(data));

              case 10:
                return _context11.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function send(_x8) {
        return _send.apply(this, arguments);
      }

      return send;
    }()
    /**
     * 获取聊天室的历史消息
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(options) {
        var _yield$this$_context$5, code, data, list;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                engine.assert('options.timestamp', options.timestamp, engine.AssertRules.NUMBER);
                engine.assert('options.count', options.count, engine.AssertRules.NUMBER);
                engine.assert('options.order', options.order, function (value) {
                  return value === 0 || value === 1;
                });
                _context12.next = 5;
                return this._context.getChatRoomHistoryMessages(this._id, options.count, options.order, options.timestamp);

              case 5:
                _yield$this$_context$5 = _context12.sent;
                code = _yield$this$_context$5.code;
                data = _yield$this$_context$5.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context12.next = 11;
                  break;
                }

                list = data.list.map(function (item) {
                  return tranReceivedMessage(item);
                });
                return _context12.abrupt("return", {
                  list: list,
                  hasMore: data.hasMore
                });

              case 11:
                return _context12.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 12:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getMessages(_x9) {
        return _getMessages.apply(this, arguments);
      }

      return getMessages;
    }()
    /**
     * 撤回聊天室消息
    */

  }, {
    key: "recall",
    value: function () {
      var _recall = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(options) {
        var conversationType, _yield$this$_context$6, code, data;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                engine.assert('options.messageUId', options.messageUId, engine.AssertRules.STRING, true);
                engine.assert('options.sentTime', options.sentTime, engine.AssertRules.NUMBER, true);
                conversationType = engine.ConversationType.CHATROOM;
                _context13.next = 5;
                return this._context.recallMessage(conversationType, this._id, options.messageUId, options.sentTime, {
                  channelId: '',
                  user: options.user
                });

              case 5:
                _yield$this$_context$6 = _context13.sent;
                code = _yield$this$_context$6.code;
                data = _yield$this$_context$6.data;

                if (!(code === engine.ErrorCode.SUCCESS && data)) {
                  _context13.next = 10;
                  break;
                }

                return _context13.abrupt("return", tranReceivedMessage(data));

              case 10:
                return _context13.abrupt("return", Promise.reject({
                  code: code,
                  msg: ERROR_CODE[code]
                }));

              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function recall(_x10) {
        return _recall.apply(this, arguments);
      }

      return recall;
    }()
  }]);

  return Chatroom;
}();
var ChatroomModule = /*#__PURE__*/function () {
  function ChatroomModule(apiContext) {
    _classCallCheck(this, ChatroomModule);

    this._context = apiContext;
  }
  /**
   * 根据聊天室 id 初始化一个聊天室功能实例，以实现收发消息等聊天室相关功能
   * @param option
   */


  _createClass(ChatroomModule, [{
    key: "get",
    value: function get(option) {
      engine.assert('option.id', option.id, engine.notEmptyString, true);
      return new Chatroom(this._context, option.id);
    }
  }]);

  return ChatroomModule;
}();

var correctPrototypeGetter = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has$1(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};

var ITERATOR$2 = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false;

var returnThis$2 = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!has$1(IteratorPrototype$2, ITERATOR$2)) {
  createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$2, returnThis$2);
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





var returnThis$1 = function () { return this; };

var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var aPossiblePrototype = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};

/* eslint-disable no-proto -- safe */

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var IteratorPrototype = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
  }
  iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
iterators.Arguments = iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME in domIterables) {
  var Collection = global$1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
}

var RTCClient = /*#__PURE__*/function () {
  function RTCClient(_options, _context) {
    _classCallCheck(this, RTCClient);

    this._options = _options;
    this._context = _context;
    this._roomId = _options.id;
  }

  _createClass(RTCClient, [{
    key: "join",
    value: function () {
      var _join = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _yield$this$_context$, code, data;

        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._context.joinRTCRoom(this._roomId, this._options.mode, this._options.broadcastType);

              case 2:
                _yield$this$_context$ = _context2.sent;
                code = _yield$this$_context$.code;
                data = _yield$this$_context$.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", data);

              case 7:
                return _context2.abrupt("return", Promise.reject(code));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee, this);
      }));

      function join() {
        return _join.apply(this, arguments);
      }

      return join;
    }()
  }, {
    key: "quit",
    value: function () {
      var _quit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var code;
        return regeneratorRuntime.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._context.quitRTCRoom(this._roomId);

              case 2:
                code = _context3.sent;
                return _context3.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this);
      }));

      function quit() {
        return _quit.apply(this, arguments);
      }

      return quit;
    }()
  }, {
    key: "getRoomInfo",
    value: function () {
      var _getRoomInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _yield$this$_context$2, code, data;

        return regeneratorRuntime.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._context.getRTCRoomInfo(this._roomId);

              case 2:
                _yield$this$_context$2 = _context4.sent;
                code = _yield$this$_context$2.code;
                data = _yield$this$_context$2.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("return", data);

              case 7:
                return _context4.abrupt("return", Promise.reject(code));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRoomInfo() {
        return _getRoomInfo.apply(this, arguments);
      }

      return getRoomInfo;
    }()
  }, {
    key: "setUserInfo",
    value: function () {
      var _setUserInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(info) {
        var code;
        return regeneratorRuntime.wrap(function _callee4$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._context.setRTCUserInfo(this._roomId, info.key, info.value);

              case 2:
                code = _context5.sent;
                return _context5.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee4, this);
      }));

      function setUserInfo(_x) {
        return _setUserInfo.apply(this, arguments);
      }

      return setUserInfo;
    }()
  }, {
    key: "removeUserInfo",
    value: function () {
      var _removeUserInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(info) {
        var code;
        return regeneratorRuntime.wrap(function _callee5$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._context.removeRTCUserInfo(this._roomId, info.keys);

              case 2:
                code = _context6.sent;
                return _context6.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee5, this);
      }));

      function removeUserInfo(_x2) {
        return _removeUserInfo.apply(this, arguments);
      }

      return removeUserInfo;
    }()
  }, {
    key: "setData",
    value: function () {
      var _setData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(key, value, isInner, apiType, message) {
        var code;
        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._context.setRTCData(this._roomId, key, value, isInner, apiType, message);

              case 2:
                code = _context7.sent;
                return _context7.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee6, this);
      }));

      function setData(_x3, _x4, _x5, _x6, _x7) {
        return _setData.apply(this, arguments);
      }

      return setData;
    }()
  }, {
    key: "setUserData",
    value: function setUserData(key, value, isInner, message) {
      return this.setData(key, value, isInner, engine.RTCApiType.PERSON, message);
    }
    /**
     * 全量 URI 资源发布
     * @param message 旧版本消息，含消息名及消息内容
     * @param valueInfo 全量消息数据
     * @param objectName 全量 URI 消息名
     */

  }, {
    key: "setRTCUserData",
    value: function () {
      var _setRTCUserData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(message, valueInfo, objectName) {
        var code;
        return regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._context.setRTCTotalRes(this._roomId, message, valueInfo, objectName);

              case 2:
                code = _context8.sent;
                return _context8.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee7, this);
      }));

      function setRTCUserData(_x8, _x9, _x10) {
        return _setRTCUserData.apply(this, arguments);
      }

      return setRTCUserData;
    }()
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(keys, isInner, apiType) {
        var _yield$this$_context$3, code, data;

        return regeneratorRuntime.wrap(function _callee8$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._context.getRTCData(this._roomId, keys, isInner, apiType);

              case 2:
                _yield$this$_context$3 = _context9.sent;
                code = _yield$this$_context$3.code;
                data = _yield$this$_context$3.data;
                return _context9.abrupt("return", code === engine.ErrorCode.SUCCESS ? data : Promise.reject(code));

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee8, this);
      }));

      function getData(_x11, _x12, _x13) {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
  }, {
    key: "getUserData",
    value: function getUserData(keys, isInner) {
      return this.getData(keys, isInner, engine.RTCApiType.PERSON);
    }
  }, {
    key: "removeData",
    value: function () {
      var _removeData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(keys, isInner, apiType, message) {
        var code;
        return regeneratorRuntime.wrap(function _callee9$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._context.removeRTCData(this._roomId, keys, isInner, apiType, message);

              case 2:
                code = _context10.sent;
                return _context10.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee9, this);
      }));

      function removeData(_x14, _x15, _x16, _x17) {
        return _removeData.apply(this, arguments);
      }

      return removeData;
    }()
  }, {
    key: "removeUserData",
    value: function removeUserData(keys, isInner, message) {
      return this.removeData(keys, isInner, engine.RTCApiType.PERSON, message);
    }
  }, {
    key: "setRoomData",
    value: function setRoomData(key, value, isInner, message) {
      return this.setData(key, value, isInner, engine.RTCApiType.ROOM, message);
    }
  }, {
    key: "getRoomData",
    value: function getRoomData(keys, isInner) {
      return this.getData(keys, isInner, engine.RTCApiType.ROOM);
    }
  }, {
    key: "removeRoomData",
    value: function removeRoomData(keys, isInner, message) {
      return this.removeData(keys, isInner, engine.RTCApiType.ROOM, message);
    }
  }, {
    key: "setState",
    value: function () {
      var _setState = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(content) {
        var code;
        return regeneratorRuntime.wrap(function _callee10$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._context.setRTCState(this._roomId, content.report);

              case 2:
                code = _context11.sent;
                return _context11.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee10, this);
      }));

      function setState(_x18) {
        return _setState.apply(this, arguments);
      }

      return setState;
    }()
  }, {
    key: "getUserList",
    value: function () {
      var _getUserList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var _yield$this$_context$4, code, data;

        return regeneratorRuntime.wrap(function _callee11$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._context.getRTCUserInfoList(this._roomId);

              case 2:
                _yield$this$_context$4 = _context12.sent;
                code = _yield$this$_context$4.code;
                data = _yield$this$_context$4.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context12.next = 7;
                  break;
                }

                return _context12.abrupt("return", data);

              case 7:
                return _context12.abrupt("return", Promise.reject(code));

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee11, this);
      }));

      function getUserList() {
        return _getUserList.apply(this, arguments);
      }

      return getUserList;
    }()
  }, {
    key: "getUserInfoList",
    value: function () {
      var _getUserInfoList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var _yield$this$_context$5, code, data, users;

        return regeneratorRuntime.wrap(function _callee12$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._context.getRTCUserInfoList(this._roomId);

              case 2:
                _yield$this$_context$5 = _context13.sent;
                code = _yield$this$_context$5.code;
                data = _yield$this$_context$5.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context13.next = 8;
                  break;
                }

                users = data === null || data === void 0 ? void 0 : data.users;
                return _context13.abrupt("return", users);

              case 8:
                return _context13.abrupt("return", Promise.reject(code));

              case 9:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee12, this);
      }));

      function getUserInfoList() {
        return _getUserInfoList.apply(this, arguments);
      }

      return getUserInfoList;
    }()
  }, {
    key: "getToken",
    value: function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var _yield$this$_context$6, data, code;

        return regeneratorRuntime.wrap(function _callee13$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._context.getRTCToken(this._roomId, this._options.mode, this._options.broadcastType);

              case 2:
                _yield$this$_context$6 = _context14.sent;
                data = _yield$this$_context$6.data;
                code = _yield$this$_context$6.code;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context14.next = 7;
                  break;
                }

                return _context14.abrupt("return", data);

              case 7:
                return _context14.abrupt("return", Promise.reject(code));

              case 8:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee13, this);
      }));

      function getToken() {
        return _getToken.apply(this, arguments);
      }

      return getToken;
    }()
  }, {
    key: "ping",
    value: function () {
      var _ping = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var code;
        return regeneratorRuntime.wrap(function _callee14$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._context.rtcPing(this._roomId, this._options.mode, this._options.broadcastType);

              case 2:
                code = _context15.sent;
                return _context15.abrupt("return", code === engine.ErrorCode.SUCCESS ? code : Promise.reject(code));

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee14, this);
      }));

      function ping() {
        return _ping.apply(this, arguments);
      }

      return ping;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(options) {
        var _yield$this$_context$7, code, data;

        return regeneratorRuntime.wrap(function _callee15$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._context.sendMessage(engine.ConversationType.RTC_ROOM, this._roomId, {
                  content: _objectSpread2({}, options.content),
                  messageType: options.messageType
                });

              case 2:
                _yield$this$_context$7 = _context16.sent;
                code = _yield$this$_context$7.code;
                data = _yield$this$_context$7.data;

                if (!(code === engine.ErrorCode.SUCCESS)) {
                  _context16.next = 7;
                  break;
                }

                return _context16.abrupt("return", data);

              case 7:
                return _context16.abrupt("return", Promise.reject(code));

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee15, this);
      }));

      function send(_x19) {
        return _send.apply(this, arguments);
      }

      return send;
    }()
  }]);

  return RTCClient;
}(); // export class RTCModule {
//   private _context: APIContext
//   constructor (apiContext: APIContext) {
//     this._context = apiContext
//   }
//   /**
//     * 为 RTCLib 提供的 API 接口，业务层不可使用
//     * @private
//     * @param options
//     */
//   get (options: RTCRoomOption) {
//     assert('options.id', options.id, notEmptyString, true)
//     return new RTCClient(options, this._context)
//   }
// }

var slice = [].slice;
var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

var wrap = function (scheduler) {
  return function (handler, timeout /* , ...arguments */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
    } : handler, timeout);
  };
};

// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
_export({ global: true, bind: true, forced: MSIE }, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global$1.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global$1.setInterval)
});

var hasMiniBaseEvent = function hasMiniBaseEvent(miniGlobal) {
  var baseMiniEventNames = ['canIUse', 'getSystemInfo'];

  for (var i = 0, max = baseMiniEventNames.length; i < max; i++) {
    var baseEventName = baseMiniEventNames[i];

    if (!miniGlobal[baseEventName]) {
      return false;
    }
  }

  return true;
};

var isFromUniappEnv = function isFromUniappEnv() {
  if (typeof uni !== 'undefined' && hasMiniBaseEvent(uni)) {
    return true;
  }

  return false;
};

var _window, _window2;
var isFromUniapp$2 = isFromUniappEnv();

var createXHR = function createXHR() {
  var hasCORS = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();

  if (typeof XMLHttpRequest !== 'undefined' && hasCORS) {
    return new XMLHttpRequest();
  } else if (typeof XDomainRequest !== 'undefined') {
    return new XDomainRequest();
  } else {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }
};

function httpReq(options) {
  var method = options.method || engine.HttpMethod.GET;
  var timeout = options.timeout || 60 * 1000;
  var headers = options.headers,
      query = options.query,
      body = options.body;
  var url = engine.appendUrl(options.url, query);
  return new Promise(function (resolve) {
    var xhr = createXHR();
    var isXDomainRequest = Object.prototype.toString.call(xhr) === '[object XDomainRequest]';
    xhr.open(method, url);

    if (headers && xhr.setRequestHeader) {
      for (var key in headers) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }

    if (isXDomainRequest) {
      xhr.timeout = timeout;

      xhr.onload = function () {
        resolve({
          data: xhr.responseText,
          status: xhr.status || 200
        });
      };

      xhr.onerror = function () {
        resolve({
          status: xhr.status || 0
        });
      };

      xhr.ontimeout = function () {
        resolve({
          status: xhr.status || 0
        });
      };

      var reqBody = _typeof(body) === 'object' ? JSON.stringify(body) : body;
      xhr.send(reqBody);
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          resolve({
            data: xhr.responseText,
            status: xhr.status
          });
        }
      };

      xhr.onerror = function () {
        resolve({
          status: xhr.status || 0
        });
      };

      setTimeout(function () {
        return resolve({
          status: xhr.status || 0
        });
      }, timeout);
      xhr.send(body);
    }
  });
}

function createWebSocket(url, protocols) {
  var ws = new WebSocket(url, protocols);
  ws.binaryType = 'arraybuffer';
  return {
    onClose: function onClose(callback) {
      ws.onclose = function (evt) {
        var code = evt.code,
            reason = evt.reason;
        callback(code, reason);
      };
    },
    onError: function onError(callback) {
      ws.onerror = callback;
    },
    onMessage: function onMessage(callback) {
      ws.onmessage = function (evt) {
        callback(evt.data);
      };
    },
    onOpen: function onOpen(callback) {
      ws.onopen = callback;
    },
    send: function send(data) {
      ws.send(data);
    },
    close: function close(code, reason) {
      ws.close(code, reason);
    }
  };
}

var browser = {
  tag: "browser",
  httpReq: httpReq,
  localStorage: (_window = window) === null || _window === void 0 ? void 0 : _window.localStorage,
  sessionStorage: (_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.sessionStorage,
  isSupportSocket: function isSupportSocket() {
    var bool = typeof WebSocket !== 'undefined';
    bool || logger.warn('websocket not support');
    return bool;
  },
  useNavi: true,
  connectPlatform: '',
  isFromUniapp: isFromUniapp$2,
  createWebSocket: createWebSocket,
  createDataChannel: function createDataChannel(watcher, connectType) {
    if (this.isSupportSocket() && connectType === 'websocket') {
      return new engine.WebSocketChannel(this, watcher);
    } else {
      return new engine.CometChannel(this, watcher);
    }
  }
};

var isFromUniapp$1 = isFromUniappEnv();

var createFunc$2 = function createFunc(method) {
  return function () {
    try {
      var _wx;

      return (_wx = wx)[method].apply(_wx, arguments);
    } catch (err) {
      // 此 Bug 是由于微信小程序数据库文件可能会意外损坏导致，目前无解
      logger.error(err);
    }
  };
};

var storage$2 = {
  setItem: createFunc$2('setStorageSync'),
  getItem: createFunc$2('getStorageSync'),
  removeItem: createFunc$2('removeStorageSync'),
  clear: createFunc$2('clearStorageSync')
};
/**
 * @todo
 */

var wechat = {
  tag: "wechat",
  httpReq: function httpReq(options) {
    var method = options.method || engine.HttpMethod.GET;
    var timeout = options.timeout || 60 * 1000;
    var headers = options.headers,
        query = options.query,
        body = options.body;
    var url = engine.appendUrl(options.url, query);
    return new Promise(function (resolve) {
      wx.request({
        url: url,
        method: method,
        headers: headers,
        timeout: timeout,
        data: body,
        success: function success(res) {
          resolve({
            data: res.data,
            status: res.statusCode
          });
        },
        fail: function fail() {
          resolve({
            status: engine.ErrorCode.RC_HTTP_REQ_TIMEOUT
          });
        }
      });
    });
  },
  localStorage: storage$2,
  sessionStorage: storage$2,
  isSupportSocket: function isSupportSocket() {
    return true;
  },
  useNavi: false,
  connectPlatform: 'MiniProgram',
  isFromUniapp: isFromUniapp$1,
  createWebSocket: function createWebSocket(url, protocols) {
    var socketTask = wx.connectSocket({
      url: url,
      protocols: protocols
    });
    return {
      onClose: function onClose(callback) {
        socketTask.onClose(function (res) {
          callback(res.code, res.reason);
        });
      },
      onError: function onError(callback) {
        socketTask.onError(function (res) {
          callback(res.errMsg);
        });
      },
      onMessage: function onMessage(callback) {
        socketTask.onMessage(function (res) {
          callback(res.data);
        });
      },
      onOpen: function onOpen(callback) {
        socketTask.onOpen(callback);
      },
      send: function send(data) {
        socketTask.send({
          data: data
        });
      },
      close: function close(code, reason) {
        socketTask.close({
          code: code,
          reason: reason
        });
      }
    };
  },
  createDataChannel: function createDataChannel(watcher) {
    return new engine.WebSocketChannel(this, watcher);
  }
};

var isFromUniapp = isFromUniappEnv();

var createFunc$1 = function createFunc(method) {
  return function () {
    try {
      var _my;

      return (_my = my)[method].apply(_my, arguments);
    } catch (err) {
      logger.error(err);
    }
  };
};

var storage$1 = {
  setItem: createFunc$1('setStorageSync'),
  getItem: createFunc$1('getStorageSync'),
  removeItem: createFunc$1('removeStorageSync'),
  clear: createFunc$1('clearStorageSync')
};
var alipay = {
  tag: "alipay",
  httpReq: function httpReq(options) {
    var method = options.method || engine.HttpMethod.GET;
    var timeout = options.timeout || 60 * 1000;
    var headers = options.headers,
        query = options.query,
        body = options.body;
    var url = engine.appendUrl(options.url, query);
    return new Promise(function (resolve) {
      my.request({
        url: url,
        method: method,
        headers: headers,
        timeout: timeout,
        data: body,
        success: function success(res) {
          resolve({
            data: res.data,
            status: res.status
          });
        },
        fail: function fail() {
          resolve({
            status: engine.ErrorCode.RC_HTTP_REQ_TIMEOUT
          });
        }
      });
    });
  },
  localStorage: storage$1,
  sessionStorage: storage$1,
  isSupportSocket: function isSupportSocket() {
    return false;
  },
  useNavi: false,
  connectPlatform: 'MiniProgram',
  isFromUniapp: isFromUniapp,
  createDataChannel: function createDataChannel(watcher) {
    return new engine.CometChannel(this, watcher);
  }
};

var createFunc = function createFunc(method) {
  return function () {
    try {
      var _uni;

      return (_uni = uni)[method].apply(_uni, arguments);
    } catch (err) {
      logger.error(err);
    }
  };
};

var storage = {
  setItem: createFunc('setStorageSync'),
  getItem: createFunc('getStorageSync'),
  removeItem: createFunc('removeStorageSync'),
  clear: createFunc('clearStorageSync')
};
/**
 * @todo
 */

var appPlus = {
  tag: "uniapp",
  httpReq: function httpReq(options) {
    var method = options.method || engine.HttpMethod.GET;
    var timeout = options.timeout || 60 * 1000;
    var headers = options.headers,
        query = options.query,
        body = options.body;
    var url = engine.appendUrl(options.url, query);
    return new Promise(function (resolve) {
      uni.request({
        url: url,
        method: method,
        headers: headers,
        timeout: timeout,
        data: body,
        success: function success(res) {
          resolve({
            data: res.data,
            status: res.statusCode
          });
        },
        fail: function fail() {
          resolve({
            status: engine.ErrorCode.RC_HTTP_REQ_TIMEOUT
          });
        }
      });
    });
  },
  localStorage: storage,
  sessionStorage: storage,
  isSupportSocket: function isSupportSocket() {
    return true;
  },
  useNavi: true,
  connectPlatform: '',
  isFromUniapp: true,
  createWebSocket: function createWebSocket(url, protocols) {
    var options = {
      complete: function complete() {},
      url: url,
      protocols: protocols
    };
    var socketTask = uni.connectSocket(options);
    return {
      onClose: function onClose(callback) {
        socketTask.onClose(function (res) {
          callback(res.code, res.reason);
        });
      },
      onError: function onError(callback) {
        socketTask.onError(function (res) {
          callback(res.errMsg);
        });
      },
      onMessage: function onMessage(callback) {
        socketTask.onMessage(function (res) {
          callback(res.data);
        });
      },
      onOpen: function onOpen(callback) {
        socketTask.onOpen(callback);
      },
      send: function send(data) {
        socketTask.send({
          data: data
        });
      },
      close: function close(code, reason) {
        socketTask.close({
          code: code,
          reason: reason
        });
      }
    };
  },
  createDataChannel: function createDataChannel(watcher) {
    return new engine.WebSocketChannel(this, watcher);
  }
};

var uniapp = function uniapp() {
  var uniPlatform = process.env.VUE_APP_PLATFORM;

  switch (uniPlatform) {
    case 'app-plus':
      return appPlus;
    // case 'mp-baidu':
    //   return {}
    // case 'mp-toutiao':
    //   return {}

    case 'mp-alipay':
      return alipay;

    case 'mp-weixin':
      return wechat;

    case 'h5':
    default:
      return browser;
  }
};

var isMiniPrograme = function isMiniPrograme(miniGlobal) {
  return miniGlobal && miniGlobal.canIUse && miniGlobal.getSystemInfo;
};

var runtime = function () {
  if (typeof uni !== 'undefined' && isMiniPrograme(uni)) {
    return uniapp();
  }

  if (typeof wx !== 'undefined' && isMiniPrograme(wx)) {
    return wechat;
  }

  if (typeof my !== 'undefined' && isMiniPrograme(my)) {
    return alipay;
  }

  return browser;
}();

var rtcInnerMsgWatcher = [];
var rtcInnerStatusWatcher = [];
var rtcInnerWatcher = {
  message: function message(_message) {
    rtcInnerMsgWatcher.forEach(function (item) {
      return item(_message);
    });
  },
  status: function status(_status) {
    rtcInnerStatusWatcher.forEach(function (item) {
      return item(_status);
    });
  }
};

var IMClient = /*#__PURE__*/function () {
  function IMClient(apiContext) {
    _classCallCheck(this, IMClient);

    this._token = '';
    this._context = apiContext;
    this.Conversation = new ConversationModule(apiContext);
    this.ChatRoom = new ChatroomModule(apiContext);

    this.RTC = function (options) {
      engine.assert('options.id', options.id, engine.notEmptyString, true);
      return new RTCClient(options, apiContext);
    };
  }
  /**
   * 装载 plugin 插件，并返回相应的插件实例，需在调用 `connect` 方法之前使用
   * @param plugins
   */


  _createClass(IMClient, [{
    key: "install",
    value: function install(plugin, options) {
      return this._context.install(plugin, options);
    }
    /**
     * 添加全局事件监听，同一类型事件会覆盖添加，以避免多次监听引起的复杂问题
     * @param options
     */

  }, {
    key: "watch",
    value: function watch(options) {
      var statusListener = options.status,
          conversationListener = options.conversation,
          messageListener = options.message,
          chatroomListener = options.chatroom,
          expansionListener = options.expansion;
      var watcher = {};

      if (statusListener) {
        watcher.connectionState = function (status) {
          // 对业务层的方法要增加 catch 捕获，避免影响内部调用栈的继续进行
          try {
            statusListener({
              status: status
            });
          } catch (err) {
            logger.error(err);
          }
        };
      }

      if (conversationListener) {
        watcher.conversationState = function (conversations) {
          try {
            var list = conversations.map(function (item) {
              return tranReceiveUpdateConversation(item);
            });
            conversationListener({
              updatedConversationList: list
            });
          } catch (err) {
            logger.error(err);
          }
        };
      }

      if (messageListener) {
        watcher.message = function (message) {
          try {
            messageListener({
              message: tranReceivedMessage(message)
            });
          } catch (err) {
            logger.error(err);
          }
        };
      }

      if (chatroomListener) {
        watcher.chatroomState = function (event) {
          try {
            chatroomListener(event);
          } catch (err) {
            logger.error(err);
          }
        };
      }

      if (expansionListener) {
        watcher.expansion = function (event) {
          try {
            expansionListener(event);
          } catch (err) {
            logger.error(err);
          }
        };
      }

      this._context.assignWatcher(watcher);
    }
  }, {
    key: "unwatch",
    value: function unwatch() {
      this._context.assignWatcher({
        message: undefined,
        connectionState: undefined,
        conversationState: undefined,
        chatroomState: undefined,
        expansion: undefined
      });
    }
  }, {
    key: "rtcInnerWatch",
    value: function rtcInnerWatch(attrs) {
      var messageListener = attrs.message,
          statusListener = attrs.status;

      if (messageListener) {
        rtcInnerMsgWatcher.push(function (message) {
          try {
            messageListener({
              message: tranReceivedMessage(message)
            });
          } catch (err) {
            logger.error(err);
          }
        });
      }

      if (statusListener) {
        rtcInnerStatusWatcher.push(function (status) {
          try {
            statusListener({
              status: status
            });
          } catch (err) {
            logger.error(err);
          }
        });
      }

      this._context.assignWatcher({
        rtcInnerWatcher: rtcInnerWatcher
      });
    }
  }, {
    key: "rtcInnerUnwatch",
    value: function rtcInnerUnwatch() {
      rtcInnerStatusWatcher.length = rtcInnerStatusWatcher.length = 0;

      this._context.assignWatcher({
        rtcInnerWatcher: undefined
      });
    }
    /**
     * 建立 IM 连接
     * @param options
     */

  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(options) {
        var token, res;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                engine.assert('options.token', options.token, engine.AssertRules.STRING, true);
                token = options.token;
                this._token = token;
                _context.next = 5;
                return this._context.connect(token, true);

              case 5:
                res = _context.sent;

                if (!(res.code === engine.ErrorCode.SUCCESS)) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", {
                  id: res.userId
                });

              case 8:
                return _context.abrupt("return", Promise.reject({
                  code: res.code,
                  msg: ERROR_CODE[res.code]
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function connect(_x) {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
    /**
     * 使用上一次的链接 token 重新建立连接，该方法只需在主动调用 `disconnect` 方法之后有重连需求时调用
     */

  }, {
    key: "reconnect",
    value: function () {
      var _reconnect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var res;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._context.reconnect();

              case 2:
                res = _context2.sent;

                if (!(res.code === engine.ErrorCode.SUCCESS)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", {
                  id: res.userId
                });

              case 5:
                return _context2.abrupt("return", Promise.reject({
                  code: res.code,
                  msg: ERROR_CODE[res.code]
                }));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function reconnect() {
        return _reconnect.apply(this, arguments);
      }

      return reconnect;
    }()
    /**
     * 断开当前用户的连接
     * @description 调用后将不再接收消息，不可发送消息，不可获取历史消息，不可获取会话列表
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._context.disconnect();
    }
    /**
     * 获取当前 IM 环境信息
     */

  }, {
    key: "getAppInfo",
    value: function getAppInfo() {
      return {
        appkey: this._context.appkey,
        token: this._token,
        navi: this._context.getInfoFromCache()
      };
    }
    /**
     * 获取 IM 连接时间
     */

  }, {
    key: "getConnectedTime",
    value: function getConnectedTime() {
      return this._context.getConnectedTime();
    }
    /**
     * 获取 IM 连接状态
     */

  }, {
    key: "getConnectionStatus",
    value: function getConnectionStatus() {
      return this._context.getConnectionStatus();
    }
    /**
     * 获取 IM 连接用户的 id
     */

  }, {
    key: "getConnectionUserId",
    value: function getConnectionUserId() {
      return this._context.getCurrentUserId();
    }
    /**
     * 获取文件 token
     * @description 上传文件时，获取文件 token
     * @param fileType 上传类型, 通过 RongIMLib.FILE_TYPE 获取
     * @param fileName 上传文件名，Server 通过文件名生成百度上传认证, 若不传 engine 自动生成
     */

  }, {
    key: "getFileToken",
    value: function getFileToken(fileType, fileName) {
      engine.assert('fileType', fileType, engine.isValidFileType, true);
      return this._context.getFileToken(fileType, fileName);
    }
    /**
     * 获取文件上传后的下载地址
     */

  }, {
    key: "getFileUrl",
    value: function getFileUrl(
    /**
     * 上传类型, 通过 RongIMLib.FILE_TYPE 获取
     */
    fileType,
    /**
     * 上传后的文件名
     */
    filename,
    /**
     * 原始文件名
     */
    oriname,
    /**
     * 上传成功返回数据
     * 百度 bos 上传地址即为下载地址，IM Server 不会返回百度 bos 下载地址，通过用户层传入再返回
    */
    uploadRes,
    /**
     * 上传方式，阿里或七牛，RongIMLib.UploadMethod 获取
     */
    uploadMethod) {
      engine.assert('fileType', fileType, engine.isValidFileType, true);
      engine.assert('filename', filename, engine.AssertRules.STRING);
      engine.assert('oriname', oriname, engine.AssertRules.STRING);
      engine.assert('uploadMethod', uploadMethod, engine.AssertRules.NUMBER);
      return this._context.getFileUrl(fileType, filename, oriname, uploadRes, uploadMethod);
    }
    /**
     * 切换用户，作用等同于断开当前用户连接，以新的 token 重新建立连接
     * @deprecated
     * @param option
     */

  }, {
    key: "changeUser",
    value: function () {
      var _changeUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(options) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                logger.warn('Method is deprecated');
                engine.assert('options.token', options.token, engine.AssertRules.STRING, true);
                _context3.next = 4;
                return this.disconnect();

              case 4:
                return _context3.abrupt("return", this.connect(options));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function changeUser(_x2) {
        return _changeUser.apply(this, arguments);
      }

      return changeUser;
    }()
    /**
     * 注册自定义消息
     * @param messageType 消息类型
     * @param isPersited  是否存储
     * @param isCounted   是否计数
     * @param prototypes  消息属性名称
    */

  }, {
    key: "registerMessageType",
    value: function registerMessageType(messageType, isPersited, isCounted, prototypes) {
      this._context.registerMessageType(messageType, isPersited, isCounted, prototypes);
    }
  }]);

  return IMClient;
}();

var imInstance;
/**
 * 初始化
 * @param {IInitOption} options
 */

var init = function init(options) {
  if (imInstance) {
    logger.error('The instance already exists. Do not repeatedly call the init method');
    return imInstance;
  }

  engine.assert('options.appkey', options.appkey, engine.AssertRules.STRING, true);
  engine.assert('options.debug', options.debug, engine.AssertRules.BOOLEAN);
  engine.assert('options.navigators', options.navigators, function (value) {
    return engine.isArray(value) && (value.length === 0 || value.every(engine.isHttpUrl));
  });

  if ([0, 1, 2, 3, 4].indexOf(options.logLevel) > -1) {
    logger.set(options.logLevel);
  }

  var context = engine.APIContext.init(runtime, {
    appkey: options.appkey,
    apiVersion: "4.3.0-alpha.2",
    navigators: options.navigators || [],
    miniCMPProxy: options.customCMP || [],
    connectionType: options.connectType || 'websocket',
    logLevel: options.logLevel
  });
  imInstance = new IMClient(context);
  return imInstance;
};
var getInstance = function getInstance() {
  if (!imInstance) {
    logger.error('Please call the init method first');
  }

  return imInstance;
};

Object.defineProperty(exports, 'ConnectionStatus', {
  enumerable: true,
  get: function () {
    return engine.ConnectionStatus;
  }
});
Object.defineProperty(exports, 'LogLevel', {
  enumerable: true,
  get: function () {
    return engine.LogLevel;
  }
});
Object.defineProperty(exports, 'UploadMethod', {
  enumerable: true,
  get: function () {
    return engine.UploadMethod;
  }
});
exports.CHATROOM_ENTRY_TYPE = CHATROOM_ENTRY_TYPE;
exports.CHATROOM_ORDER = CHATROOM_ORDER;
exports.CONNECTION_STATUS = CONNECTION_STATUS;
exports.CONNECT_TYPE = CONNECT_TYPE;
exports.CONVERSATION_TYPE = CONVERSATION_TYPE;
exports.ERROR_CODE = ERROR_CODE;
exports.FILE_TYPE = FILE_TYPE;
exports.IMClient = IMClient;
exports.MENTIONED_TYPE = MENTIONED_TYPE;
exports.MESSAGE_DIRECTION = MESSAGE_DIRECTION;
exports.MESSAGE_TYPE = MESSAGE_TYPE;
exports.MESSAGS_TIME_ORDER = MESSAGS_TIME_ORDER;
exports.NOTIFICATION_STATUS = NOTIFICATION_STATUS;
exports.RECALL_MESSAGE_TYPE = RECALL_MESSAGE_TYPE;
exports.RECEIVED_STATUS = RECEIVED_STATUS;
exports.SDK_VERSION = SDK_VERSION;
exports.getInstance = getInstance;
exports.init = init;

Object.defineProperty(exports, '__esModule', { value: true });

})));
